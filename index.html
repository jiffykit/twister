<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twịz⊥</title>
    <style>
        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 8px;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 1600px;
            height: calc(100vh - 16px);
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 1.6em;
            margin-bottom: 8px;
            text-align: center;
            background: linear-gradient(45deg, #4f0643, #4ecdc4, #225703, #96ceb4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
            flex: 1;
            overflow: hidden;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }

        .control-group h3 {
            margin: 0 0 8px 0;
            font-size: 0.95em;
            color: #4ecdc4;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 4px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #e0e0e0;
            font-size: 0.85em;
        }

        input[type="file"] {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: #fff;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        input[type="file"]:hover,
        .file-drop-zone:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-drop-zone {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop-zone.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: scale(1.02);
        }

        .file-drop-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .file-drop-hint {
            color: #999;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        select {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            font-size: 0.95em;
            width: 100%;
            transition: all 0.3s ease;
        }

        select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #222;
            color: #fff;
            padding: 8px;
        }

        .function-grid {
            display: none;
            /* Hide the grid, we'll use a dropdown */
        }

        .function-select {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            font-size: 0.95em;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
            max-height: 400px;
        }

        .function-select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .function-select option {
            background: #222;
            color: #fff;
            padding: 8px 12px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .function-select option:hover {
            background: #333;
            border-left-color: #4ecdc4;
        }

        .function-select optgroup {
            background: #1a1a1a;
            color: #4ecdc4;
            font-weight: bold;
            font-size: 0.9em;
            border-top: 1px solid rgba(78, 205, 196, 0.3);
            margin-top: 2px;
            padding: 6px 8px;
        }

        .function-select optgroup:first-child {
            border-top: none;
            margin-top: 0;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            color: #fff;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stop-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .stop-btn:hover {
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.6);
        }

        .realtime-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .realtime-btn:hover {
            box-shadow: 0 6px 25px rgba(78, 205, 196, 0.6);
        }

        #status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
        }

        .error {
            background: rgba(255, 51, 51, 0.2);
            border: 1px solid #ff3333;
        }

        .success {
            background: rgba(51, 255, 51, 0.2);
            border: 1px solid #33ff33;
        }

        .info {
            background: rgba(51, 51, 255, 0.2);
            border: 1px solid #3333ff;
        }

        .value-display {
            font-weight: 700;
            color: #4ecdc4;
            font-size: 1.1em;
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }

        .memory-info {
            font-size: 0.9em;
            color: #888;
            text-align: center;
            margin-top: 15px;
        }

        .visualizer {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 120px;
            border-radius: 8px;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
        }

        .compact-layout {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .compact-control {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .compact-control label {
            margin-bottom: 3px;
            font-size: 0.8em;
        }

        .toggle-container {
            display: flex;
            gap: 2px;
            margin-top: 3px;
        }

        .toggle-btn {
            flex: 1;
            padding: 6px 3px;
            font-size: 0.75em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            box-shadow: 0 2px 8px rgba(78, 205, 196, 0.4);
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            color: #888;
            margin-top: 2px;
        }

        .button-group {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 8px 0;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 20px;
            color: #fff;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .compact-layout {
                grid-template-columns: 1fr;
            }
        }

        .value-display {
            font-weight: 700;
            color: #4ecdc4;
            font-size: 1.0em;
        }

        .memory-info {
            font-size: 0.8em;
            color: #888;
            text-align: center;
            margin-top: 8px;
        }

        #status {
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }

        .error {
            background: rgba(255, 51, 51, 0.2);
            border: 1px solid #ff3333;
        }

        .success {
            background: rgba(51, 255, 51, 0.2);
            border: 1px solid #33ff33;
        }

        .info {
            background: rgba(51, 51, 255, 0.2);
            border: 1px solid #3333ff;
        }

        /* Dual-handle slider styling */
        .dual-slider-container {
            position: relative;
            margin: 10px 0;
        }

        .main-slider {
            width: 100%;
            position: relative;
            z-index: 1;
            transition: all 0.1s ease;
        }

        .main-slider.animated {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffd93d);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .main-slider.animated::-webkit-slider-thumb {
            background: radial-gradient(circle, #fff, #4ecdc4);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
            animation: modulation-pulse 1s ease-in-out infinite alternate;
        }

        @keyframes modulation-pulse {
            from {
                transform: scale(1.0);
                box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
            }

            to {
                transform: scale(1.2);
                box-shadow: 0 0 20px rgba(78, 205, 196, 1.0);
            }
        }

        /* Legacy mod-handle styling (kept for modulation sliders) */
        .mod-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: transparent;
            pointer-events: none;
            z-index: 2;
            -webkit-appearance: none;
            appearance: none;
            height: 100%;
        }

        .mod-handle::-webkit-slider-track {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
        }

        .mod-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
            pointer-events: auto;
            cursor: pointer;
            transform: scale(0.9);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            -webkit-appearance: none;
            appearance: none;
        }

        /* FIXED: Compact dual slider - single track appearance */
        .dual-slider-container {
            position: relative;
            margin: 6px 0;
            height: 16px;
        }

        /* Show main slider when modulation is disabled, hide when enabled */
        .dual-slider-container.modulation-disabled .main-slider {
            display: block !important;
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 16px;
            z-index: 5;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .dual-slider-container:not(.modulation-disabled) .main-slider {
            display: none !important;
        }

        .slider-track {
            position: absolute;
            top: 6px;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 2px;
            z-index: 1;
        }

        .dual-handle {
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 16px;
            background: transparent;
            pointer-events: none;
            z-index: 3;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Main slider styling when modulation is disabled - green handle appearance */
        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-track {
            background: transparent;
            height: 4px;
        }

        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
            cursor: pointer;
            position: relative;
            z-index: 6;
        }

        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #20bf6b, #26de81) !important;
            box-shadow: 0 0 12px rgba(46, 213, 115, 0.8) !important;
            transform: scale(1.1);
        }

        .dual-handle::-webkit-slider-track {
            background: transparent;
            height: 4px;
        }

        .dual-handle::-webkit-slider-thumb {
            pointer-events: auto;
            cursor: pointer;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            -webkit-appearance: none;
            appearance: none;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 4;
        }

        .dual-handle::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
        }

        /* Green handle styling for minimum values */
        .green-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
        }

        .green-handle::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #20bf6b, #26de81) !important;
            box-shadow: 0 0 12px rgba(46, 213, 115, 0.8) !important;
        }

        /* Red handle styling for maximum values */
        .red-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff4757) !important;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6) !important;
        }

        .red-handle::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #ff5252, #ff3742) !important;
            box-shadow: 0 0 12px rgba(255, 107, 107, 0.8) !important;
        }

        .handle-labels {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            z-index: 2;
        }

        .min-label {
            color: #2ed573;
            font-weight: 600;
        }

        .max-label {
            color: #ff6b6b;
            font-weight: 600;
        }

        /* Special styling for modulation sliders */
        #modMinSlider::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff4757) !important;
            border: 2px solid #fff !important;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6) !important;
        }

        #modMaxSlider::-webkit-slider-thumb {
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            border: 2px solid #fff !important;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
        }

        .modulation-range-display {
            font-size: 0.85em;
            color: #ff6b6b;
            margin-top: 5px;
            text-align: center;
            opacity: 0.9;
            font-weight: 500;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
        }

        /* Pulse indicator for modulation */
        .pulse-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: left 0.1s ease-out, opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }

        .dual-slider-container:not(.modulation-disabled) .pulse-indicator {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0.7;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* Show mod handles only when modulation is enabled */
        .modulation-disabled .mod-handle {
            display: none;
        }

        .modulation-disabled .modulation-range-display {
            display: none;
        }

        /* Hide dual handles when modulation is disabled */
        .modulation-disabled .dual-handle {
            display: none !important;
        }

        /* LUFS display styling */
        .lufs-display {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 4px;
            padding: 3px 6px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-align: center;
            font-size: 0.75em;
        }

        .toggle-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: #fff;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.4);
        }

        input[type="range"] {
            width: 100%;
            margin: 6px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 3px;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        select {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
            width: 100%;
            transition: all 0.3s ease;
        }

        select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #222;
            color: #fff;
            padding: 6px;
        }

        .function-select {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
            max-height: 400px;
        }

        .function-select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .function-select option {
            background: #222;
            color: #fff;
            padding: 6px 10px;
            border-left: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .function-select option:hover {
            background: #333;
            border-left-color: #4ecdc4;
        }

        .function-select optgroup {
            background: #1a1a1a;
            color: #4ecdc4;
            font-weight: bold;
            font-size: 0.8em;
            border-top: 1px solid rgba(78, 205, 196, 0.3);
            margin-top: 1px;
            padding: 4px 6px;
        }

        .function-select optgroup:first-child {
            border-top: none;
            margin-top: 0;
        }

        input[type="file"] {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        input[type="file"]:hover,
        .file-drop-zone:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-drop-zone {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop-zone.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: scale(1.02);
        }

        .file-drop-text {
            color: #e0e0e0;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .file-drop-hint {
            color: #999;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Twịz⊥</h1>

        <div class="controls-grid">
            <!-- Dual Track System -->
            <div class="control-group">
                <h3>WTF</h3>

                <!-- Track A -->
                <div
                    style="border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(78, 205, 196, 0.05);">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.85em; color: #4ecdc4;">🎵 Track A</h4>

                    <!-- File Drop Zone Row -->
                    <div class="file-drop-zone" id="fileDropZoneA"
                        style="padding: 4px 8px; margin-bottom: 8px; position: relative; border: 1px dashed rgba(78, 205, 196, 0.5); border-radius: 4px; height: 20px; overflow: hidden;">
                        <div class="file-drop-text" style="font-size: 11px; text-align: center; line-height: 12px;">🎵
                            Drop audio file A here or click</div>
                        <input type="file" id="fileInputA" accept="audio/*"
                            style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 20px; cursor: pointer; z-index: 1;">
                    </div>

                    <!-- Controls Row -->
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                        <button type="button" id="playBtnA" style="padding: 4px 6px; font-size: 0.75em;">▶️ Play
                            A</button>
                        <button type="button" id="stopBtnA" style="padding: 4px 6px; font-size: 0.75em;">⏹️
                            Stop</button>
                    </div>

                    <!-- Time Slider Row -->
                    <div class="compact-control" style="margin-top: 4px;">
                        <label for="timeSliderA" style="font-size: 0.75em;">Time A: <span class="value-display"
                                id="timeValueA">0:00</span></label>
                        <input type="range" id="timeSliderA" min="0" max="100" step="0.1" value="0"
                            style="height: 4px;">
                    </div>
                </div>

                <!-- Track B -->
                <div
                    style="border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(255, 107, 107, 0.05);">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.85em; color: #ff6b6b;">🎵 Track B</h4>

                    <!-- File Drop Zone Row -->
                    <div class="file-drop-zone" id="fileDropZoneB"
                        style="padding: 4px 8px; margin-bottom: 8px; position: relative; border: 1px dashed rgba(255, 107, 107, 0.5); border-radius: 4px; height: 20px; overflow: hidden;">
                        <div class="file-drop-text" style="font-size: 11px; text-align: center; line-height: 12px;">🎵
                            Drop audio file B here or click</div>
                        <input type="file" id="fileInputB" accept="audio/*"
                            style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 20px; cursor: pointer; z-index: 1;">
                    </div>

                    <!-- Controls Row -->
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                        <button type="button" id="playBtnB" style="padding: 4px 6px; font-size: 0.75em;">▶️ Play
                            B</button>
                        <button type="button" id="stopBtnB" style="padding: 4px 6px; font-size: 0.75em;">⏹️
                            Stop</button>
                    </div>

                    <!-- Time Slider Row -->
                    <div class="compact-control" style="margin-top: 4px;">
                        <label for="timeSliderB" style="font-size: 0.75em;">Time B: <span class="value-display"
                                id="timeValueB">0:00</span></label>
                        <input type="range" id="timeSliderB" min="0" max="100" step="0.1" value="0"
                            style="height: 4px;">
                    </div>
                </div>

                <!-- Crossfader -->
                <div
                    style="border: 1px solid rgba(150, 206, 180, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(150, 206, 180, 0.05);">
                    <div class="compact-control">
                        <label for="crossfaderSlider" style="font-size: 0.85em; color: #96ceb4;">🎚️ Crossfader: <span
                                class="value-display" id="crossfaderValue">A ←→ B</span></label>
                        <input type="range" id="crossfaderSlider" min="0" max="100" step="1" value="0"
                            style="background: linear-gradient(90deg, #4ecdc4, #96ceb4, #ff6b6b);">
                        <div class="slider-info">
                            <span style="color: #4ecdc4;">A Only</span>
                            <span style="color: #96ceb4;">Mix</span>
                            <span style="color: #ff6b6b;">B Only</span>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 4px;">
                        <label style="font-size: 0.75em;">
                            <input type="checkbox" id="fadeSyncCrossfader" style="margin-right: 4px;">
                            FadeSync - Effects fade with crossfader mix
                        </label>
                    </div>
                </div>

                <!-- Master Controls -->
                <div style="margin-top: 8px;">
                    <!-- Buttons removed as requested -->
                </div>

                <div id="status" style="margin-top: 6px; font-size: 0.75em;"></div>
                <div class="memory-info" id="memoryInfo" style="font-size: 0.7em; margin-top: 4px;"></div>
            </div>

            <!-- Mathematical Function & Processing -->
            <div class="control-group">
                <h3>🔬 Mathematical Function</h3>
                <label for="functionCategorySelect">Category:</label>
                <select id="functionCategorySelect" class="function-select">
                    <option value="basic">🔢 Basic Operations</option>
                    <option value="logarithmic">📈 Logarithmic & Exponential</option>
                    <option value="trigonometric">🌊 Trigonometric</option>
                    <option value="hyperbolic">📐 Hyperbolic</option>
                    <option value="complex">🔢 Complex Number Operations</option>
                    <option value="physics">⚛️ Physics Equations</option>
                    <option value="special">🔬 Special Functions</option>
                    <option value="geometric">� Geometric</option>
                    <option value="spirals">🌪️ Spirals</option>
                    <option value="fractals">🌀 Fractals & Chaos</option>
                    <option value="wave">🌊 Wave Functions</option>
                    <option value="patterns">🔸 Special Patterns</option>
                    <option value="stereo">🎧 Stereo Panning</option>
                    <option value="quantum">🚀 Quantum & Exotic</option>
                </select>

                <label for="functionSelect" style="margin-top: 8px;">Function:</label>
                <select id="functionSelect" class="function-select">
                    <!-- Functions will be populated based on category selection -->
                    <option value="power">Power (f^n) - Frequency stretching/compression</option>
                </select>

                <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="powerSlider">Amount: <span class="value-display"
                                id="powerValue">1.000</span></label>
                        <div class="dual-slider-container modulation-disabled">
                            <input type="range" id="powerSlider" class="main-slider" min="0.1" max="20.0" step="0.001"
                                value="1.0">
                            <div class="slider-track"></div>
                            <input type="range" id="modMinSlider" class="dual-handle green-handle" min="0.1" max="20.0"
                                step="0.001" value="0.1">
                            <input type="range" id="modMaxSlider" class="dual-handle red-handle" min="0.1" max="20.0"
                                step="0.001" value="1.0">
                            <div class="modulation-range-display">
                                Mod Range: <span id="modRangeValue">0.100 → 1.000</span>
                            </div>
                            <div class="pulse-indicator"></div>
                        </div>
                        <div class="slider-info">
                            <span>0.1</span>
                            <span>10.0</span>
                            <span>20.0</span>
                        </div>
                    </div>
                    <div class="compact-control">
                        <label for="modPeriodSlider">Modulate (<span id="modStatus">Off</span>): <span
                                class="value-display" id="modPeriodValue">5.0s</span></label>
                        <input type="range" id="modPeriodSlider" min="0" max="2" step="0.01" value="0">
                        <div class="slider-info">
                            <span>Off</span>
                            <span>1min</span>
                            <span>10min</span>
                        </div>
                    </div>
                </div>

                <div class="compact-layout" style="grid-template-columns: 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="gainSlider">Gain: <span class="value-display" id="gainValue">0.0dB</span></label>
                        <input type="range" id="gainSlider" min="-60" max="36" step="0.1" value="0">
                        <div class="slider-info">
                            <span>-∞dB</span>
                            <span>0dB</span>
                            <span>+36dB</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mix & Effects Section -->
            <div class="control-group">
                <h3>🎛️ Mix & Effects</h3>

                <!-- Output Filters -->
                <div class="compact-control">
                    <label for="outputFilterSlider">High/Low Pass: <span class="value-display"
                            id="outputFilterValue">1Hz → 20kHz</span></label>
                    <div class="dual-slider-container">
                        <div class="slider-track"></div>
                        <input type="range" id="outputFilterMinSlider" class="dual-handle green-handle" min="1"
                            max="20000" step="1" value="1">
                        <input type="range" id="outputFilterMaxSlider" class="dual-handle red-handle" min="1"
                            max="20000" step="1" value="20000">
                        <div class="handle-labels">
                            <span class="min-label">Min</span>
                            <span class="max-label">Max</span>
                        </div>
                    </div>
                </div>

                <!-- Transform Mix & Output Gain -->
                <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="mixSlider">Transform Mix: <span class="value-display"
                                id="mixValue">100%</span></label>
                        <input type="range" id="mixSlider" min="0" max="100" step="1" value="100">
                        <div class="slider-info">
                            <span>0%</span>
                            <span>50%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    <div class="compact-control">
                        <label for="outputGainSlider">Output Gain: <span class="value-display"
                                id="outputGainValue">0.0dB</span></label>
                        <input type="range" id="outputGainSlider" min="-60" max="18" step="0.1" value="0">
                        <div class="slider-info">
                            <span>-∞dB</span>
                            <span>0dB</span>
                            <span>+18dB</span>
                        </div>
                    </div>
                </div>

                <!-- Delay Effects -->
                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.85em; color: #4ecdc4;">🔄 Delay</h4>
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                        <div class="compact-control">
                            <label for="delayTimeSlider">Time: <span class="value-display"
                                    id="delayTimeValue">0.0s</span></label>
                            <input type="range" id="delayTimeSlider" min="0" max="1000" step="1" value="0">
                            <div class="slider-info">
                                <span>0ms</span>
                                <span>500ms</span>
                                <span>1s</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="delayFeedbackSlider">Feedback: <span class="value-display"
                                    id="delayFeedbackValue">0%</span></label>
                            <input type="range" id="delayFeedbackSlider" min="0" max="95" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>95%</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="delayMixSlider">Mix: <span class="value-display"
                                    id="delayMixValue">0%</span></label>
                            <input type="range" id="delayMixSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 6px;">
                        <label for="delayFilterSlider">Filter: <span class="value-display" id="delayFilterValue">20Hz →
                                20kHz</span></label>
                        <div class="dual-slider-container">
                            <div class="slider-track"></div>
                            <input type="range" id="delayFilterMinSlider" class="dual-handle green-handle" min="20"
                                max="20000" step="10" value="20">
                            <input type="range" id="delayFilterMaxSlider" class="dual-handle red-handle" min="20"
                                max="20000" step="10" value="20000">
                            <div class="handle-labels">
                                <span class="min-label">Min</span>
                                <span class="max-label">Max</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Reverb Effects -->
                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.85em; color: #4ecdc4;">🌊 Reverb</h4>
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                        <div class="compact-control">
                            <label for="reverbRoomSizeSlider">Room: <span class="value-display"
                                    id="reverbRoomSizeValue">0%</span></label>
                            <input type="range" id="reverbRoomSizeSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>Small</span>
                                <span>Medium</span>
                                <span>Large</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="reverbDecaySlider">Decay: <span class="value-display"
                                    id="reverbDecayValue">1.0s</span></label>
                            <input type="range" id="reverbDecaySlider" min="0.1" max="10.0" step="0.1" value="1.0">
                            <div class="slider-info">
                                <span>0.1s</span>
                                <span>5s</span>
                                <span>10s</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="reverbMixSlider">Mix: <span class="value-display"
                                    id="reverbMixValue">0%</span></label>
                            <input type="range" id="reverbMixSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 6px;">
                        <label for="reverbFilterSlider">Filter: <span class="value-display" id="reverbFilterValue">20Hz
                                → 20kHz</span></label>
                        <div class="dual-slider-container">
                            <div class="slider-track"></div>
                            <input type="range" id="reverbFilterMinSlider" class="dual-handle green-handle" min="20"
                                max="20000" step="10" value="20">
                            <input type="range" id="reverbFilterMaxSlider" class="dual-handle red-handle" min="20"
                                max="20000" step="10" value="20000">
                            <div class="handle-labels">
                                <span class="min-label">Min</span>
                                <span class="max-label">Max</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Audio Visualization -->
        <div class="control-group full-width">
            <h3>📊 Audio Visualization</h3>
            <div class="visualizer">
                <canvas id="visualizerCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>// Ultimate Complex Audio Transformer - Always Real-time with Dual Track System
        let ctx;

        // Dual Track System Variables
        let audioBufferA, audioBufferB;
        let processedBuffer;
        let audioSourceA, audioSourceB;
        let realtimeProcessor;
        let currentSourceA, currentSourceB;
        let isPlayingA = false, isPlayingB = false;
        let isPlaying = false; // For mixed playback state
        let isRealTimeMode = false;
        let selectedFunction = 'power';
        let analyser;
        let canvas;
        let canvasCtx;
        let animationId;
        let scriptProcessor;

        // Track timing and position variables
        let trackPositionA = 0, trackPositionB = 0;
        let trackDurationA = 0, trackDurationB = 0;
        let trackStartTimeA = 0, trackStartTimeB = 0;

        // Time slider drag state tracking
        let timeSliderADragging = false;
        let timeSliderBDragging = false;

        // Crossfader variables
        let crossfaderValue = 50; // 0 = A only, 50 = equal mix, 100 = B only
        let fadeSyncEnabled = false;
        let mixerGainNodeA, mixerGainNodeB, mixerOutputNode;

        // Effects chain nodes
        let delayNode;
        let delayFeedbackNode;
        let delayMixNode;
        let delayWetGainNode;
        let delayDryGainNode;
        let delayLowCutFilter;
        let delayHighCutFilter;
        let reverbNode;
        let reverbMixNode;
        let reverbWetGainNode;
        let reverbDryGainNode;
        let reverbLowCutFilter;
        let reverbHighCutFilter;

        // Output filter nodes
        let lowPassFilter;
        let highPassFilter;

        // Auto gain and output gain nodes
        let finalOutputGainNode;
        let compressorNode; // Auto-limiter

        // LUFS measurement
        let inputLufsAnalyser;
        let outputLufsAnalyser;
        let lufsUpdateInterval;

        // Real-time processing parameters
        let realtimeParams = {
            fftSize: 13860,
            amount: 1.0,
            smoothing: 0.1,
            mix: 1.0,
            gain: 1.0,
            modEnabled: false,   // Whether amount modulation is enabled
            modPeriod: 5.0,      // Modulation period in seconds
            modStartTime: 0,     // Time when modulation started
            modMinAmount: 0.0,   // Minimum modulation amount
            modMaxAmount: 1.0,   // Maximum modulation amount

            // Crossfader parameters
            crossfaderValue: 0,     // 0 = A only, 50 = equal mix, 100 = B only
            fadeSyncEnabled: false,  // Whether effects fade with crossfader mix
            crossfaderGainA: 0.5,    // Calculated gain for track A
            crossfaderGainB: 0.5,    // Calculated gain for track B

            // FadeSync maximum values (captured when FadeSync is enabled)
            fadeSyncMaxTransformMix: 1.0,  // Maximum transform mix for FadeSync
            fadeSyncMaxDelayMix: 1.0,      // Maximum delay mix for FadeSync  
            fadeSyncMaxReverbMix: 1.0,     // Maximum reverb mix for FadeSync

            // Output filter parameters
            lowPassFreq: 20000,  // Low pass filter frequency in Hz
            highPassFreq: 1,     // High pass filter frequency in Hz (start at 1Hz)

            // Delay parameters
            delayTime: 0.0,      // Delay time in seconds
            delayFeedback: 0.0,  // Feedback amount (0-0.95)
            delayMix: 0.0,       // Delay mix (0-1)
            delayLowCut: 20.0,   // Delay low cut frequency in Hz
            delayHighCut: 20000.0, // Delay high cut frequency in Hz

            // Reverb parameters
            reverbRoomSize: 0.0, // Room size (0-1)
            reverbDecay: 1.0,    // Decay time in seconds
            reverbMix: 0.0,      // Reverb mix (0-1)
            reverbLowCut: 20.0,  // Reverb low cut frequency in Hz
            reverbHighCut: 20000.0, // Reverb high cut frequency in Hz

            // Auto gain compensation and output
            outputGainDb: 0.0,     // Output gain in dB (-∞ to +18)
            finalOutputGain: 1.0   // Final output gain
        };

        // Memory management pool
        let memoryPool = {
            realBuffers: [],
            imagBuffers: [],
            windowBuffers: new Map(),
            fftBuffers: []
        };

        // Complex function definitions with complete implementations
        // 'inverse': Flips the frequency spectrum around a central point, creating unique spectral inversions and mirror effects.
        const complexFunctions = {
            // === BASIC MATHEMATICAL OPERATIONS ===
            'power': { name: 'Power (f^n)', desc: 'Frequency stretching/compression' },
            'sqrt': { name: '√z', desc: 'Square root expansion' },
            'cbrt': { name: '∛z', desc: 'Cube root expansion' },
            'nroot': { name: 'ⁿ√z', desc: 'N-th root (power-controlled)' },
            'square': { name: 'z²', desc: 'Square compression' },
            'inverse': { name: '1/z', desc: 'Reciprocal inversion. Flips the spectrum around a central point, creating mirror-like spectral effects.' },

            // === LOGARITHMIC & EXPONENTIAL ===
            'log': { name: 'ln(z)', desc: 'Natural logarithm' },
            'log10': { name: 'log₁₀(z)', desc: 'Base-10 logarithm' },
            'log2': { name: 'log₂(z)', desc: 'Base-2 logarithm' },
            'exp': { name: 'e^z', desc: 'Natural exponential' },
            'exp2': { name: '2^z', desc: 'Base-2 exponential' },
            'exp10': { name: '10^z', desc: 'Base-10 exponential' },

            // === TRIGONOMETRIC FUNCTIONS ===
            'sin': { name: 'sin(z)', desc: 'Sine wave warping' },
            'cos': { name: 'cos(z)', desc: 'Cosine wave warping' },
            'tan': { name: 'tan(z)', desc: 'Tangent sharp bending' },
            'cot': { name: 'cot(z)', desc: 'Cotangent (1/tan)' },


            // === INVERSE HYPERBOLIC ===
            'asinh': { name: 'asinh(z)', desc: 'Inverse hyperbolic sine' },
            'acosh': { name: 'acosh(z)', desc: 'Inverse hyperbolic cosine' },
            'atanh': { name: 'atanh(z)', desc: 'Inverse hyperbolic tangent' },


            // === FAMOUS PHYSICS EQUATIONS ===
            'schrodinger': { name: 'Schrödinger Ψ', desc: 'Quantum wave function' },
            'heisenberg': { name: 'Heisenberg Δx·Δp', desc: 'Uncertainty principle' },
            'einstein_mass_energy': { name: 'E=mc²', desc: 'Mass-energy equivalence' },
            'planck_radiation': { name: 'Planck B(ν,T)', desc: 'Blackbody radiation' },
            'maxwell_boltzmann': { name: 'Maxwell-Boltzmann', desc: 'Velocity distribution' },
            'wave_equation': { name: 'Wave ∂²u/∂t²', desc: 'String vibrations' },
            'heat_equation': { name: 'Heat ∂u/∂t', desc: 'Thermal diffusion' },
            'schwarzschild': { name: 'Schwarzschild r_s', desc: 'Black hole radius' },
            'compton_scattering': { name: 'Compton Δλ', desc: 'Photon scattering' },

            // === SPECIAL FUNCTIONS ===

            'airy_ai': { name: 'Ai(z)', desc: 'Airy function Ai' },
            'airy_bi': { name: 'Bi(z)', desc: 'Airy function Bi' },
            'erf': { name: 'erf(z)', desc: 'Error function' },
            'erfc': { name: 'erfc(z)', desc: 'Complementary error function' },
            'mobius': { name: 'Möbius (az+b)/(cz+d)', desc: 'Conformal mapping' },


            // === SPIRAL TRANSFORMATIONS ===
            'fibonacci_spiral': { name: 'Fibonacci Spiral', desc: 'Golden ratio spiral' },
            'archimedean_spiral': { name: 'Archimedean rθ', desc: 'Linear spiral' },
            'fermat_spiral': { name: 'Fermat r²=aθ', desc: 'Parabolic spiral' },
            'hyperbolic_spiral': { name: 'Hyperbolic r=a/θ', desc: 'Reciprocal spiral' },
            'ulam_spiral': { name: 'Ulam Spiral', desc: 'Prime number spiral' },

            // === FRACTAL FUNCTIONS ===
            'mandelbrot': { name: 'Mandelbrot z²+c', desc: 'Classic fractal' },
            'julia': { name: 'Julia Set', desc: 'Julia set fractal' },
            'burning_ship': { name: 'Burning Ship |z|²+c', desc: 'Absolute value fractal' },
            'tricorn': { name: 'Tricorn z̄²+c', desc: 'Conjugate fractal' },
            'multibrot': { name: 'Multibrot z^n+c', desc: 'Generalized Mandelbrot' },
            'newton_raphson': { name: 'Newton z³-1', desc: 'Newton fractal' },
            'nova': { name: 'Nova Fractal', desc: 'Newton-style fractal' },
            'phoenix': { name: 'Phoenix z²+c+b', desc: 'Phoenix fractal' },
            'magnet': { name: 'Magnet (z²+c-1)²', desc: 'Magnet fractal' },
            'lambda': { name: 'Lambda λz(1-z)', desc: 'Lambda fractal' },
            'henon_map': { name: 'Hénon Map', desc: '2D chaotic attractor' },
            'lorenz_attractor': { name: 'Lorenz Attractor', desc: 'Butterfly effect chaos' },
            'logistic_map': { name: 'Logistic rx(1-x)', desc: 'Period-doubling chaos' },

            // === WAVE FUNCTIONS ===
            'wave': { name: 'Wave Interference', desc: 'Constructive/destructive' },
            'ripple': { name: 'Ripple Effect', desc: 'Concentric waves' },
            'standing_wave': { name: 'Standing Wave', desc: 'Node/antinode pattern' },
            'beat_frequency': { name: 'Beat Frequency', desc: 'Amplitude modulation' },
            'chirp': { name: 'Chirp f(t)', desc: 'Frequency sweep' },

            // === STEREO PANNING EFFECTS ===
            'stereo_real_imag': { name: '🎧 Real/Imaginary Split', desc: 'Real→Left, Imag→Right' },
            'stereo_mag_phase': { name: '🎧 Magnitude/Phase Split', desc: 'Mag→Left, Phase→Right' },
            'stereo_rotation': { name: '🎧 Complex Rotation', desc: 'Rotating panning field' },
            'stereo_spiral_pan': { name: '🎧 Spiral Panning', desc: 'Frequency-dependent pan' },
            'stereo_doppler_pan': { name: '🎧 Doppler Panning', desc: 'Moving source simulation' },
            'stereo_binaural': { name: '🎧 Binaural Beats', desc: 'Frequency difference beats' },

            // === QUANTUM & EXOTIC ===
            'quantum_harmonic': { name: 'Quantum Harmonic', desc: 'QHO wave functions' },
            'hydrogen_orbital': { name: 'Hydrogen Orbital', desc: 'Atomic wave functions' },
            'tunneling_effect': { name: 'Quantum Tunneling', desc: 'Barrier penetration' },
            'klein_gordon': { name: 'Klein-Gordon', desc: 'Relativistic wave equation' },
            'dirac_equation': { name: 'Dirac Equation', desc: 'Relativistic electron' },
            'feynman_diagram': { name: 'Feynman Propagator', desc: 'Particle interactions' }
        };

        // Memory management functions
        function getBuffer(size, type = 'real') {
            // Ensure memoryPool exists
            if (!memoryPool) {
                memoryPool = {
                    realBuffers: [],
                    imagBuffers: [],
                    windowBuffers: new Map(),
                    fftBuffers: []
                };
            }

            const pool = type === 'real' ? memoryPool.realBuffers : memoryPool.imagBuffers;
            if (!pool) {
                console.warn(`Memory pool for type '${type}' is undefined, creating new array`);
                if (type === 'real') {
                    memoryPool.realBuffers = [];
                    return new Float32Array(size);
                } else {
                    memoryPool.imagBuffers = [];
                    return new Float32Array(size);
                }
            }

            let buffer = pool.find(b => b && b.length >= size);
            if (!buffer) {
                buffer = new Float32Array(size);
                pool.push(buffer);
            }
            return buffer.subarray(0, size);
        }

        function getWindow(size) {
            // Ensure memoryPool exists
            if (!memoryPool || !memoryPool.windowBuffers) {
                if (!memoryPool) {
                    memoryPool = {
                        realBuffers: [],
                        imagBuffers: [],
                        windowBuffers: new Map(),
                        fftBuffers: []
                    };
                } else if (!memoryPool.windowBuffers) {
                    memoryPool.windowBuffers = new Map();
                }
            }

            if (!memoryPool.windowBuffers.has(size)) {
                const window = new Float32Array(size);
                // Hann window
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                memoryPool.windowBuffers.set(size, window);
            }
            return memoryPool.windowBuffers.get(size);
        }

        function updateMemoryInfo() {
            try {
                // Ensure memoryPool exists and has required properties
                if (!memoryPool) {
                    console.warn('memoryPool is undefined, reinitializing...');
                    memoryPool = {
                        realBuffers: [],
                        imagBuffers: [],
                        windowBuffers: new Map(),
                        fftBuffers: []
                    };
                }

                // Ensure each property exists
                if (!memoryPool.realBuffers) memoryPool.realBuffers = [];
                if (!memoryPool.imagBuffers) memoryPool.imagBuffers = [];
                if (!memoryPool.windowBuffers) memoryPool.windowBuffers = new Map();
                if (!memoryPool.fftBuffers) memoryPool.fftBuffers = [];

                const realCount = memoryPool.realBuffers.length;
                const imagCount = memoryPool.imagBuffers.length;
                const windowCount = memoryPool.windowBuffers.size;
                const fftCount = memoryPool.fftBuffers.length;

                const memoryInfoElement = document.getElementById('memoryInfo');
                if (memoryInfoElement) {
                    const outputGainStatus = realtimeParams.outputGainDb === -Infinity ?
                        'Output: -∞dB' : `Output: ${realtimeParams.outputGainDb >= 0 ? '+' : ''}${realtimeParams.outputGainDb.toFixed(1)}dB`;
                    memoryInfoElement.textContent =
                        `Memory Pool: ${realCount} real, ${imagCount} imag, ${windowCount} window, ${fftCount} FFT buffers | ${outputGainStatus}`;
                }
            } catch (error) {
                console.error('Error in updateMemoryInfo:', error);
                // Don't throw the error, just log it to prevent breaking the audio processing
            }
        }

        // Audio context initialization
        async function initAudioContext() {
            try {
                if (!ctx) {
                    ctx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio context created');
                }

                if (ctx.state === 'suspended') {
                    console.log('Audio context suspended, attempting to resume...');
                    await ctx.resume();
                    console.log('Audio context resumed successfully');
                }

                console.log(`Audio context state: ${ctx.state}, sample rate: ${ctx.sampleRate}`);
                return ctx;

            } catch (error) {
                console.error('Failed to initialize audio context:', error);
                showStatus(`Audio context error: ${error.message}. Try clicking a button first.`, 'error');
                throw error;
            }
        }

        // Status display
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = type;
            console.log(`[${type}] ${message}`);
        }

        // Real-time Audio Processor with large buffer for smooth processing
        class RealtimeAudioProcessor {
            constructor(audioContext, bufferDuration = 3.0) {
                this.audioContext = audioContext;
                this.sampleRate = audioContext.sampleRate;
                this.bufferDuration = bufferDuration;

                // Use larger buffer size for smoother processing
                this.bufferSize = 8192; // Larger ScriptProcessorNode buffer

                // Large circular buffer for smooth processing (3+ seconds)
                this.circularBufferSize = Math.ceil(this.sampleRate * bufferDuration);
                this.inputCircularBuffer = new Float32Array(this.circularBufferSize);
                this.outputCircularBuffer = new Float32Array(this.circularBufferSize);

                // Buffer pointers
                this.writePtr = 0;
                this.readPtr = 0;
                this.bufferFilled = false;

                // Initialize with 3 second latency for smooth processing
                this.latencyBufferSize = Math.floor(this.sampleRate * 1.5); // 1.5 second initial latency
                this.readPtr = this.circularBufferSize - this.latencyBufferSize;

                console.log(`Initialized large buffer: ${this.circularBufferSize} samples (${(this.circularBufferSize / this.sampleRate).toFixed(2)}s) at ${this.sampleRate}Hz`);

                // Processing parameters
                this.params = {
                    function: 'power',
                    amount: 1.0,
                    smoothing: 0.1,
                    mix: 1.0,
                    gain: 1.0
                };

                // FFT setup for real-time processing
                this.fftSize = 2048;
                this.windowFunc = this.createWindow(this.fftSize);

                // Processing state
                this.lastSample = 0;
                this.processCounter = 0;

                // Create ScriptProcessorNode with larger buffer - STEREO
                this.processor = audioContext.createScriptProcessor(this.bufferSize, 2, 2);
                this.processor.onaudioprocess = this.processAudio.bind(this);

                // Gain node for output control
                this.gainNode = audioContext.createGain();
                this.processor.connect(this.gainNode);

                console.log(`RealtimeAudioProcessor initialized with ${this.bufferSize} sample buffer and ${(this.circularBufferSize / this.sampleRate).toFixed(2)}s circular buffer`);
            }

            createWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                return window;
            }

            updateParams(newParams) {
                // Update parameters safely
                Object.assign(this.params, newParams);
                this.gainNode.gain.value = this.params.gain;

                // Update FFT size if changed
                if (newParams.fftSize && newParams.fftSize !== this.fftSize) {
                    this.fftSize = newParams.fftSize;
                    this.windowFunc = this.createWindow(this.fftSize);
                    this.lastSample = 0;
                    console.log(`FFT size updated to ${this.fftSize}`);
                }

                // Log parameter updates for debugging
                if (this.processCounter % 50 === 0) {
                    console.log('Updated params:', {
                        function: this.params.function,
                        amount: this.params.amount,
                        mix: this.params.mix,
                        fftSize: this.fftSize
                    });
                }
            }
            // No additional code needed here for parameter updates.
            // Parameters are updated via updateParams() externally.
            processAudio(event) {
                const numChannels = Math.min(2, event.inputBuffer.numberOfChannels);
                const bufferLength = event.inputBuffer.length;

                // Process both channels
                for (let channel = 0; channel < 2; channel++) {
                    const inputData = event.inputBuffer.getChannelData(Math.min(channel, numChannels - 1));
                    const outputData = event.outputBuffer.getChannelData(channel);

                    // Write input data to circular buffer
                    for (let i = 0; i < bufferLength; i++) {
                        this.inputCircularBuffer[this.writePtr] = inputData[i];
                        this.writePtr = (this.writePtr + 1) % this.circularBufferSize;
                    }

                    // Simple direct processing to avoid circular buffer complexity
                    // Process the current input buffer directly with proper windowing

                    if (bufferLength >= this.fftSize) {
                        // Process in overlapping windows
                        const hopSize = this.fftSize / 4; // 75% overlap for very smooth processing
                        const tempOutput = new Float32Array(bufferLength);
                        tempOutput.fill(0); // Initialize to zero for overlap-add

                        for (let windowStart = 0; windowStart < bufferLength - this.fftSize + hopSize; windowStart += hopSize) {
                            const windowEnd = Math.min(windowStart + this.fftSize, bufferLength);
                            const actualWindowSize = windowEnd - windowStart;

                            if (actualWindowSize < this.fftSize / 2) continue; // Skip tiny windows

                            // Extract window
                            const windowBuffer = new Float32Array(this.fftSize);
                            windowBuffer.fill(0);

                            for (let i = 0; i < actualWindowSize; i++) {
                                windowBuffer[i] = inputData[windowStart + i];
                            }

                            // Process window
                            const processedWindow = this.processChunk(windowBuffer);

                            // Overlap-add to output with proper scaling
                            const overlapScale = 1.0 / 3.0; // Scale for 75% overlap
                            for (let i = 0; i < actualWindowSize; i++) {
                                if (windowStart + i < bufferLength) {
                                    tempOutput[windowStart + i] += processedWindow[i] * overlapScale;
                                }
                            }
                        }

                        // Copy to final output with mixing and gain
                        for (let i = 0; i < bufferLength; i++) {
                            let processedSample = tempOutput[i];

                            // Apply smoothing to reduce artifacts
                            if (this.lastSample !== undefined) {
                                const smoothingAmount = Math.min(0.1, this.params.smoothing);
                                processedSample = smoothingAmount * this.lastSample + (1 - smoothingAmount) * processedSample;
                            }
                            this.lastSample = processedSample;

                            // Apply dry/wet mix
                            const originalSample = inputData[i];
                            let mixedSample = this.params.mix * processedSample + (1 - this.params.mix) * originalSample;

                            // Apply gain with soft limiting
                            mixedSample *= this.params.gain;
                            if (Math.abs(mixedSample) > 0.95) {
                                mixedSample = Math.sign(mixedSample) * (0.95 + 0.05 * Math.tanh((Math.abs(mixedSample) - 0.95) * 10));
                            }

                            outputData[i] = mixedSample;
                        }

                    } else {
                        // Buffer smaller than FFT size - simple processing
                        const paddedBuffer = new Float32Array(this.fftSize);
                        paddedBuffer.fill(0);

                        for (let i = 0; i < bufferLength; i++) {
                            paddedBuffer[i] = inputData[i];
                        }

                        const processedBuffer = this.processChunk(paddedBuffer);

                        for (let i = 0; i < bufferLength; i++) {
                            let processedSample = processedBuffer[i];

                            // Apply smoothing
                            if (this.lastSample !== undefined) {
                                const smoothingAmount = Math.min(0.1, this.params.smoothing);
                                processedSample = smoothingAmount * this.lastSample + (1 - smoothingAmount) * processedSample;
                            }
                            this.lastSample = processedSample;

                            // Apply mix and gain
                            const originalSample = inputData[i];
                            let mixedSample = this.params.mix * processedSample + (1 - this.params.mix) * originalSample;

                            mixedSample *= this.params.gain;
                            if (Math.abs(mixedSample) > 0.95) {
                                mixedSample = Math.sign(mixedSample) * (0.95 + 0.05 * Math.tanh((Math.abs(mixedSample) - 0.95) * 10));
                            }

                            outputData[i] = mixedSample;
                        }
                    }

                    // Update processing counter for diagnostics
                    this.processCounter++;
                    if (this.processCounter % 200 === 0) {
                        const bufferFillPercent = (this.getAvailableData() / this.circularBufferSize * 100).toFixed(1);
                        console.log(`Processing stable - Buffer: ${bufferFillPercent}%`);
                    }
                } // Close channel loop
            }

            // Helper method to get available data in circular buffer
            getAvailableData() {
                if (this.writePtr >= this.readPtr) {
                    return this.writePtr - this.readPtr;
                } else {
                    return this.circularBufferSize - this.readPtr + this.writePtr;
                }
            }

            // Process a single chunk through FFT
            processChunk(inputChunk) {
                const real = new Float32Array(this.fftSize);
                const imag = new Float32Array(this.fftSize);

                // Copy input with windowing
                for (let i = 0; i < Math.min(inputChunk.length, this.fftSize); i++) {
                    real[i] = inputChunk[i] * this.windowFunc[i];
                    imag[i] = 0;
                }

                // Forward FFT
                fft(real, imag);

                // Apply frequency domain transformation
                try {
                    applyComplexFunction(real, imag, this.fftSize, this.sampleRate, this.params.function, this.params.amount, this.params);
                } catch (error) {
                    console.warn('Frequency transformation error:', error);
                }

                // Inverse FFT
                ifft(real, imag);

                // Apply windowing again and return
                const output = new Float32Array(this.fftSize);
                for (let i = 0; i < this.fftSize; i++) {
                    output[i] = real[i] * this.windowFunc[i];
                }

                return output;
            }

            connect(destination) {
                this.gainNode.connect(destination);
                return this.processor;
            }

            disconnect() {
                if (this.processor) {
                    this.processor.disconnect();
                }
                if (this.gainNode) {
                    this.gainNode.disconnect();
                }
            }
        }

        // Create delay effect
        function createDelayEffect() {
            if (!ctx) return null;

            try {
                // Create delay line
                const maxDelayTime = 1.0; // 1 second maximum
                const delay = ctx.createDelay(maxDelayTime);
                delay.delayTime.setValueAtTime(realtimeParams.delayTime, ctx.currentTime);

                // Create feedback gain
                const feedback = ctx.createGain();
                feedback.gain.setValueAtTime(realtimeParams.delayFeedback, ctx.currentTime);

                // Create wet/dry mix
                const wetGain = ctx.createGain();
                const dryGain = ctx.createGain();
                const outputGain = ctx.createGain();

                wetGain.gain.setValueAtTime(realtimeParams.delayMix, ctx.currentTime);
                dryGain.gain.setValueAtTime(1.0 - realtimeParams.delayMix, ctx.currentTime);

                // Create filter nodes
                delayLowCutFilter = ctx.createBiquadFilter();
                delayLowCutFilter.type = 'highpass';
                delayLowCutFilter.frequency.setValueAtTime(realtimeParams.delayLowCut, ctx.currentTime);
                delayLowCutFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                delayHighCutFilter = ctx.createBiquadFilter();
                delayHighCutFilter.type = 'lowpass';
                delayHighCutFilter.frequency.setValueAtTime(realtimeParams.delayHighCut, ctx.currentTime);
                delayHighCutFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Connect delay feedback loop
                delay.connect(feedback);
                feedback.connect(delay);

                // Connect delay chain with filters: delay -> lowcut -> highcut -> wetGain
                delay.connect(delayLowCutFilter);
                delayLowCutFilter.connect(delayHighCutFilter);
                delayHighCutFilter.connect(wetGain);

                // Connect wet/dry mix
                wetGain.connect(outputGain);
                dryGain.connect(outputGain);

                // Store global references
                delayNode = delay;
                delayFeedbackNode = feedback;
                delayWetGainNode = wetGain;
                delayDryGainNode = dryGain;

                return {
                    input: delay,
                    inputDry: dryGain,
                    output: outputGain,
                    delayNode: delay,
                    feedbackNode: feedback,
                    wetGainNode: wetGain,
                    dryGainNode: dryGain
                };
            } catch (error) {
                console.error('Error creating delay effect:', error);
                return null;
            }
        }

        // Create reverb effect using convolution
        function createReverbEffect() {
            if (!ctx) return null;

            try {
                // Create convolver for reverb
                const convolver = ctx.createConvolver();

                // Generate impulse response for reverb
                const sampleRate = ctx.sampleRate;
                const decayTime = realtimeParams.reverbDecay;
                const roomSize = realtimeParams.reverbRoomSize;
                const length = Math.min(sampleRate * decayTime, sampleRate * 4); // Max 4 seconds

                const impulse = ctx.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;

                        // Exponential decay
                        const decay = Math.exp(-4 * t / decayTime);

                        // Room characteristics
                        const roomFactor = 0.05 + roomSize * 0.95;

                        // Early reflections (first 80ms)
                        let sample = 0;
                        if (t < 0.08) {
                            const reflectionDensity = roomFactor * 20;
                            const numReflections = Math.floor(reflectionDensity * t);
                            for (let r = 0; r < numReflections; r++) {
                                const reflectionTime = Math.random() * t;
                                const reflectionDecay = Math.exp(-reflectionTime / 0.02);
                                const reflectionAmp = (Math.random() - 0.5) * 0.1 * reflectionDecay;
                                sample += reflectionAmp;
                            }
                        }

                        // Late reverb (dense, decorrelated)
                        const lateReverb = (Math.random() - 0.5) * 2 * decay * roomFactor;

                        // High frequency rolloff
                        const hfRolloff = Math.exp(-t * 2);

                        // Combine components
                        const totalSample = (sample + lateReverb) * hfRolloff;

                        // Stereo decorrelation
                        channelData[i] = totalSample * (channel === 0 ? 1 : 0.7 + Math.random() * 0.3);
                    }
                }

                convolver.buffer = impulse;

                // Create filter nodes
                reverbLowCutFilter = ctx.createBiquadFilter();
                reverbLowCutFilter.type = 'highpass';
                reverbLowCutFilter.frequency.setValueAtTime(realtimeParams.reverbLowCut, ctx.currentTime);
                reverbLowCutFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                reverbHighCutFilter = ctx.createBiquadFilter();
                reverbHighCutFilter.type = 'lowpass';
                reverbHighCutFilter.frequency.setValueAtTime(realtimeParams.reverbHighCut, ctx.currentTime);
                reverbHighCutFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Create wet/dry mix
                const wetGain = ctx.createGain();
                const dryGain = ctx.createGain();
                const outputGain = ctx.createGain();

                wetGain.gain.setValueAtTime(realtimeParams.reverbMix, ctx.currentTime);
                dryGain.gain.setValueAtTime(1.0 - realtimeParams.reverbMix, ctx.currentTime);

                // Connect reverb chain with filters: input -> lowcut -> highcut -> convolver -> wetGain
                reverbLowCutFilter.connect(reverbHighCutFilter);
                reverbHighCutFilter.connect(convolver);
                convolver.connect(wetGain);
                wetGain.connect(outputGain);
                dryGain.connect(outputGain);

                // Store global references
                reverbNode = convolver;
                reverbWetGainNode = wetGain;
                reverbDryGainNode = dryGain;

                return {
                    input: reverbLowCutFilter,
                    inputDry: dryGain,
                    output: outputGain,
                    reverbNode: convolver,
                    wetGainNode: wetGain,
                    dryGainNode: dryGain
                };
            } catch (error) {
                console.error('Error creating reverb effect:', error);
                return null;
            }
        }

        // Function to recreate reverb impulse response when parameters change
        function recreateReverbImpulse() {
            if (!ctx || !reverbNode) return;

            try {
                // Generate new impulse response with current parameters
                const sampleRate = ctx.sampleRate;
                const decayTime = realtimeParams.reverbDecay;
                const roomSize = realtimeParams.reverbRoomSize;
                const length = Math.min(sampleRate * decayTime, sampleRate * 4); // Max 4 seconds

                const impulse = ctx.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;

                        // Exponential decay
                        const decay = Math.exp(-4 * t / decayTime);

                        // Room characteristics
                        const roomFactor = 0.05 + roomSize * 0.95;

                        // Early reflections (first 80ms)
                        let sample = 0;
                        if (t < 0.08) {
                            const reflectionDensity = roomFactor * 20;
                            const numReflections = Math.floor(reflectionDensity * t);
                            for (let r = 0; r < numReflections; r++) {
                                const reflectionTime = Math.random() * t;
                                const reflectionDecay = Math.exp(-reflectionTime / 0.02);
                                const reflectionAmp = (Math.random() - 0.5) * 0.1 * reflectionDecay;
                                sample += reflectionAmp;
                            }
                        }

                        // Late reverb (dense, decorrelated)
                        const lateReverb = (Math.random() - 0.5) * 2 * decay * roomFactor;

                        // High frequency rolloff
                        const hfRolloff = Math.exp(-t * 2);

                        // Combine components
                        const totalSample = (sample + lateReverb) * hfRolloff;

                        // Stereo decorrelation
                        channelData[i] = totalSample * (channel === 0 ? 1 : 0.7 + Math.random() * 0.3);
                    }
                }

                // Update the reverb node's buffer
                reverbNode.buffer = impulse;

                showStatus(`Reverb updated: ${realtimeParams.reverbDecay.toFixed(1)}s decay, ${Math.round(realtimeParams.reverbRoomSize * 100)}% room size`, 'info');

            } catch (error) {
                console.error('Error recreating reverb impulse:', error);
                showStatus('Error updating reverb parameters', 'error');
            }
        }

        // RMS calculation for auto gain compensation (simpler than LUFS)
        function calculateRMS(analyser) {
            if (!analyser) return 0.0;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatFrequencyData(dataArray);

            // Calculate RMS from frequency domain data
            let sum = 0;
            let count = 0;

            for (let i = 1; i < bufferLength; i++) { // Skip DC
                if (dataArray[i] > -120) { // Only count significant energy
                    const linearPower = Math.pow(10, dataArray[i] / 10);
                    sum += linearPower;
                    count++;
                }
            }

            if (count === 0) return 0.0;

            const rms = Math.sqrt(sum / count);
            return rms;
        }

        // Update LUFS measurements and auto gain
        function updateLUFSMeasurements() {
            if (!inputLufsAnalyser || !outputLufsAnalyser) return;

            const inputRMS = calculateRMS(inputLufsAnalyser);
            const outputRMS = calculateRMS(outputLufsAnalyser);

            // Update display if elements exist (optional UI elements)
            const inputLufsElement = document.getElementById('inputLufs');
            const outputLufsElement = document.getElementById('outputLufs');
            if (inputLufsElement) inputLufsElement.textContent = (20 * Math.log10(inputRMS + 1e-12)).toFixed(1) + ' dB';
            if (outputLufsElement) outputLufsElement.textContent = (20 * Math.log10(outputRMS + 1e-12)).toFixed(1) + ' dB';

            // Auto gain compensation removed - no autoGainNode needed
            updateMemoryInfo(); // Update UI
        }
        // Complex function applications with proper frequency transformations
        function applyComplexFunction(real, imag, fftSize, sampleRate, funcName, amount = 1.0, params = null) {
            // Helper for inverse mapping
            function inverseFrequencyMapping(normalizedFreq, amount) {
                const inversionPoint = 0.5;
                let mapped = inversionPoint - (normalizedFreq - inversionPoint) * amount;
                if (amount > 1) {
                    mapped = ((mapped % 1) + 1) % 1; // Wrap into [0,1]
                } else {
                    mapped = Math.max(0, Math.min(1, mapped)); // Clamp to [0,1]
                }
                return mapped;
            }
            try {
                // Use passed params or fall back to global realtimeParams
                const currentParams = params || realtimeParams;

                const nyquist = sampleRate / 2;
                const binSize = sampleRate / fftSize;

                // Frequency range limits - permanently set to unlimited
                const minFreq = 0;
                const maxFreq = nyquist * 2; // Allow frequencies up to 2x Nyquist to trigger wrapping

                // Create temporary arrays for frequency remapping
                const tempReal = new Float32Array(fftSize);
                const tempImag = new Float32Array(fftSize);

                // Copy original spectrum
                for (let i = 0; i < fftSize; i++) {
                    tempReal[i] = real[i];
                    tempImag[i] = imag[i];
                }

                // Clear output arrays
                real.fill(0);
                imag.fill(0);

                // Process only positive frequencies (first half of spectrum)
                for (let i = 1; i < fftSize / 2; i++) {
                    const frequency = i * binSize;

                    // Skip frequencies outside range based on current settings
                    if (frequency < minFreq || frequency > maxFreq) continue;

                    // Normalize frequency to 0-1 within selected range
                    let normalizedFreq = (frequency - minFreq) / (maxFreq - minFreq);

                    // Get magnitude and phase from original spectrum
                    const magnitude = Math.sqrt(tempReal[i] * tempReal[i] + tempImag[i] * tempImag[i]);
                    const phase = Math.atan2(tempImag[i], tempReal[i]);

                    if (magnitude < 1e-12) continue; // Skip silent bins

                    let mappedFreq = normalizedFreq; // Default: no change
                    let magnitudeMultiplier = 1.0;
                    let phaseShift = 0;

                    // Apply dramatic frequency transformations based on function type
                    // All functions use 'amount' parameter to control intensity (0-10 typical range)
                    switch (funcName) {
                        // === BASIC OPERATIONS ===
                        case 'power':
                            // amount: [0.1, 4.0], controls exponent for stretching/compression.
                            const exponent = 0.1 + (amount * 0.5);
                            mappedFreq = Math.pow(normalizedFreq, exponent);
                            break;

                        case 'sqrt':
                            mappedFreq = Math.pow(normalizedFreq, 0.5 - amount * 0.03);
                            break;

                        case 'cbrt':
                            mappedFreq = Math.pow(normalizedFreq, 0.33 - amount * 0.02);
                            break;

                        case 'nroot':
                            const rootPower = 1 + amount;
                            mappedFreq = Math.pow(normalizedFreq, 1 / rootPower);
                            break;

                        case 'square':
                            mappedFreq = Math.pow(normalizedFreq, 2 + amount * 0.5);
                            break;

                        case 'cube':
                            mappedFreq = Math.pow(normalizedFreq, 3 + amount);
                            break;

                        case 'quartic':
                            mappedFreq = Math.pow(normalizedFreq, 4 + amount);
                            break;

                        case 'quintic':
                            mappedFreq = Math.pow(normalizedFreq, 5 + amount);
                            break;

                        case 'inverse':
                            mappedFreq = inverseFrequencyMapping(normalizedFreq, amount);
                            magnitudeMultiplier = Math.min(0.5 + 0.2 * Math.tanh(amount), 1.0);
                            break;

                        // === LOGARITHMIC & EXPONENTIAL ===
                        case 'log':
                            mappedFreq = Math.log(1 + normalizedFreq * (Math.E - 1) * amount) / amount;
                            break;

                        case 'log10':
                            mappedFreq = Math.log10(1 + normalizedFreq * 9 * amount) / Math.log10(1 + 9 * amount);
                            break;

                        case 'log2':
                            mappedFreq = Math.log2(1 + normalizedFreq * 3 * amount) / Math.log2(1 + 3 * amount);
                            break;

                        case 'exp':
                            mappedFreq = (Math.exp(normalizedFreq * amount) - 1) / (Math.exp(amount) - 1);
                            break;

                        case 'exp2':
                            mappedFreq = (Math.pow(2, normalizedFreq * amount) - 1) / (Math.pow(2, amount) - 1);
                            break;

                        case 'exp10':
                            mappedFreq = (Math.pow(10, normalizedFreq * amount * 0.5) - 1) / (Math.pow(10, amount * 0.5) - 1);
                            break;

                        // === TRIGONOMETRIC FUNCTIONS ===
                        case 'sin':
                            mappedFreq = (1 + Math.sin((normalizedFreq * Math.PI * 2 * amount) - Math.PI / 2)) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.sin(normalizedFreq * Math.PI * amount);
                            phaseShift = Math.sin(normalizedFreq * Math.PI * amount) * 0.5;
                            break;

                        case 'cos':
                            mappedFreq = (1 + Math.cos((normalizedFreq * Math.PI * 2 * amount) - Math.PI / 2)) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.cos(normalizedFreq * Math.PI * amount);
                            break;

                        case 'tan':
                            const tanInput = (normalizedFreq - 0.5) * Math.PI * 0.8 * amount;
                            mappedFreq = (Math.atan(Math.tan(tanInput)) / (Math.PI * 0.8 * amount)) + 0.5;
                            mappedFreq = Math.max(0, Math.min(1, mappedFreq));
                            break;

                        case 'csc':
                            mappedFreq = (1 + (1 / Math.sin((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        case 'sec':
                            mappedFreq = (1 + (1 / Math.cos((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        case 'cot':
                            mappedFreq = (1 + (1 / Math.tan((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        // === INVERSE TRIGONOMETRIC ===
                        case 'asin':
                            const asinInput = (normalizedFreq * 2 - 1) * Math.min(0.99, amount * 0.1);
                            mappedFreq = (Math.asin(asinInput) / Math.asin(Math.min(0.99, amount * 0.1)) + 1) / 2;
                            break;

                        case 'acos':
                            const acosInput = Math.min(0.99, amount * 0.1);
                            mappedFreq = Math.acos(normalizedFreq * acosInput) / Math.acos(acosInput);
                            break;

                        case 'atan':
                            const atanInput = (normalizedFreq - 0.5) * amount * 2;
                            mappedFreq = (Math.atan(atanInput) / Math.atan(amount * 2)) * 0.5 + 0.5;
                            break;

                        case 'atan2':
                            mappedFreq = (Math.atan2(normalizedFreq, amount) + Math.PI) / (2 * Math.PI);
                            break;

                        // === HYPERBOLIC FUNCTIONS ===
                        case 'sinh':
                            const sinhInput = (normalizedFreq - 0.5) * amount;
                            mappedFreq = Math.tanh(Math.sinh(sinhInput) * 0.5) * 0.5 + 0.5;
                            magnitudeMultiplier = 1 + 0.2 * Math.abs(Math.sinh(sinhInput));
                            break;

                        case 'cosh':
                            const coshInput = (normalizedFreq - 0.5) * amount;
                            mappedFreq = (Math.cosh(coshInput) - 1) / (Math.cosh(amount) - 1);
                            break;

                        case 'tanh':
                            const tanhInput = (normalizedFreq - 0.5) * amount * 3;
                            mappedFreq = (Math.tanh(tanhInput) + 1) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.abs(Math.tanh(tanhInput));
                            break;

                        case 'csch':
                            mappedFreq = (1 + (1 / Math.sinh((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        case 'sech':
                            mappedFreq = (1 + (1 / Math.cosh((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        case 'coth':
                            mappedFreq = (1 + (1 / Math.tanh((normalizedFreq * Math.PI * amount) + 0.01))) / 2;
                            break;

                        // === INVERSE HYPERBOLIC ===
                        case 'asinh':
                            mappedFreq = (Math.asinh(normalizedFreq * amount) / Math.asinh(amount)) || 0;
                            break;

                        case 'acosh':
                            mappedFreq = (Math.acosh(1 + normalizedFreq * (amount - 1)) / Math.acosh(amount)) || 0;
                            break;

                        case 'atanh':
                            mappedFreq = (Math.atanh(normalizedFreq * (1 - 1e-6)) / Math.atanh(1 - 1e-6)) * amount;
                            break;

                        // === COMPLEX NUMBER OPERATIONS ===
                        case 'complex_magnitude':
                            // For complex_magnitude, amount controls THETA (angle) for each frequency bin
                            // Map: new bin = magnitude * exp(i * (phase + amount * normalizedFreq * 2π))
                            // This rotates each frequency bin by an amount-proportional phase
                            mappedFreq = normalizedFreq; // Keep frequency bin unchanged
                            magnitudeMultiplier = 1.0;
                            phaseShift = amount * normalizedFreq * 2 * Math.PI;
                            // This will cause wild frequency rotation as amount is moved
                            // Rotate each frequency bin by amount * normalizedFreq * 2π (wild rotation)
                            // This is a true complex rotation: new real/imag = magnitude * exp(i * (phase + theta))
                            // But to "get brand new frequencies from the complex plane", we rotate the bin's phase and
                            // also shift the frequency bin index by amount * normalizedFreq * (fftSize/2)
                            // This creates wild frequency rotation and cross-mapping.

                            // Calculate rotation angle (theta) for this bin
                            const theta = amount * normalizedFreq * 2 * Math.PI;

                            // New phase is phase + theta
                            const newPhase = phase + theta;

                            // Optionally, shift the frequency bin index by a function of amount and normalizedFreq
                            // For maximum "wild" effect, let the bin shift wrap around the spectrum
                            let freqShift = Math.round(amount * Math.sin(normalizedFreq * Math.PI) * (fftSize / 4));
                            let newBin = i + freqShift;

                            // Wrap newBin into valid range
                            if (newBin < 1) newBin = 1 + ((newBin + fftSize / 2) % (fftSize / 2));
                            if (newBin >= fftSize / 2) newBin = 1 + ((newBin - 1) % (fftSize / 2));

                            // Place rotated magnitude/phase into new bin
                            real[newBin] += magnitude * Math.cos(newPhase);
                            imag[newBin] += magnitude * Math.sin(newPhase);

                            // Mirror for negative frequencies
                            const negBin = fftSize - newBin;
                            if (negBin < fftSize) {
                                real[negBin] = real[newBin];
                                imag[negBin] = -imag[newBin];
                            }
                            continue;

                        case 'complex_phase':
                            // Remap frequency bin index to shift frequency, not just rotate phase
                            // Example: shift bins by amount*normalizedFreq*(fftSize/4) for audible effect
                            const freqShift_phase = Math.round(amount * Math.sin(normalizedFreq * Math.PI) * (fftSize / 4));
                            let newBin_phase = i + freqShift_phase;

                            // Wrap newBin into valid range
                            if (newBin_phase < 1) newBin_phase = 1 + ((newBin_phase + fftSize / 2) % (fftSize / 2));
                            if (newBin_phase >= fftSize / 2) newBin_phase = 1 + ((newBin_phase - 1) % (fftSize / 2));

                            // Rotate phase as well
                            const theta_phase = amount * normalizedFreq * 2 * Math.PI;
                            const newPhase_phase = phase + theta_phase;

                            // Place rotated magnitude/phase into new bin
                            real[newBin_phase] += magnitude * Math.cos(newPhase_phase);
                            imag[newBin_phase] += magnitude * Math.sin(newPhase_phase);

                            // Mirror for negative frequencies
                            const negBin_phase = fftSize - newBin_phase;
                            if (negBin_phase < fftSize) {
                                real[negBin_phase] = real[newBin_phase];
                                imag[negBin_phase] = -imag[newBin_phase];
                            }
                            continue;

                        case 'conjugate':
                            mappedFreq = 1 - normalizedFreq * (amount * 0.1);
                            phaseShift = -phase * amount * 0.1;
                            break;

                        case 'reciprocal':
                            // True complex reciprocal: 1/(re + i*im)
                            // Avoid division by zero
                            if (Math.abs(tempReal[i]) < 1e-12 && Math.abs(tempImag[i]) < 1e-12) {
                                // If zero, skip or set to zero
                                continue;
                            } else {
                                // Compute reciprocal in complex plane: 1/(a+ib) = (a-ib)/(a^2+b^2)
                                const denom = tempReal[i] * tempReal[i] + tempImag[i] * tempImag[i];
                                const recipReal = tempReal[i] / denom;
                                const recipImag = -tempImag[i] / denom;

                                // Optionally, scale by amount
                                const outReal = recipReal * amount;
                                const outImag = recipImag * amount;

                                // Place in same bin (no frequency mapping)
                                real[i] = outReal;
                                imag[i] = outImag;

                                // Mirror for negative frequencies
                                const negBin = fftSize - i;
                                if (negBin < fftSize) {
                                    real[negBin] = outReal;
                                    imag[negBin] = -outImag;
                                }
                                continue;
                            }

                        case 'abs_square':
                            mappedFreq = normalizedFreq * normalizedFreq * amount;
                            break;

                        // === FAMOUS PHYSICS EQUATIONS ===
                        case 'schrodinger':
                            const x_pos = (normalizedFreq - 0.5) * 6;
                            const n_level = Math.floor(amount) % 10;
                            const hermite = Math.exp(-x_pos * x_pos / 2) * Math.pow(x_pos, n_level);
                            mappedFreq = normalizedFreq * (1 + 0.5 * hermite * (amount * 0.1));
                            magnitudeMultiplier = 1 + 0.3 * Math.abs(hermite);
                            break;

                        case 'heisenberg':
                            const uncertainty = amount / (normalizedFreq * 10 + 1);
                            mappedFreq = normalizedFreq * (1 + uncertainty * 0.3);
                            magnitudeMultiplier = 1 + uncertainty * 0.2;
                            break;

                        case 'einstein_mass_energy':
                            const mass = amount;
                            const energy = mass * Math.pow(normalizedFreq, 2);
                            mappedFreq = Math.min(1, Math.max(0, energy));
                            magnitudeMultiplier = 0.5 + (energy * 3);
                            break;

                        case 'planck_radiation':
                            const temp = 1000 + amount * 500;
                            const planckCurve = Math.pow(normalizedFreq, 3) / (Math.exp(normalizedFreq * 20 / temp) - 1);
                            mappedFreq = normalizedFreq * (1 + planckCurve * amount * 0.1);
                            magnitudeMultiplier = 1 + planckCurve * amount * 0.2;
                            break;

                        case 'maxwell_boltzmann':
                            const v = normalizedFreq * amount;
                            mappedFreq = v * v * Math.exp(-v * v / 2);
                            break;

                        case 'wave_equation':
                            const modeNum = Math.floor(amount) % 20 + 1;
                            const standingWave = Math.sin(normalizedFreq * Math.PI * modeNum);
                            mappedFreq = normalizedFreq * (1 + standingWave * amount * 0.1);
                            magnitudeMultiplier = 1 + Math.abs(standingWave) * amount * 0.3;
                            break;

                        case 'heat_equation':
                            mappedFreq = normalizedFreq * Math.exp(-amount * normalizedFreq);
                            break;

                        case 'lorentz_factor':
                            const v_lorentz = normalizedFreq * amount;
                            mappedFreq = normalizedFreq / Math.sqrt(1 - v_lorentz * v_lorentz / (299792458 * 299792458));
                            break;

                        case 'schwarzschild':
                            mappedFreq = normalizedFreq / (1 - amount * normalizedFreq);
                            break;

                        case 'compton_scattering':
                            mappedFreq = normalizedFreq / (1 + amount * (1 - Math.cos(normalizedFreq * Math.PI)));
                            break;

                        // === SPECIAL FUNCTIONS ===
                        case 'gamma':
                            mappedFreq = Math.exp(normalizedFreq * amount) * Math.sqrt(2 * Math.PI / normalizedFreq);
                            break;

                        case 'factorial':
                            mappedFreq = Math.exp(normalizedFreq * Math.log(normalizedFreq * amount + 1));
                            break;

                        case 'zeta':
                            mappedFreq = 1 / Math.pow(normalizedFreq + 1, amount);
                            break;

                        case 'eta':
                            mappedFreq = (1 - Math.pow(-1, normalizedFreq + 1)) / Math.pow(normalizedFreq + 1, amount);
                            break;

                        case 'bessel_j0':
                            mappedFreq = Math.abs(Math.sin(normalizedFreq * amount) / (normalizedFreq * amount + 0.01));
                            break;

                        case 'bessel_y0':
                            mappedFreq = Math.abs(Math.cos(normalizedFreq * amount) / (normalizedFreq * amount + 0.01));
                            break;

                        case 'bessel_i0':
                            mappedFreq = Math.abs(Math.sinh(normalizedFreq * amount) / (normalizedFreq * amount + 0.01));
                            break;

                        case 'bessel_k0':
                            mappedFreq = Math.abs(Math.cosh(normalizedFreq * amount) / (normalizedFreq * amount + 0.01));
                            break;

                        case 'airy_ai':
                            mappedFreq = Math.abs(Math.sin(Math.pow(normalizedFreq * amount, 1.5)));
                            break;

                        case 'airy_bi':
                            mappedFreq = Math.abs(Math.cos(Math.pow(normalizedFreq * amount, 1.5)));
                            break;

                        case 'erf':
                            mappedFreq = (2 / Math.sqrt(Math.PI)) * Math.exp(-Math.pow(normalizedFreq * amount, 2));
                            break;

                        case 'erfc':
                            mappedFreq = 1 - (2 / Math.sqrt(Math.PI)) * Math.exp(-Math.pow(normalizedFreq * amount, 2));
                            break;

                        // === GEOMETRIC TRANSFORMATIONS ===
                        case 'mobius': {
                            const nyquist = sampleRate / 2;
                            const maxFreq = nyquist * 2;
                            function mod(n, m) { return ((n % m) + m) % m; }
                            let shiftedFreq = mod(frequency + amount, maxFreq);
                            mappedFreq = shiftedFreq / maxFreq;
                            break;
                        }

                        case 'joukowsky':
                            const jouZ = normalizedFreq * 2 - 1;
                            const jouResult = 0.5 * (jouZ + amount * 0.2 / (jouZ + 0.01));
                            mappedFreq = (jouResult + 1) / 2;
                            mappedFreq = Math.max(0, Math.min(1, mappedFreq));
                            break;

                        case 'schwarz_christoffel':
                            mappedFreq = Math.pow(normalizedFreq, amount) * Math.sin(Math.PI * normalizedFreq * amount);
                            break;

                        case 'cayley':
                            mappedFreq = (normalizedFreq - amount) / (normalizedFreq + amount + 0.01);
                            break;

                        // === SPIRAL TRANSFORMATIONS ===
                        case 'spiral':
                            const spiralR = normalizedFreq;
                            const spiralTheta = normalizedFreq * Math.PI * 2 * amount;
                            const spiralX = spiralR * Math.cos(spiralTheta);
                            mappedFreq = (spiralX + 1) / 2;
                            break;

                        case 'fibonacci_spiral':
                            const phi = (1 + Math.sqrt(5)) / 2;
                            mappedFreq = Math.pow(phi, normalizedFreq * amount) % 1;
                            break;

                        case 'archimedean_spiral':
                            mappedFreq = (normalizedFreq + amount * normalizedFreq) % 1;
                            break;

                        case 'fermat_spiral':
                            mappedFreq = Math.sqrt(normalizedFreq * amount) % 1;
                            break;

                        case 'hyperbolic_spiral':
                            mappedFreq = (1 / (normalizedFreq * amount + 0.01)) % 1;
                            break;

                        case 'ulam_spiral':
                            mappedFreq = ((normalizedFreq * amount) % 1) * Math.sin(normalizedFreq * Math.PI * amount);
                            break;

                        // === FRACTALS & CHAOS ===
                        case 'mandelbrot':
                            let zr = (normalizedFreq - 0.5) * 3;
                            let zi = 0;
                            const cr = -0.5 + amount * 0.1;
                            const ci = 0.6 * amount * 0.1;
                            let iter = 0;
                            const maxIter = 50;
                            while (iter < maxIter && zr * zr + zi * zi < 4) {
                                const temp = zr * zr - zi * zi + cr;
                                zi = 2 * zr * zi + ci;
                                zr = temp;
                                iter++;
                            }
                            const escape = iter / maxIter;
                            mappedFreq = normalizedFreq * (0.5 + escape * 0.5 * amount * 0.1);
                            magnitudeMultiplier = 0.5 + escape * amount * 0.1;
                            break;

                        case 'julia':
                            const juliaC_r = -0.7 + amount * 0.05;
                            const juliaC_i = 0.27 + amount * 0.05;
                            let jr = (normalizedFreq - 0.5) * 2;
                            let ji = 0.1 * amount;
                            let juliaIter = 0;
                            while (juliaIter < 30 && jr * jr + ji * ji < 4) {
                                const temp = jr * jr - ji * ji + juliaC_r;
                                ji = 2 * jr * ji + juliaC_i;
                                jr = temp;
                                juliaIter++;
                            }
                            const juliaEscape = juliaIter / 30;
                            mappedFreq = normalizedFreq * (0.3 + juliaEscape * 0.7 * amount * 0.1);
                            break;

                        case 'burning_ship':
                            let bsr = (normalizedFreq - 0.5) * 2;
                            let bsi = 0;
                            const bcr = -0.4 + amount * 0.05;
                            const bci = 0.6 * amount * 0.05;
                            let bsIter = 0;
                            const bsMaxIter = 40;
                            while (bsIter < bsMaxIter && bsr * bsr + bsi * bsi < 4) {
                                const temp = bsr * bsr - bsi * bsi + bcr;
                                bsi = Math.abs(2 * bsr * bsi) + bci;
                                bsr = Math.abs(temp);
                                bsIter++;
                            }
                            const bsEscape = bsIter / bsMaxIter;
                            mappedFreq = normalizedFreq * (0.4 + bsEscape * 0.6 * amount * 0.5);
                            break;

                        case 'tricorn':
                            let tr = (normalizedFreq - 0.5) * 2;
                            let ti = 0;
                            const tcr = -0.5 + amount * 0.1;
                            const tci = 0.6 * amount * 0.1;
                            let tIter = 0;
                            const tMaxIter = 40;
                            while (tIter < tMaxIter && tr * tr + ti * ti < 4) {
                                const temp = tr * tr - ti * ti + tcr;
                                ti = -2 * tr * ti + tci;
                                tr = temp;
                                tIter++;
                            }
                            const tEscape = tIter / tMaxIter;
                            mappedFreq = normalizedFreq * (0.4 + tEscape * 0.6 * amount * 0.1);
                            break;

                        case 'multibrot':
                            let mr = (normalizedFreq - 0.5) * 2;
                            let mi = 0;
                            const mcr = -0.5 + amount * 0.1;
                            const mci = 0.6 * amount * 0.1;
                            let mIter = 0;
                            const mMaxIter = 40;
                            const mbPower = Math.round(amount) + 2;
                            while (mIter < mMaxIter && mr * mr + mi * mi < 4) {
                                let r = mr, i = mi;
                                for (let p = 1; p < mbPower; p++) {
                                    const tempR = r * mr - i * mi;
                                    const tempI = r * mi + i * mr;
                                    r = tempR;
                                    i = tempI;
                                }
                                const temp = r + mcr;
                                mi = i + mci;
                                mr = temp;
                                mIter++;
                            }
                            const mEscape = mIter / mMaxIter;
                            mappedFreq = normalizedFreq * (0.4 + mEscape * 0.6 * amount * 0.1);
                            break;

                        case 'newton_raphson':
                            let nr = (normalizedFreq - 0.5) * 2;
                            let ni = 0;
                            let nIter = 0;
                            const nMaxIter = 20;
                            for (; nIter < nMaxIter; nIter++) {
                                const denom = 3 * (nr * nr - ni * ni);
                                if (Math.abs(denom) < 1e-6) break;
                                const temp = nr - (nr * nr * nr - 3 * nr * ni * ni - 1) / denom;
                                ni = ni - (3 * nr * nr * ni - ni * ni * ni) / denom;
                                nr = temp;
                                if (nr * nr + ni * ni > 4) break;
                            }
                            const nEscape = nIter / nMaxIter;
                            mappedFreq = normalizedFreq * (0.5 + nEscape * 0.5 * amount * 0.1);
                            break;

                        case 'nova':
                            mappedFreq = normalizedFreq + amount * Math.sin(normalizedFreq * Math.PI * amount);
                            break;

                        case 'phoenix':
                            mappedFreq = normalizedFreq + amount * Math.cos(normalizedFreq * Math.PI * amount);
                            break;

                        case 'magnet':
                            mappedFreq = Math.abs(Math.sin(normalizedFreq * Math.PI * amount));
                            break;

                        case 'lambda':
                            mappedFreq = amount * normalizedFreq * (1 - normalizedFreq);
                            break;

                        case 'spider':
                            mappedFreq = Math.abs(normalizedFreq * normalizedFreq + amount / (normalizedFreq + 0.01));
                            break;

                        case 'henon_map':
                            let hx = normalizedFreq;
                            let hy = 0;
                            const a_henon = 1.4 + amount * 0.1;
                            const b_henon = 0.3 + amount * 0.01;
                            let hIter = 0;
                            const hMaxIter = 20;
                            for (; hIter < hMaxIter; hIter++) {
                                const temp = 1 - a_henon * hx * hx + hy;
                                hy = b_henon * hx;
                                hx = temp;
                            }
                            mappedFreq = (hx + 1) / 2;
                            break;

                        case 'lorenz_attractor':
                            let lx = 0.1 + normalizedFreq * 0.8;
                            let ly = 0;
                            let lz = 0;
                            const sigma = 10 + amount;
                            const rho = 28 + amount * 2;
                            const beta = 8 / 3;
                            let lzIter = 0;
                            const lzMaxIter = 10;
                            for (; lzIter < lzMaxIter; lzIter++) {
                                const dx = sigma * (ly - lx) * 0.01;
                                const dy = (lx * (rho - lz) - ly) * 0.01;
                                const dz = (lx * ly - beta * lz) * 0.01;
                                lx += dx;
                                ly += dy;
                                lz += dz;
                            }
                            mappedFreq = (lx + 30) / 60;
                            break;

                        case 'logistic_map':
                            let x = normalizedFreq;
                            const r = 2.5 + amount * 0.35;
                            let lIter = 0;
                            const lMaxIter = 30;
                            for (; lIter < lMaxIter; lIter++) {
                                x = r * x * (1 - x);
                            }
                            mappedFreq = x;
                            break;

                        case 'tent_map':
                            let tx = normalizedFreq;
                            const tentR = amount;
                            for (let t = 0; t < 20; t++) {
                                tx = tx < 0.5 ? tentR * tx : tentR * (1 - tx);
                            }
                            mappedFreq = tx;
                            break;

                        // === WAVE FUNCTIONS ===
                        case 'wave':
                            mappedFreq = normalizedFreq + amount * Math.sin(normalizedFreq * Math.PI * amount);
                            break;

                        case 'ripple':
                            mappedFreq = normalizedFreq + Math.sin(normalizedFreq * Math.PI * amount) / (amount + 1);
                            break;

                        case 'standing_wave':
                            mappedFreq = normalizedFreq * Math.abs(Math.sin(normalizedFreq * Math.PI * amount));
                            break;

                        case 'beat_frequency':
                            mappedFreq = normalizedFreq + Math.sin(amount * normalizedFreq * Math.PI * 2) * 0.01;
                            break;

                        case 'doppler_effect':
                            mappedFreq = normalizedFreq / (1 - amount * Math.cos(normalizedFreq * Math.PI));
                            break;

                        case 'gaussian_wave':
                            mappedFreq = Math.exp(-Math.pow((normalizedFreq - 0.5) * amount, 2));
                            break;

                        case 'sinc_function':
                            mappedFreq = Math.abs(Math.sin(normalizedFreq * amount) / (normalizedFreq * amount + 0.01));
                            break;

                        case 'chirp':
                            mappedFreq = normalizedFreq + amount * normalizedFreq * normalizedFreq;
                            break;

                        case 'morlet_wavelet':
                            mappedFreq = Math.exp(-Math.pow((normalizedFreq - 0.5) * amount, 2)) * Math.cos(2 * Math.PI * normalizedFreq * amount);
                            break;

                        case 'mexican_hat':
                            mappedFreq = (1 - Math.pow((normalizedFreq - 0.5) * amount, 2)) * Math.exp(-0.5 * Math.pow((normalizedFreq - 0.5) * amount, 2));
                            break;

                        // === SPECIAL PATTERNS ===
                        case 'dirac_delta':
                            mappedFreq = normalizedFreq === amount ? 1 : 0;
                            break;

                        case 'heaviside_step':
                            mappedFreq = normalizedFreq > amount ? 1 : 0;
                            break;

                        case 'sawtooth':
                            mappedFreq = (normalizedFreq * amount) % 1;
                            break;

                        case 'square_wave':
                            mappedFreq = ((normalizedFreq * amount) % 1) > 0.5 ? 1 : 0;
                            break;

                        case 'triangle_wave':
                            mappedFreq = 1 - 4 * Math.abs(Math.round(normalizedFreq * amount - 0.25) - (normalizedFreq * amount - 0.25));
                            break;

                        case 'pulse_train':
                            mappedFreq = ((normalizedFreq * amount) % 1) < 0.1 ? 1 : 0;
                            break;

                        // === STEREO PANNING EFFECTS ===
                        case 'stereo_real_imag':
                            // Real component → Left channel, Imaginary → Right channel
                            mappedFreq = normalizedFreq;
                            const realComponent = tempReal[i];
                            const imagComponent = tempImag[i];
                            // Channel 0 (left) gets real part, Channel 1 (right) gets imaginary
                            if (currentParams.stereoChannel === 0) {
                                real[i] = realComponent * amount * 0.5;
                                imag[i] = imagComponent * amount * 0.1; // Small amount of imag for texture
                            } else {
                                real[i] = imagComponent * amount * 0.5;
                                imag[i] = realComponent * amount * 0.1; // Small amount of real for texture
                            }
                            // Mirror for negative frequencies
                            const negBin_real = fftSize - i;
                            if (negBin_real < fftSize) {
                                real[negBin_real] = real[i];
                                imag[negBin_real] = -imag[i];
                            }
                            continue;

                        case 'stereo_mag_phase':
                            // Magnitude → Left channel, Phase → Right channel
                            mappedFreq = normalizedFreq;
                            const magComponent = Math.sqrt(tempReal[i] * tempReal[i] + tempImag[i] * tempImag[i]);
                            const phaseComponent = Math.atan2(tempImag[i], tempReal[i]);
                            // Channel 0 (left) gets magnitude, Channel 1 (right) gets phase-derived signal
                            if (currentParams.stereoChannel === 0) {
                                real[i] = magComponent * Math.cos(phaseComponent * 0.1) * amount * 0.5;
                                imag[i] = magComponent * Math.sin(phaseComponent * 0.1) * amount * 0.1;
                            } else {
                                real[i] = magComponent * Math.cos(phaseComponent * amount * 0.5) * 0.5;
                                imag[i] = magComponent * Math.sin(phaseComponent * amount * 0.5) * 0.5;
                            }
                            // Mirror for negative frequencies
                            const negBin_mag = fftSize - i;
                            if (negBin_mag < fftSize) {
                                real[negBin_mag] = real[i];
                                imag[negBin_mag] = -imag[i];
                            }
                            continue;

                        case 'stereo_rotation':
                            // Complex rotation creates rotating panning field
                            const rotationAngle = amount * normalizedFreq * Math.PI * 2;
                            // Apply different rotation amounts for each channel
                            const channelOffset = currentParams.stereoChannel * Math.PI * 0.5; // 90° offset between channels
                            const finalAngle = rotationAngle + channelOffset;
                            const rotCos = Math.cos(finalAngle);
                            const rotSin = Math.sin(finalAngle);
                            // Rotate the complex number
                            const rotatedReal = tempReal[i] * rotCos - tempImag[i] * rotSin;
                            const rotatedImag = tempReal[i] * rotSin + tempImag[i] * rotCos;
                            mappedFreq = normalizedFreq;
                            real[i] = rotatedReal;
                            imag[i] = rotatedImag;
                            // Mirror for negative frequencies
                            const negBin_rot = fftSize - i;
                            if (negBin_rot < fftSize) {
                                real[negBin_rot] = rotatedReal;
                                imag[negBin_rot] = -rotatedImag;
                            }
                            continue;

                        case 'stereo_spiral_pan':
                            // Frequency-dependent spiral panning
                            const spiralAngle = normalizedFreq * amount * Math.PI * 4;
                            const spiralRadius = normalizedFreq * amount * 0.5;
                            // Apply different spiral offset for each channel
                            const spiralChannelOffset = currentParams.stereoChannel * Math.PI; // 180° offset
                            const spiralPanX = spiralRadius * Math.cos(spiralAngle + spiralChannelOffset);
                            const spiralPanY = spiralRadius * Math.sin(spiralAngle + spiralChannelOffset);
                            mappedFreq = normalizedFreq;
                            real[i] = magnitude * Math.cos(phase + spiralPanX);
                            imag[i] = magnitude * Math.sin(phase + spiralPanY);
                            // Mirror for negative frequencies
                            const negBin_spiral = fftSize - i;
                            if (negBin_spiral < fftSize) {
                                real[negBin_spiral] = real[i];
                                imag[negBin_spiral] = -imag[i];
                            }
                            continue;

                        case 'stereo_doppler_pan':
                            // Moving source simulation with Doppler effect
                            const velocity = Math.sin(amount * 0.1) * 0.5; // Oscillating velocity
                            // Apply different velocity directions for each channel
                            const channelVelocity = currentParams.stereoChannel === 0 ? velocity : -velocity;
                            const dopplerShift = 1 / (1 + channelVelocity * normalizedFreq);
                            mappedFreq = normalizedFreq * dopplerShift;
                            // Pan based on velocity direction
                            const panPosition = channelVelocity * amount * 0.2;
                            magnitudeMultiplier = 1 + Math.abs(panPosition) * 0.3;
                            phaseShift = panPosition * Math.PI;
                            break;

                        case 'stereo_binaural':
                            // Binaural beats - slight frequency difference between channels
                            const beatFreq = amount * 0.5; // Beat frequency in Hz
                            // Apply frequency offset based on channel
                            const freqOffset = currentParams.stereoChannel === 0 ? -beatFreq * 0.5 : beatFreq * 0.5;
                            const channelFreq = normalizedFreq * (1 + freqOffset / (frequency + 1));
                            mappedFreq = channelFreq;
                            // Create phase difference for binaural effect
                            phaseShift = beatFreq * normalizedFreq * Math.PI * currentParams.stereoChannel;
                            magnitudeMultiplier = 1 + 0.2 * Math.sin(beatFreq * normalizedFreq * Math.PI * 2);
                            break;

                        // === QUANTUM & EXOTIC ===
                        case 'quantum_harmonic':
                            mappedFreq = Math.abs(Math.sin(normalizedFreq * Math.PI * amount));
                            break;

                        case 'hydrogen_orbital':
                            mappedFreq = Math.exp(-normalizedFreq * amount) * Math.pow(normalizedFreq, amount);
                            break;

                        case 'tunneling_effect':
                            mappedFreq = normalizedFreq * Math.exp(-amount * normalizedFreq);
                            break;

                        case 'klein_gordon':
                            mappedFreq = normalizedFreq / Math.sqrt(1 + amount * normalizedFreq * normalizedFreq);
                            break;

                        case 'dirac_equation':
                            mappedFreq = normalizedFreq + amount * Math.sin(normalizedFreq * Math.PI * amount);
                            break;

                        case 'feynman_diagram':
                            mappedFreq = normalizedFreq + Math.cos(amount * normalizedFreq * Math.PI * 2) * 0.01;
                            break;
                    } // <-- Add this closing brace to end the switch statement

                    // Apply simple frequency clamping to prevent aliasing
                    mappedFreq = Math.max(0, Math.min(1, mappedFreq));

                    // Add subtle stereo enhancement for non-stereo functions
                    if (!selectedFunction.startsWith('stereo_') && currentParams.stereoChannel !== undefined) {
                        // Add slight phase and frequency offset for stereo width
                        const stereoOffset = (currentParams.stereoChannel - 0.5) * 0.1; // -0.05 to +0.05
                        phaseShift += stereoOffset * normalizedFreq * Math.PI;
                        magnitudeMultiplier *= (1 + stereoOffset * 0.2); // Slight level difference
                    }

                    // Convert back to actual frequency in the selected range
                    const newFrequency = minFreq + mappedFreq * (maxFreq - minFreq);
                    const newBin = Math.round(newFrequency / binSize);

                    // Only place frequency content in valid bins
                    if (newBin > 0 && newBin < fftSize / 2) {
                        // Apply magnitude and phase modifications
                        const finalMagnitude = magnitude * magnitudeMultiplier;
                        const finalPhase = phase + phaseShift;

                        // Convert back to real/imaginary
                        real[newBin] += finalMagnitude * Math.cos(finalPhase);
                        imag[newBin] += finalMagnitude * Math.sin(finalPhase);

                        // Mirror for negative frequencies (maintain symmetry)
                        const negBin = fftSize - newBin;
                        if (negBin < fftSize) {
                            real[negBin] = real[newBin];
                            imag[negBin] = -imag[newBin];
                        }
                    }
                }

                // Preserve DC component
                real[0] = tempReal[0];
                imag[0] = 0;

            } catch (error) {
                console.error(`Error in applyComplexFunction (${funcName}):`, error);
                // On error, just copy original data
                for (let i = 0; i < fftSize; i++) {
                    real[i] = tempReal[i];
                    imag[i] = tempImag[i];
                }
            }
        }

        // STFT Implementation
        function stft(audioData, fftSize, hopSize, windowFunc) {
            const numFrames = Math.floor((audioData.length - fftSize) / hopSize) + 1;
            const frames = [];

            for (let i = 0; i < numFrames; i++) {
                const start = i * hopSize;
                const frame = audioData.slice(start, start + fftSize);

                // Apply window
                for (let j = 0; j < fftSize; j++) {
                    frame[j] *= windowFunc[j];
                }

                frames.push(frame);
            }

            return frames;
        }

        // Custom FFT Implementation
        function fft(real, imag) {
            const n = real.length;
            if (n <= 1) return;

            // Ensure n is a power of 2
            if ((n & (n - 1)) !== 0) {
                console.error('FFT size must be a power of 2');
                return;
            }

            // Bit-reversal permutation
            for (let i = 0; i < n; i++) {
                let j = 0;
                let temp = i;
                for (let k = 0; k < Math.log2(n); k++) {
                    j = (j << 1) | (temp & 1);
                    temp >>= 1;
                }
                if (j > i) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
            }

            // Cooley-Tukey FFT
            for (let len = 2; len <= n; len *= 2) {
                const angle = -2 * Math.PI / len;
                const wlen = { re: Math.cos(angle), im: Math.sin(angle) };

                for (let i = 0; i < n; i += len) {
                    let w = { re: 1, im: 0 };

                    for (let j = 0; j < len / 2; j++) {
                        const u = { re: real[i + j], im: imag[i + j] };
                        const v = {
                            re: real[i + j + len / 2] * w.re - imag[i + j + len / 2] * w.im,
                            im: real[i + j + len / 2] * w.im + imag[i + j + len / 2] * w.re
                        };

                        real[i + j] = u.re + v.re;
                        imag[i + j] = u.im + v.im;
                        real[i + j + len / 2] = u.re - v.re;
                        imag[i + j + len / 2] = u.im - v.im;

                        const newW = {
                            re: w.re * wlen.re - w.im * wlen.im,
                            im: w.re * wlen.im + w.im * wlen.re
                        };
                        w = newW;
                    }
                }
            }
        }

        // Inverse FFT
        function ifft(real, imag) {
            const n = real.length;

            // Conjugate
            for (let i = 0; i < n; i++) {
                imag[i] = -imag[i];
            }

            // Forward FFT
            fft(real, imag);

            // Conjugate and scale
            for (let i = 0; i < n; i++) {
                real[i] /= n;
                imag[i] = -imag[i] / n;
            }
        }

        // Main audio processing function with proper frequency transformations
        async function processAudio() {
            if (!audioBuffer) {
                showStatus('No audio loaded', 'error');
                return null;
            }

            showStatus('Processing audio...', 'info');

            try {
                const fftSize = Math.pow(2, parseInt(document.getElementById('fftSizeSlider').value));
                const overlapFactor = Math.pow(2, parseInt(document.getElementById('overlapSlider').value));
                const hopSize = Math.floor(fftSize / overlapFactor);
                const amount = parseFloat(document.getElementById('powerSlider').value);
                const smoothing = parseFloat(document.getElementById('smoothingSlider').value);
                const mixValue = parseFloat(document.getElementById('mixSlider').value) / 100;
                const gain = parseFloat(document.getElementById('gainSlider').value);

                console.log(`Processing with FFT size: ${fftSize}, hop size: ${hopSize}, amount: ${amount}`);

                const sampleRate = audioBuffer.sampleRate;
                const numChannels = Math.max(2, audioBuffer.numberOfChannels); // Always ensure at least stereo
                const windowFunc = getWindow(fftSize);

                // Process all channels (or create stereo from mono)
                const processedChannels = [];

                for (let channel = 0; channel < 2; channel++) {
                    // Get audio data for this channel (duplicate mono if needed)
                    const audioData = audioBuffer.numberOfChannels > channel ?
                        audioBuffer.getChannelData(channel) :
                        audioBuffer.getChannelData(0);

                    // Perform STFT
                    const frames = stft(audioData, fftSize, hopSize, windowFunc);
                    const processedFrames = [];

                    console.log(`Processing ${frames.length} frames for channel ${channel}`);

                    for (let frameIdx = 0; frameIdx < frames.length; frameIdx++) {
                        const frame = frames[frameIdx];
                        const real = getBuffer(fftSize, 'real');
                        const imag = getBuffer(fftSize, 'imag');

                        // Copy frame data and zero-pad if necessary
                        for (let i = 0; i < fftSize; i++) {
                            real[i] = i < frame.length ? frame[i] : 0;
                            imag[i] = 0;
                        }

                        // Forward FFT
                        fft(real, imag);

                        // Apply function transformation with channel-specific parameters for stereo effects
                        const channelParams = { ...realtimeParams, stereoChannel: channel };
                        applyComplexFunction(real, imag, fftSize, sampleRate, selectedFunction, amount, channelParams);

                        // Apply smoothing in frequency domain
                        if (smoothing > 0) {
                            for (let i = 1; i < fftSize / 2 - 1; i++) {
                                const prevReal = real[i - 1];
                                const prevImag = imag[i - 1];
                                const nextReal = real[i + 1];
                                const nextImag = imag[i + 1];

                                real[i] = real[i] * (1 - smoothing) + (prevReal + nextReal) * smoothing / 2;
                                imag[i] = imag[i] * (1 - smoothing) + (prevImag + nextImag) * smoothing / 2;

                                // Update mirrored bins
                                real[fftSize - i] = real[i];
                                imag[fftSize - i] = -imag[i];
                            }
                        }

                        // Inverse FFT
                        ifft(real, imag);

                        // Store raw IFFT output (no additional windowing)
                        processedFrames.push(real.slice(0, fftSize));
                    }

                    // Overlap-add reconstruction with proper normalization
                    const outputLength = (frames.length - 1) * hopSize + fftSize;
                    const outputBuffer = new Float32Array(outputLength);
                    const normBuffer = new Float32Array(outputLength);

                    // Calculate window normalization factor for overlap-add
                    for (let i = 0; i < frames.length; i++) {
                        const start = i * hopSize;
                        for (let j = 0; j < fftSize; j++) {
                            if (start + j < outputLength) {
                                normBuffer[start + j] += windowFunc[j] * windowFunc[j];
                            }
                        }
                    }

                    // Reconstruct with proper windowing and normalization
                    for (let i = 0; i < processedFrames.length; i++) {
                        const start = i * hopSize;
                        for (let j = 0; j < fftSize; j++) {
                            if (start + j < outputLength) {
                                // Apply synthesis window and accumulate
                                outputBuffer[start + j] += processedFrames[i][j] * windowFunc[j];
                            }
                        }
                    }

                    // Normalize to prevent amplitude modulation
                    for (let i = 0; i < outputLength; i++) {
                        if (normBuffer[i] > 1e-12) {
                            outputBuffer[i] /= normBuffer[i];
                        }
                    }

                    // Mix with original signal for this channel
                    const originalAudioData = audioBuffer.numberOfChannels > channel ?
                        audioBuffer.getChannelData(channel) :
                        audioBuffer.getChannelData(0);
                    const mixedBuffer = new Float32Array(Math.min(outputBuffer.length, originalAudioData.length));
                    for (let i = 0; i < mixedBuffer.length; i++) {
                        const dry = originalAudioData[i];
                        const wet = outputBuffer[i] * gain;
                        mixedBuffer[i] = dry * (1 - mixValue) + wet * mixValue;
                    }

                    processedChannels.push(mixedBuffer);
                }

                // Create new stereo audio buffer
                const finalLength = Math.min(processedChannels[0].length, processedChannels[1].length);
                const newBuffer = ctx.createBuffer(2, finalLength, sampleRate);
                newBuffer.copyToChannel(processedChannels[0], 0); // Left channel
                newBuffer.copyToChannel(processedChannels[1], 1); // Right channel

                showStatus('Audio processing complete!', 'success');
                updateMemoryInfo();

                return newBuffer;

            } catch (error) {
                showStatus(`Error processing audio: ${error.message}`, 'error');
                console.error('Audio processing error:', error);
                return null;
            }
        }

        // Visualization
        function setupVisualization() {
            canvas = document.getElementById('visualizerCanvas');
            canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        function drawVisualization() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const timeArray = new Uint8Array(analyser.fftSize);

            analyser.getByteFrequencyData(dataArray);
            analyser.getByteTimeDomainData(timeArray);

            // Clear canvas with fade effect
            canvasCtx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw frequency spectrum (top half)
            const freqHeight = canvas.height / 2;
            const barWidth = canvas.width / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * freqHeight;

                // Color based on frequency and transformation
                const hue = (i / bufferLength) * 360;
                const saturation = 70 + (dataArray[i] / 255) * 30;
                const lightness = 40 + (dataArray[i] / 255) * 20;

                canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                canvasCtx.fillRect(x, freqHeight - barHeight, barWidth, barHeight);

                x += barWidth;
            }

            // Draw waveform (bottom half)
            canvasCtx.strokeStyle = '#4ecdc4';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();

            const sliceWidth = canvas.width / timeArray.length;
            x = 0;

            for (let i = 0; i < timeArray.length; i++) {
                const v = (timeArray[i] - 128) / 128;
                const y = freqHeight + (v * freqHeight / 2) + freqHeight / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.stroke();

            // Draw function name and parameters
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            canvasCtx.font = '16px Segoe UI';
            canvasCtx.fillText(`Function: ${complexFunctions[selectedFunction].name}`, 10, 25);

            if (isPlaying) {
                canvasCtx.fillStyle = 'rgba(78, 205, 196, 0.8)';
                canvasCtx.fillText('● REAL-TIME', 10, 50);
            }

            // Update time sliders for playing tracks
            updateTimeSliders();

            if (isPlaying) {
                animationId = requestAnimationFrame(drawVisualization);
            }
        }

        // Function to update time sliders during playback
        function updateTimeSliders() {
            if (!ctx) return;

            // Update Track A slider
            if (isPlayingA && trackStartTimeA !== undefined) {
                const currentTimeA = ctx.currentTime - trackStartTimeA;
                const durationA = audioBufferA ? audioBufferA.duration : 0;

                if (durationA > 0) {
                    trackPositionA = currentTimeA % durationA; // Handle looping
                    const sliderA = document.getElementById('timeSliderA');
                    const valueA = document.getElementById('timeValueA');

                    if (sliderA && !timeSliderADragging) { // Don't update if user is dragging
                        sliderA.value = trackPositionA;
                        const minutes = Math.floor(trackPositionA / 60);
                        const seconds = Math.floor(trackPositionA % 60);
                        valueA.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }

            // Update Track B slider
            if (isPlayingB && trackStartTimeB !== undefined) {
                const currentTimeB = ctx.currentTime - trackStartTimeB;
                const durationB = audioBufferB ? audioBufferB.duration : 0;

                if (durationB > 0) {
                    trackPositionB = currentTimeB % durationB; // Handle looping
                    const sliderB = document.getElementById('timeSliderB');
                    const valueB = document.getElementById('timeValueB');

                    if (sliderB && !timeSliderBDragging) { // Don't update if user is dragging
                        sliderB.value = trackPositionB;
                        const minutes = Math.floor(trackPositionB / 60);
                        const seconds = Math.floor(trackPositionB % 60);
                        valueB.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }
        }

        // Robust real-time audio processor with proper overlap-add
        function setupRealtimeAudio() {
            if (!ctx || (!audioBufferA && !audioBufferB)) return;

            try {
                // Create script processor for real-time effects - STEREO
                scriptProcessor = ctx.createScriptProcessor(4096, 2, 2);
                analyser = ctx.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.3;

                // FFT processing setup
                const fftSize = 2048;
                const hopSize = fftSize / 4; // 75% overlap
                const windowFunc = createOptimalHannWindow(fftSize, hopSize);

                // Delay lines for overlap-add - separate for each channel
                let inputDelayChannels = [new Float32Array(fftSize), new Float32Array(fftSize)];
                let outputDelayChannels = [new Float32Array(fftSize), new Float32Array(fftSize)];
                let frameCounterChannels = [0, 0];

                // Initialize processor parameters with all current settings
                scriptProcessor.params = {
                    ...realtimeParams,
                    antiAliasingMode: realtimeParams.antiAliasingMode,
                    frequencyMapping: realtimeParams.frequencyMapping
                };
                // Set global reference to processor
                realtimeProcessor = scriptProcessor;

                scriptProcessor.onaudioprocess = function (audioProcessingEvent) {
                    // Process both channels
                    for (let channel = 0; channel < 2; channel++) {
                        const input = audioProcessingEvent.inputBuffer.getChannelData(Math.min(channel, audioProcessingEvent.inputBuffer.numberOfChannels - 1));
                        const output = audioProcessingEvent.outputBuffer.getChannelData(channel);

                        // Get current parameters from the processor object
                        let amount = scriptProcessor.params.amount;
                        const mixValue = scriptProcessor.params.mix;
                        const gain = scriptProcessor.params.gain;

                        // Apply modulation to amount if enabled
                        if (scriptProcessor.params.modEnabled) {
                            const minAmount = scriptProcessor.params.modMinAmount || 0.0;
                            const maxAmount = scriptProcessor.params.modMaxAmount || amount;
                            const currentTime = ctx.currentTime;
                            const startTime = scriptProcessor.params.modStartTime;
                            const modPeriod = scriptProcessor.params.modPeriod;

                            // Calculate elapsed time and position in modulation cycle
                            const elapsedTime = currentTime - startTime;
                            const normalizedPosition = (elapsedTime % modPeriod) / modPeriod;

                            // Sinusoidal modulation between min and max bounds
                            const modulationFactor = Math.sin(normalizedPosition * 2 * Math.PI);
                            amount = minAmount + (maxAmount - minAmount) * (modulationFactor * 0.5 + 0.5);
                        }

                        for (let n = 0; n < input.length; n++) {
                            // Shift delay lines for this channel
                            const inputDelay = inputDelayChannels[channel];
                            const outputDelay = outputDelayChannels[channel];

                            for (let i = 0; i < fftSize - 1; i++) {
                                inputDelay[i] = inputDelay[i + 1];
                                outputDelay[i] = outputDelay[i + 1];
                            }
                            inputDelay[fftSize - 1] = input[n];
                            outputDelay[fftSize - 1] = 0;

                            // Process frame every hopSize samples for this channel
                            if (frameCounterChannels[channel] % hopSize === 0) {
                                // Prepare FFT buffers
                                const real = new Float32Array(fftSize);
                                const imag = new Float32Array(fftSize);

                                // Apply window to input
                                for (let i = 0; i < fftSize; i++) {
                                    real[i] = inputDelay[i] * windowFunc[i];
                                    imag[i] = 0;
                                }

                                // Forward FFT
                                fft(real, imag);

                                // Apply frequency transformation with channel-specific parameters
                                const channelParams = { ...scriptProcessor.params, stereoChannel: channel };
                                applyComplexFunction(real, imag, fftSize, ctx.sampleRate, selectedFunction, amount, channelParams);

                                // Inverse FFT
                                ifft(real, imag);

                                // Apply synthesis window and overlap-add
                                for (let i = 0; i < fftSize; i++) {
                                    outputDelay[i] += real[i] * windowFunc[i];
                                }
                            }

                            // Output with proper mix
                            const wet = outputDelay[0] * gain;
                            output[n] = input[n] * (1 - mixValue) + wet * mixValue;

                            frameCounterChannels[channel]++;
                        }
                    } // Close channel loop
                };

                return scriptProcessor;

            } catch (error) {
                console.error('Error setting up real-time audio:', error);
                return null;
            }
        }

        function createOptimalHannWindow(size, hopSize) {
            const window = new Float32Array(size);

            // Create basic Hann window
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Calculate the optimal normalization for constant amplitude with overlap-add
            // For Hann window with 75% overlap (hopSize = size/4), we need to compensate
            // for the overlapping window energy

            // Test the overlap sum at the center of the window
            let overlapSum = 0;
            const center = Math.floor(size / 2);

            // Sum all overlapping windows at the center point
            for (let offset = -size; offset <= size; offset += hopSize) {
                const index = center + offset;
                if (index >= 0 && index < size) {
                    overlapSum += window[index] * window[index];
                }
            }

            // Normalize so that overlapping windows sum to constant amplitude
            const normFactor = 1.0 / Math.sqrt(overlapSum);
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        // Hann window creation for analysis
        function createHannWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Normalize for overlap-add with 75% overlap (hopSize = size/4)
            // This ensures constant amplitude reconstruction
            let sum = 0;
            const hopSize = size / 4;
            for (let i = 0; i < size; i++) {
                let overlap = 0;
                for (let j = -3; j <= 3; j++) { // Check overlapping windows
                    const pos = i + j * hopSize;
                    if (pos >= 0 && pos < size) {
                        overlap += window[pos] * window[pos];
                    }
                }
                if (overlap > sum) sum = overlap;
            }

            // Apply normalization factor
            const normFactor = 1.0 / Math.sqrt(sum);
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        function createSimpleHannWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Simple normalization for 75% overlap
            // For Hann window with 75% overlap, the normalization factor is approximately 2/3
            const normFactor = 2.0 / 3.0;
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        // Update real-time amount display with modulated value and slider animation
        function updateModulatedDisplay() {
            if (!isPlaying || !realtimeProcessor || !realtimeProcessor.params.modEnabled) {
                // If modulation is off, restore original amount display and remove animation
                if (realtimeProcessor && realtimeProcessor.params) {
                    const powerValue = document.getElementById('powerValue');
                    const powerSlider = document.getElementById('powerSlider');
                    if (powerValue) {
                        powerValue.textContent = realtimeProcessor.params.amount.toFixed(3);
                    }
                    if (powerSlider) {
                        powerSlider.classList.remove('animated');
                    }
                }
                return;
            }

            const powerValue = document.getElementById('powerValue');
            const powerSlider = document.getElementById('powerSlider');
            if (!powerValue || !powerSlider) return;

            const amount = realtimeProcessor.params.amount;
            const minAmount = realtimeProcessor.params.modMinAmount || 0.0;
            const maxAmount = realtimeProcessor.params.modMaxAmount || amount;
            const currentTime = ctx.currentTime;
            const startTime = realtimeProcessor.params.modStartTime;
            const modPeriod = realtimeProcessor.params.modPeriod;

            // Calculate elapsed time and position in modulation cycle
            const elapsedTime = currentTime - startTime;
            const normalizedPosition = (elapsedTime % modPeriod) / modPeriod;

            // Sinusoidal modulation between min and max bounds
            const modulationFactor = Math.sin(normalizedPosition * 2 * Math.PI);
            const modulatedAmount = minAmount + (maxAmount - minAmount) * (modulationFactor * 0.5 + 0.5);

            // Update display with the current modulated value and bounds
            powerValue.textContent = `${modulatedAmount.toFixed(3)} (${minAmount.toFixed(3)}→${maxAmount.toFixed(3)})`;

            // Add animation class to slider
            powerSlider.classList.add('animated');

            // Move the slider thumb to match the modulated value
            const sliderMin = parseFloat(powerSlider.min);
            const sliderMax = parseFloat(powerSlider.max);
            const clampedValue = Math.max(sliderMin, Math.min(sliderMax, modulatedAmount));
            powerSlider.value = clampedValue;

            // Set CSS custom property for smooth animation
            const percentage = ((clampedValue - sliderMin) / (sliderMax - sliderMin)) * 100;
            powerSlider.style.setProperty('--modulation-position', `${percentage}%`);

            // Update pulse indicator position to move between red and green handles
            const pulseIndicator = document.querySelector('.dual-slider-container .pulse-indicator');
            if (pulseIndicator) {
                // Calculate position based on modulation factor (-1 to 1, but we want 0 to 1)
                const normalizedFactor = (modulationFactor + 1) / 2; // Convert -1→1 to 0→1

                // Get slider values for positioning
                const minSliderValue = parseFloat(document.getElementById('modMinSlider').value);
                const maxSliderValue = parseFloat(document.getElementById('modMaxSlider').value);

                // Calculate position as percentage between min and max handles
                const minPos = ((minSliderValue - sliderMin) / (sliderMax - sliderMin)) * 100;
                const maxPos = ((maxSliderValue - sliderMin) / (sliderMax - sliderMin)) * 100;
                const currentPos = minPos + (maxPos - minPos) * normalizedFactor;

                pulseIndicator.style.left = `${currentPos}%`;
            }

            // Update the internal processor amount in real-time
            if (realtimeProcessor.params) {
                realtimeProcessor.params.amount = modulatedAmount;
            }

            // Update crossfader modulation sync if enabled
            if (typeof updateCrossfaderModulation === 'function') {
                updateCrossfaderModulation();
            }

            // Request next animation frame
            requestAnimationFrame(updateModulatedDisplay);
        }

        // Setup real-time parameter updates
        function setupRealtimeParameterUpdates() {
            // This function can be empty for bypass mode
            // In full mode, it would update FFT processing parameters in real-time
        }

        // Create output filters
        function createOutputFilters() {
            if (!ctx) return;

            try {
                // Create low pass filter
                lowPassFilter = ctx.createBiquadFilter();
                lowPassFilter.type = 'lowpass';
                lowPassFilter.frequency.setValueAtTime(realtimeParams.lowPassFreq, ctx.currentTime);
                lowPassFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Create high pass filter
                highPassFilter = ctx.createBiquadFilter();
                highPassFilter.type = 'highpass';
                highPassFilter.frequency.setValueAtTime(realtimeParams.highPassFreq, ctx.currentTime);
                highPassFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Chain them together: highpass -> lowpass
                highPassFilter.connect(lowPassFilter);

                console.log('Output filters created');
            } catch (error) {
                console.error('Error creating output filters:', error);
            }
        }

        // Setup filter slider handlers
        function setupFilterControls() {
            // Output Filters (High/Low Pass)
            setupDualSlider('outputFilter', 1, 20000,
                (min, max) => {
                    realtimeParams.highPassFreq = min;
                    realtimeParams.lowPassFreq = max;

                    if (highPassFilter) {
                        highPassFilter.frequency.setTargetAtTime(min, ctx.currentTime, 0.1);
                    }
                    if (lowPassFilter) {
                        lowPassFilter.frequency.setTargetAtTime(max, ctx.currentTime, 0.1);
                    }
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );

            // Delay Filter Range
            setupDualSlider('delayFilter', 20, 20000,
                (min, max) => {
                    realtimeParams.delayLowCut = min;
                    realtimeParams.delayHighCut = max;

                    // Ensure delay filter nodes exist
                    if (!delayLowCutFilter || !delayHighCutFilter) {
                        if (ctx && delayNode) {
                            // Create filters if not already present
                            delayLowCutFilter = ctx.createBiquadFilter();
                            delayLowCutFilter.type = 'highpass';
                            delayLowCutFilter.frequency.value = min;
                            delayLowCutFilter.Q.value = 0.7;

                            delayHighCutFilter = ctx.createBiquadFilter();
                            delayHighCutFilter.type = 'lowpass';
                            delayHighCutFilter.frequency.value = max;
                            delayHighCutFilter.Q.value = 0.7;

                            // Insert filters into delay chain: delay -> lowcut -> highcut -> wetGain
                            if (delayWetGainNode) {
                                // Disconnect existing delay -> wetGain connection
                                delayNode.disconnect(delayWetGainNode);

                                // Connect new chain: delay -> lowcut -> highcut -> wetGain
                                delayNode.connect(delayLowCutFilter);
                                delayLowCutFilter.connect(delayHighCutFilter);
                                delayHighCutFilter.connect(delayWetGainNode);
                            }
                        }
                    } else {
                        // Update filter frequencies
                        delayLowCutFilter.frequency.setTargetAtTime(min, ctx.currentTime, 0.01);
                        delayHighCutFilter.frequency.setTargetAtTime(max, ctx.currentTime, 0.01);
                    }
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );

            // Reverb Filter Range  
            setupDualSlider('reverbFilter', 20, 20000,
                (min, max) => {
                    realtimeParams.reverbLowCut = min;
                    realtimeParams.reverbHighCut = max;

                    // Ensure reverb filter nodes exist
                    if (!reverbLowCutFilter || !reverbHighCutFilter) {
                        if (ctx && reverbNode) {
                            // Create filters if not already present
                            reverbLowCutFilter = ctx.createBiquadFilter();
                            reverbLowCutFilter.type = 'highpass';
                            reverbLowCutFilter.frequency.value = min;
                            reverbLowCutFilter.Q.value = 0.7;

                            reverbHighCutFilter = ctx.createBiquadFilter();
                            reverbHighCutFilter.type = 'lowpass';
                            reverbHighCutFilter.frequency.value = max;
                            reverbHighCutFilter.Q.value = 0.7;

                            // Insert filters into reverb chain: input -> lowcut -> highcut -> convolver
                            if (reverbWetGainNode) {
                                // Disconnect existing reverb -> wetGain connection
                                reverbNode.disconnect(reverbWetGainNode);

                                // Connect new chain: input -> lowcut -> highcut -> reverb -> wetGain
                                reverbLowCutFilter.connect(reverbHighCutFilter);
                                reverbHighCutFilter.connect(reverbNode);
                                reverbNode.connect(reverbWetGainNode);
                            }
                        }
                    } else {
                        // Update filter frequencies
                        reverbLowCutFilter.frequency.setTargetAtTime(min, ctx.currentTime, 0.01);
                        reverbHighCutFilter.frequency.setTargetAtTime(max, ctx.currentTime, 0.01);
                    }
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );
        }

        function formatFreq(freq) {
            if (freq >= 1000) {
                return `${(freq / 1000).toFixed(freq >= 10000 ? 0 : 1)}kHz`;
            } else {
                return `${freq}Hz`;
            }
        }

        function setupDualSlider(baseName, minVal, maxVal, onUpdate, formatDisplay) {
            const minSlider = document.getElementById(baseName + 'MinSlider');
            const maxSlider = document.getElementById(baseName + 'MaxSlider');
            const valueDisplay = document.getElementById(baseName + 'Value');

            if (!minSlider || !maxSlider) return;

            let currentMin = minVal;
            let currentMax = maxVal;

            function updateDisplay() {
                const displayText = formatDisplay(currentMin, currentMax);
                if (valueDisplay) valueDisplay.textContent = displayText;
                onUpdate(currentMin, currentMax);
            }

            function handleSliderChange() {
                const minValue = parseInt(minSlider.value);
                const maxValue = parseInt(maxSlider.value);

                // Prevent handles from crossing - if they try to cross, snap them together
                if (minValue >= maxValue) {
                    currentMin = maxValue;
                    currentMax = maxValue;
                    minSlider.value = currentMin;
                    maxSlider.value = currentMax;
                } else {
                    currentMin = minValue;
                    currentMax = maxValue;
                }

                updateDisplay();
            }

            minSlider.addEventListener('input', handleSliderChange);
            maxSlider.addEventListener('input', handleSliderChange);

            // Initialize display
            updateDisplay();
        }

        // Event listeners and initialization
        document.addEventListener('DOMContentLoaded', function () {
            // Optimal ranges for each function based on frequency analysis
            function getOptimalRange(functionName) {
                switch (functionName) {
                    // Basic Operations - Fine-tuned for frequency effects
                    case 'power': return { min: 0.1, max: 4.0, optimal: 1.5 };
                    case 'sqrt': return { min: 0.2, max: 3.0, optimal: 1.0 };
                    case 'cbrt': return { min: 0.3, max: 4.0, optimal: 1.5 };
                    case 'nroot': return { min: 0.2, max: 6.0, optimal: 2.0 };
                    case 'square': return { min: 0.1, max: 1.8, optimal: 1.0 };
                    case 'cube': return { min: 0.1, max: 1.4, optimal: 0.8 };
                    case 'inverse': return { min: 0.2, max: 5.0, optimal: 1.5 };

                    // Logarithmic & Exponential - Adjusted for audio frequency range
                    case 'log': return { min: 0.1, max: 30.0, optimal: 2.0 };
                    case 'log10': return { min: 0.5, max: 15.0, optimal: 5.0 };
                    case 'log2': return { min: 0.3, max: 30.0, optimal: 4.0 };
                    case 'exp': return { min: 0.01, max: 2, optimal: 1.0 };
                    case 'exp2': return { min: 0.05, max: 2.0, optimal: 0.25 };
                    case 'exp10': return { min: 0.005, max: 0.5, optimal: 0.2 };

                    // Trigonometric - Optimized for harmonic effects
                    case 'sin': return { min: 0.5, max: 25.0, optimal: 8.0 };
                    case 'cos': return { min: 0.5, max: 25.0, optimal: 8.0 };
                    case 'tan': return { min: 0.2, max: 8.0, optimal: 2.0 };
                    case 'asin': return { min: 0.1, max: 1.8, optimal: 0.8 };
                    case 'acos': return { min: 0.1, max: 1.8, optimal: 0.8 };
                    case 'atan': return { min: 0.5, max: 50.0, optimal: 15.0 };

                    // Hyperbolic - Tuned for dynamic range
                    case 'sinh': return { min: 0.05, max: 1.8, optimal: 0.6 };
                    case 'cosh': return { min: 0.05, max: 1.8, optimal: 0.6 };
                    case 'tanh': return { min: 0.01, max: 3.0, optimal: 1.0 };
                    case 'asinh': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'acosh': return { min: 0.2, max: 4.0, optimal: 1.5 };
                    case 'atanh': return { min: 0.1, max: 1.5, optimal: 0.8 };

                    // Special Functions - Optimized for unique effects
                    case 'gamma': return { min: 0.2, max: 4.0, optimal: 1.5 };
                    case 'bessel_j0': return { min: 1.0, max: 60.0, optimal: 20.0 };
                    case 'bessel_y0': return { min: 0.8, max: 35.0, optimal: 12.0 };
                    case 'erf': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'airy_ai': return { min: 0.5, max: 15.0, optimal: 6.0 };

                    // Fractal Functions - Balanced for audio stability
                    case 'mandelbrot': return { min: 0.01, max: 10.0, optimal: 5.0 };
                    case 'julia': return { min: 0.1, max: 2.5, optimal: 0.8 };
                    case 'burning_ship': return { min: 0.1, max: 1.8, optimal: 0.6 };
                    case 'newton_raphson': return { min: 0.1, max: 1.5, optimal: 0.5 };
                    case 'logistic_map': return { min: 3, max: 20, optimal: 5 };

                    // Geometric Transformations
                    case 'mobius': return { min: -16000, max: 16000, optimal: 0 };
                    case 'joukowsky': return { min: 0.2, max: 4.0, optimal: 1.5 };

                    // Spiral Transformations - Enhanced for motion effects
                    case 'spiral': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'fibonacci_spiral': return { min: 0.2, max: 6.0, optimal: 2.0 };

                    // Wave Functions - Optimized for interference patterns
                    case 'wave': return { min: 0.5, max: 18.0, optimal: 6.0 };
                    case 'ripple': return { min: 1.0, max: 35.0, optimal: 12.0 };
                    case 'sinc_function': return { min: 1.0, max: 80.0, optimal: 25.0 };
                    case 'chirp': return { min: 0.2, max: 12.0, optimal: 4.0 };

                    // Physics Equations - Tuned for realistic effects
                    case 'schrodinger': return { min: 0.1, max: 5.0, optimal: 1.5 };
                    case 'heisenberg': return { min: 0.3, max: 10.0, optimal: 3.0 };
                    case 'einstein_mass_energy': return { min: 0.1, max: 2.0, optimal: 0.8 };
                    case 'planck_radiation': return { min: 0.2, max: 8.0, optimal: 2.5 };
                    case 'maxwell_boltzmann': return { min: 0.5, max: 12.0, optimal: 4.0 };
                    case 'wave_equation': return { min: 0.3, max: 15.0, optimal: 5.0 };
                    case 'lorentz_factor': return { min: 0.1, max: 3.0, optimal: 1.0 };
                    case 'schwarzschild': return { min: 0.1, max: 4.0, optimal: 1.2 };
                    case 'hydrogen_orbital': return { min: 0.001, max: 2.0, optimal: 2.0 };

                    // Default for unspecified functions
                    default: return { min: 0.1, max: 20.0, optimal: 1.0 };
                }
            }
            // Initialize function grid
            // Function categories mapping
            const functionCategories = {
                'basic': ['power', 'sqrt', 'cbrt', 'nroot', 'square', 'cube', 'quartic', 'quintic', 'inverse'],
                'logarithmic': ['log', 'log10', 'log2', 'exp', 'exp2', 'exp10'],
                'trigonometric': ['sin', 'cos', 'tan', 'csc', 'sec', 'cot', 'asin', 'acos', 'atan', 'atan2'],
                'hyperbolic': ['sinh', 'cosh', 'tanh', 'csch', 'sech', 'coth', 'asinh', 'acosh', 'atanh'],
                'complex': ['complex_magnitude', 'complex_phase', 'conjugate', 'reciprocal', 'abs_square'],
                'physics': ['schrodinger', 'heisenberg', 'einstein_mass_energy', 'planck_radiation', 'maxwell_boltzmann', 'wave_equation', 'heat_equation', 'lorentz_factor', 'schwarzschild', 'compton_scattering'],
                'special': ['gamma', 'factorial', 'zeta', 'eta', 'bessel_j0', 'bessel_y0', 'bessel_i0', 'bessel_k0', 'airy_ai', 'airy_bi', 'erf', 'erfc'],
                'geometric': ['mobius', 'joukowsky', 'schwarz_christoffel', 'cayley'],
                'spirals': ['spiral', 'fibonacci_spiral', 'archimedean_spiral', 'fermat_spiral', 'hyperbolic_spiral', 'ulam_spiral'],
                'fractals': ['mandelbrot', 'julia', 'burning_ship', 'tricorn', 'multibrot', 'newton_raphson', 'nova', 'phoenix', 'magnet', 'lambda', 'spider', 'henon_map', 'lorenz_attractor', 'logistic_map', 'tent_map'],
                'wave': ['wave', 'ripple', 'standing_wave', 'beat_frequency', 'doppler_effect', 'gaussian_wave', 'sinc_function', 'chirp', 'morlet_wavelet', 'mexican_hat'],
                'patterns': ['dirac_delta', 'heaviside_step', 'sawtooth', 'square_wave', 'triangle_wave', 'pulse_train'],
                'quantum': ['quantum_harmonic', 'hydrogen_orbital', 'tunneling_effect', 'klein_gordon', 'dirac_equation', 'feynman_diagram']
            };

            function initFunctionSelect() {
                const categorySelect = document.getElementById('functionCategorySelect');
                const functionSelect = document.getElementById('functionSelect');

                // Function to populate function dropdown based on category
                function populateFunctions(category) {
                    functionSelect.innerHTML = '';

                    if (functionCategories[category]) {
                        functionCategories[category].forEach(funcKey => {
                            if (complexFunctions[funcKey]) {
                                const option = document.createElement('option');
                                option.value = funcKey;
                                option.textContent = `${complexFunctions[funcKey].name} - ${complexFunctions[funcKey].desc}`;
                                option.title = complexFunctions[funcKey].desc;
                                functionSelect.appendChild(option);
                            }
                        });
                    }

                    // Set first option as selected if no current selection
                    if (functionSelect.options.length > 0 && !functionSelect.value) {
                        functionSelect.value = functionSelect.options[0].value;
                        selectedFunction = functionSelect.value;
                    }
                }

                // Initialize with basic category
                populateFunctions('basic');
                categorySelect.value = 'basic';

                // Set initial function if it exists
                if (selectedFunction && functionSelect.querySelector(`option[value="${selectedFunction}"]`)) {
                    functionSelect.value = selectedFunction;
                } else {
                    selectedFunction = functionSelect.value;
                }

                // Category change event
                categorySelect.addEventListener('change', function () {
                    populateFunctions(this.value);
                    selectedFunction = functionSelect.value;
                    updateSliderRange(selectedFunction);
                    showStatus(`Category changed. Function set to: ${complexFunctions[selectedFunction].name}`, 'info');
                });

                // Function change event
                functionSelect.addEventListener('change', function () {
                    selectedFunction = this.value;
                    updateSliderRange(selectedFunction);
                    showStatus(`Function changed to: ${complexFunctions[selectedFunction].name}`, 'info');
                });
            }

            // Update slider range when function changes
            function updateSliderRange(functionName) {
                const range = getOptimalRange(functionName);
                const powerSlider = document.getElementById('powerSlider');
                const modMinSlider = document.getElementById('modMinSlider');
                const modMaxSlider = document.getElementById('modMaxSlider');

                if (powerSlider) {
                    powerSlider.min = range.min;
                    powerSlider.max = range.max;
                    powerSlider.value = range.optimal;

                    // Update display
                    document.getElementById('powerValue').textContent = range.optimal.toFixed(3);
                    realtimeParams.amount = range.optimal;
                    if (realtimeProcessor && realtimeProcessor.params) {
                        realtimeProcessor.params.amount = range.optimal;
                    }
                }

                if (modMinSlider && modMaxSlider) {
                    modMinSlider.min = range.min;
                    modMinSlider.max = range.max;
                    modMaxSlider.min = range.min;
                    modMaxSlider.max = range.max;

                    // Set reasonable modulation range
                    modMinSlider.value = range.min;
                    modMaxSlider.value = range.optimal;
                }
            }

            function initSliders() {
                const sliders = {
                    powerSlider: (val) => {
                        document.getElementById('powerValue').textContent = parseFloat(val).toFixed(3);
                        realtimeParams.amount = parseFloat(val);
                        if (realtimeProcessor && realtimeProcessor.params) {
                            realtimeProcessor.params.amount = parseFloat(val);
                        }
                    },
                    modPeriodSlider: (val) => {
                        const sliderValue = parseFloat(val);

                        if (sliderValue === 0) {
                            // Modulation off
                            document.getElementById('modStatus').textContent = 'Off';
                            document.getElementById('modPeriodValue').textContent = 'Off';
                            realtimeParams.modEnabled = false;
                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.modEnabled = false;
                            }

                            // Reset amount display to show normal value
                            if (realtimeProcessor && realtimeProcessor.params) {
                                const powerValue = document.getElementById('powerValue');
                                if (powerValue) {
                                    powerValue.textContent = realtimeProcessor.params.amount.toFixed(3);
                                }
                            }
                        } else {
                            // Map slider value to minutes: 0.01-1.0 -> 0.1-1min, 1.0-2.0 -> 1-10min
                            let minutes;
                            if (sliderValue <= 1.0) {
                                // First half: 0.01 to 1.0 maps to 0.1 to 1 minute
                                minutes = 0.1 + (sliderValue * 0.9);
                            } else {
                                // Second half: 1.0 to 2.0 maps to 1 to 10 minutes  
                                minutes = 1 + ((sliderValue - 1.0) * 9);
                            }

                            // Convert minutes to seconds
                            const period = minutes * 60;

                            // Format display 
                            let displayValue;
                            if (minutes < 1) {
                                displayValue = `${(minutes * 60).toFixed(0)}s`;
                            } else {
                                displayValue = `${minutes.toFixed(1)}min`;
                            }

                            document.getElementById('modStatus').textContent = 'On';
                            document.getElementById('modPeriodValue').textContent = displayValue;

                            realtimeParams.modEnabled = true;
                            realtimeParams.modPeriod = period;
                            realtimeParams.modStartTime = ctx ? ctx.currentTime : 0;

                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.modEnabled = true;
                                realtimeProcessor.params.modPeriod = period;
                                realtimeProcessor.params.modStartTime = ctx ? ctx.currentTime : 0;
                            }

                            // Start modulation display updates if playing
                            if (isPlaying) {
                                requestAnimationFrame(updateModulatedDisplay);
                            }
                        }
                    },
                    mixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('mixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxTransformMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.mix = mixValue;
                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.mix = mixValue;
                            }
                        }
                    },
                    gainSlider: (val) => {
                        const gainDb = parseFloat(val);
                        let displayText;
                        if (gainDb <= -60) {
                            displayText = '-∞dB';
                            realtimeParams.gain = 0;
                        } else {
                            displayText = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                            realtimeParams.gain = Math.pow(10, gainDb / 20);
                        }
                        document.getElementById('gainValue').textContent = displayText;

                        // Update FadeSync maximum if FadeSync is enabled
                        if (realtimeParams.fadeSyncEnabled) {
                            realtimeParams.fadeSyncMaxFunctionGainDb = gainDb;
                            // Recalculate the faded gain based on current crossfader position
                            updateFadeSyncMix();
                        } else {
                            // Normal behavior when FadeSync is off
                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.gain = realtimeParams.gain;
                            }
                        }
                    },

                    // Delay controls
                    delayTimeSlider: (val) => {
                        const timeMs = parseInt(val);
                        const timeSec = timeMs / 1000;
                        document.getElementById('delayTimeValue').textContent = timeMs === 0 ? '0.0s' : `${timeMs}ms`;
                        realtimeParams.delayTime = timeSec;
                        if (delayNode) {
                            delayNode.delayTime.setTargetAtTime(timeSec, ctx.currentTime, 0.01);
                        }
                    },
                    delayFeedbackSlider: (val) => {
                        const feedback = parseInt(val) / 100;
                        document.getElementById('delayFeedbackValue').textContent = `${val}%`;
                        realtimeParams.delayFeedback = feedback;
                        if (delayFeedbackNode) {
                            delayFeedbackNode.gain.setTargetAtTime(feedback, ctx.currentTime, 0.01);
                        }
                    },
                    delayMixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('delayMixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxDelayMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.delayMix = mixValue;
                            if (delayWetGainNode && delayDryGainNode) {
                                delayWetGainNode.gain.setTargetAtTime(mixValue, ctx.currentTime, 0.01);
                                delayDryGainNode.gain.setTargetAtTime(1.0 - mixValue, ctx.currentTime, 0.01);
                            }
                        }
                    },

                    // Reverb controls
                    reverbRoomSizeSlider: (val) => {
                        const roomSize = parseInt(val) / 100;
                        document.getElementById('reverbRoomSizeValue').textContent = `${val}%`;
                        realtimeParams.reverbRoomSize = roomSize;
                        // Recreate reverb impulse response with new room size
                        recreateReverbImpulse();
                    },
                    reverbDecaySlider: (val) => {
                        const decay = parseFloat(val);
                        document.getElementById('reverbDecayValue').textContent = `${decay.toFixed(1)}s`;
                        realtimeParams.reverbDecay = decay;
                        // Recreate reverb impulse response with new decay time
                        recreateReverbImpulse();
                    },
                    reverbMixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('reverbMixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxReverbMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.reverbMix = mixValue;
                            if (reverbWetGainNode && reverbDryGainNode) {
                                reverbWetGainNode.gain.setTargetAtTime(mixValue, ctx.currentTime, 0.01);
                                reverbDryGainNode.gain.setTargetAtTime(1.0 - mixValue, ctx.currentTime, 0.01);
                            }
                        }
                    },

                    // Output gain control (-∞ to +18dB)
                    outputGainSlider: (val) => {
                        const gainDb = parseFloat(val);
                        let displayText;
                        if (gainDb <= -60) {
                            displayText = '-∞dB';
                            realtimeParams.outputGainDb = -Infinity;
                            realtimeParams.finalOutputGain = 0;
                        } else {
                            displayText = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                            realtimeParams.outputGainDb = gainDb;
                            realtimeParams.finalOutputGain = Math.pow(10, gainDb / 20);
                        }
                        document.getElementById('outputGainValue').textContent = displayText;

                        if (finalOutputGainNode) {
                            finalOutputGainNode.gain.setTargetAtTime(realtimeParams.finalOutputGain, ctx.currentTime, 0.01);
                        }
                    },

                    // Delay filter controls are now handled by dual-handle sliders in setupFilterControls

                    // Reverb filter controls are now handled by dual-handle sliders in setupFilterControls
                };

                Object.entries(sliders).forEach(([id, callback]) => {
                    const slider = document.getElementById(id);
                    if (slider) {
                        slider.addEventListener('input', (e) => callback(e.target.value));
                        // Initialize display without triggering processor updates
                        const currentValue = slider.value;
                        if (id === 'powerSlider') {
                            document.getElementById('powerValue').textContent = parseFloat(currentValue).toFixed(3);
                            realtimeParams.amount = parseFloat(currentValue);
                        } else if (id === 'modPeriodSlider') {
                            // Initialize modulation slider display with new 0-2 scale
                            const sliderValue = parseFloat(currentValue);
                            if (sliderValue === 0) {
                                document.getElementById('modStatus').textContent = 'Off';
                                document.getElementById('modPeriodValue').textContent = 'Off';
                                realtimeParams.modEnabled = false;
                            } else {
                                // Map slider value to minutes: 0.01-1.0 -> 0.1-1min, 1.0-2.0 -> 1-10min
                                let minutes;
                                if (sliderValue <= 1.0) {
                                    minutes = 0.1 + (sliderValue * 0.9);
                                } else {
                                    minutes = 1 + ((sliderValue - 1.0) * 9);
                                }

                                const period = minutes * 60;
                                let displayValue;
                                if (minutes < 1) {
                                    displayValue = `${(minutes * 60).toFixed(0)}s`;
                                } else {
                                    displayValue = `${minutes.toFixed(1)}min`;
                                }

                                document.getElementById('modStatus').textContent = 'On';
                                document.getElementById('modPeriodValue').textContent = displayValue;
                                realtimeParams.modEnabled = true;
                                realtimeParams.modPeriod = period;
                            }
                        } else if (id === 'mixSlider') {
                            document.getElementById('mixValue').textContent = `${currentValue}%`;
                            realtimeParams.mix = parseInt(currentValue) / 100;
                        } else if (id === 'gainSlider') {
                            const gainDb = parseFloat(currentValue);
                            if (gainDb <= -60) {
                                document.getElementById('gainValue').textContent = '-∞dB';
                                realtimeParams.gain = 0;
                            } else {
                                document.getElementById('gainValue').textContent = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                                realtimeParams.gain = Math.pow(10, gainDb / 20);
                            }
                        } else if (id === 'delayTimeSlider') {
                            const timeMs = parseInt(currentValue);
                            document.getElementById('delayTimeValue').textContent = timeMs === 0 ? '0.0s' : `${timeMs}ms`;
                            realtimeParams.delayTime = timeMs / 1000;
                        } else if (id === 'delayFeedbackSlider') {
                            document.getElementById('delayFeedbackValue').textContent = `${currentValue}%`;
                            realtimeParams.delayFeedback = parseInt(currentValue) / 100;
                        } else if (id === 'delayMixSlider') {
                            document.getElementById('delayMixValue').textContent = `${currentValue}%`;
                            realtimeParams.delayMix = parseInt(currentValue) / 100;
                        } else if (id === 'reverbRoomSizeSlider') {
                            document.getElementById('reverbRoomSizeValue').textContent = `${currentValue}%`;
                            realtimeParams.reverbRoomSize = parseInt(currentValue) / 100;
                        } else if (id === 'reverbDecaySlider') {
                            document.getElementById('reverbDecayValue').textContent = `${parseFloat(currentValue).toFixed(1)}s`;
                            realtimeParams.reverbDecay = parseFloat(currentValue);
                        } else if (id === 'reverbMixSlider') {
                            document.getElementById('reverbMixValue').textContent = `${currentValue}%`;
                            realtimeParams.reverbMix = parseInt(currentValue) / 100;
                        } else if (id === 'outputGainSlider') {
                            const gainDb = parseFloat(currentValue);
                            if (gainDb <= -60) {
                                document.getElementById('outputGainValue').textContent = '-∞dB';
                                realtimeParams.outputGainDb = -Infinity;
                                realtimeParams.finalOutputGain = 0;
                            } else {
                                document.getElementById('outputGainValue').textContent = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                                realtimeParams.outputGainDb = gainDb;
                                realtimeParams.finalOutputGain = Math.pow(10, gainDb / 20);
                            }
                        }
                        // Delay and reverb filter initialization is now handled by setupFilterControls
                    }
                });

                // Initialize dual-handle modulation bounds sliders
                const modMinSlider = document.getElementById('modMinSlider');
                const modMaxSlider = document.getElementById('modMaxSlider');
                const modRangeValue = document.getElementById('modRangeValue');
                const dualSliderContainer = document.querySelector('.dual-slider-container');

                if (modMinSlider && modMaxSlider && modRangeValue) {
                    function updateModulationBounds() {
                        const minVal = parseFloat(modMinSlider.value);
                        const maxVal = parseFloat(modMaxSlider.value);

                        // Ensure min is always less than max
                        if (minVal >= maxVal) {
                            if (this === modMinSlider) {
                                modMaxSlider.value = (minVal + 0.001).toFixed(3);
                            } else {
                                modMinSlider.value = (maxVal - 0.001).toFixed(3);
                            }
                        }

                        const finalMin = parseFloat(modMinSlider.value);
                        const finalMax = parseFloat(modMaxSlider.value);

                        // Update display
                        modRangeValue.textContent = `${finalMin.toFixed(3)} → ${finalMax.toFixed(3)}`;

                        // Update parameters
                        realtimeParams.modMinAmount = finalMin;
                        realtimeParams.modMaxAmount = finalMax;
                        if (realtimeProcessor && realtimeProcessor.params) {
                            realtimeProcessor.params.modMinAmount = finalMin;
                            realtimeProcessor.params.modMaxAmount = finalMax;
                        }
                    }

                    modMinSlider.addEventListener('input', updateModulationBounds);
                    modMaxSlider.addEventListener('input', updateModulationBounds);

                    // Initialize display
                    updateModulationBounds();

                    // Toggle visibility based on modulation state
                    function updateModulationVisibility() {
                        if (realtimeParams.modEnabled) {
                            dualSliderContainer.classList.remove('modulation-disabled');
                        } else {
                            dualSliderContainer.classList.add('modulation-disabled');
                        }
                    }

                    // Initial visibility update
                    updateModulationVisibility();

                    // Update visibility when modulation period changes
                    const modPeriodSlider = document.getElementById('modPeriodSlider');
                    if (modPeriodSlider) {
                        modPeriodSlider.addEventListener('input', () => {
                            setTimeout(updateModulationVisibility, 0); // Update after the main callback
                        });
                    }
                }
            }

            // Enhanced dual-track file input with drag-and-drop support
            function setupDualTrackFileInputs() {
                setupTrackFileInput('A');
                setupTrackFileInput('B');
            }

            function setupTrackFileInput(track) {
                const fileInput = document.getElementById(`fileInput${track}`);
                const dropZone = document.getElementById(`fileDropZone${track}`);

                // Handle file selection (both click and drag-drop)
                async function handleFile(file) {
                    if (!file) return;

                    showStatus(`📁 Loading Track ${track}: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)...`, 'info');
                    console.log(`Loading Track ${track} file: ${file.name}, size: ${file.size} bytes, type: ${file.type}`);

                    try {
                        // Enhanced file type checking - check both MIME type and extension
                        const supportedExtensions = ['wav', 'mp3', 'ogg', 'webm', 'm4a', 'aac', 'flac', 'opus'];
                        const supportedMimeTypes = [
                            'audio/wav', 'audio/wave', 'audio/x-wav',
                            'audio/mp3', 'audio/mpeg', 'audio/mp4',
                            'audio/ogg', 'audio/opus',
                            'audio/webm', 'audio/m4a', 'audio/aac',
                            'audio/flac', 'audio/x-flac'
                        ];

                        const fileExtension = file.name.toLowerCase().split('.').pop();
                        const mimeType = file.type.toLowerCase();

                        const isValidExtension = supportedExtensions.includes(fileExtension);
                        const isValidMimeType = supportedMimeTypes.some(type => mimeType.includes(type.replace('audio/', '')));

                        if (!isValidExtension && !isValidMimeType) {
                            throw new Error(`Unsupported file format: ${fileExtension || mimeType}.\nSupported formats: ${supportedExtensions.join(', ').toUpperCase()}`);
                        }

                        // Initialize audio context first
                        await initAudioContext();
                        console.log(`Audio context initialized, reading Track ${track} file...`);
                        showStatus(`🔄 Reading Track ${track} data...`, 'info');

                        // Read file as array buffer with progress
                        const arrayBuffer = await file.arrayBuffer();
                        console.log(`Track ${track} file read complete, buffer size: ${arrayBuffer.byteLength} bytes`);
                        showStatus(`🎵 Decoding Track ${track} audio (${fileExtension?.toUpperCase() || 'unknown format'})...`, 'info');

                        // Decode audio data with comprehensive error handling
                        try {
                            const audioBuffer = await ctx.decodeAudioData(arrayBuffer);

                            // Store in appropriate track variable
                            if (track === 'A') {
                                audioBufferA = audioBuffer;
                                trackDurationA = audioBuffer.duration;
                                document.getElementById('timeSliderA').max = trackDurationA;
                                document.getElementById('playBtnA').disabled = false;
                                console.log(`Track A loaded: duration=${trackDurationA}s, slider max set to ${trackDurationA}`);
                            } else {
                                audioBufferB = audioBuffer;
                                trackDurationB = audioBuffer.duration;
                                document.getElementById('timeSliderB').max = trackDurationB;
                                document.getElementById('playBtnB').disabled = false;
                                console.log(`Track B loaded: duration=${trackDurationB}s, slider max set to ${trackDurationB}`);
                            }

                            const duration = audioBuffer.duration;
                            const sampleRate = audioBuffer.sampleRate;
                            const channels = audioBuffer.numberOfChannels;
                            const samples = audioBuffer.length;

                            console.log(`Track ${track} decoded successfully:
            - File: ${file.name}
            - Duration: ${duration.toFixed(2)}s
            - Sample Rate: ${sampleRate}Hz
            - Channels: ${channels} (${channels === 1 ? 'Mono' : channels === 2 ? 'Stereo' : channels + '-channel'})
            - Samples: ${samples.toLocaleString()}
            - Size: ${(file.size / 1024 / 1024).toFixed(1)}MB`);

                            showStatus(`✅ Track ${track} Ready: ${file.name} | ${duration.toFixed(1)}s | ${sampleRate}Hz | ${channels}ch`, 'success');

                            // Update drop zone text to show loaded file
                            const dropText = dropZone.querySelector('.file-drop-text');
                            dropText.textContent = `✅ ${file.name.substring(0, 20)}...`;
                            dropZone.style.borderColor = track === 'A' ? 'rgba(78, 205, 196, 0.7)' : 'rgba(255, 107, 107, 0.7)';
                            dropZone.style.background = track === 'A' ? 'rgba(78, 205, 196, 0.1)' : 'rgba(255, 107, 107, 0.1)';

                            // Show audio info in status for user
                            setTimeout(() => {
                                showStatus(`🎵 Track ${track}: ${file.name} loaded (${duration.toFixed(1)}s, ${channels === 1 ? 'Mono' : 'Stereo'})`, 'success');
                            }, 2000);

                        } catch (decodeError) {
                            console.error(`Track ${track} decoding failed:`, decodeError);

                            // Provide specific error messages for common issues
                            let errorMessage = `Failed to decode Track ${track} audio file.`;
                            if (decodeError.message.includes('Unable to decode')) {
                                errorMessage = `Cannot decode Track ${track} ${fileExtension?.toUpperCase() || 'this'} file. It may be corrupted, DRM-protected, or in an unsupported codec.`;
                            } else if (decodeError.message.includes('InvalidStateError')) {
                                errorMessage = `Track ${track} audio context error. Try refreshing the page and loading the file again.`;
                            } else if (decodeError.message.includes('DataError')) {
                                errorMessage = `Track ${track} invalid audio data. The file may be corrupted or not a valid audio file.`;
                            }

                            throw new Error(`${errorMessage}\n\nTechnical details: ${decodeError.message}`);
                        }

                    } catch (error) {
                        const errorMsg = error.message.replace('Error: ', '');
                        showStatus(`❌ Track ${track}: ${errorMsg}`, 'error');
                        console.error(`Track ${track} loading error:`, error);

                        // Reset file input and disable play button
                        fileInput.value = '';
                        document.getElementById(`playBtn${track}`).disabled = true;
                        if (track === 'A') {
                            audioBufferA = null;
                            trackDurationA = 0;
                        } else {
                            audioBufferB = null;
                            trackDurationB = 0;
                        }

                        // Reset drop zone appearance
                        const dropText = dropZone.querySelector('.file-drop-text');
                        dropText.textContent = `🎵 Drop audio file ${track} here or click`;
                        dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        dropZone.style.background = 'rgba(255, 255, 255, 0.05)';
                    }
                }

                // File input change event
                fileInput.addEventListener('change', async function (e) {
                    const file = e.target.files[0];
                    await handleFile(file);
                });

                // Drag and drop events
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                });

                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        // Also update the file input to reflect the dropped file
                        const dt = new DataTransfer();
                        dt.items.add(file);
                        fileInput.files = dt.files;
                        await handleFile(file);
                    }
                });

                // Click on drop zone to trigger file input
                dropZone.addEventListener('click', (event) => {
                    // Only trigger file input if clicking directly on the drop zone, not on child buttons
                    if (event.target === dropZone || event.target.classList.contains('file-drop-text')) {
                        fileInput.click();
                    }
                });
            }

            // Legacy cleanup - removed old single-track handlers

            // Dual Track Play/Stop button handlers
            // Track A Play/Stop button
            document.getElementById('playBtnA').addEventListener('click', async function (event) {
                event.preventDefault();
                event.stopPropagation();
                await toggleTrackPlayback('A');
            });

            // Track B Play/Stop button  
            document.getElementById('playBtnB').addEventListener('click', async function (event) {
                event.preventDefault();
                event.stopPropagation();
                await toggleTrackPlayback('B');
            });

            // Track A Stop button
            const stopBtnA = document.getElementById('stopBtnA');
            if (stopBtnA) {
                console.log('Stop button A found and adding event listener');

                // Clear all existing handlers and attributes
                stopBtnA.onclick = null;
                stopBtnA.removeAttribute('onclick');
                stopBtnA.removeAttribute('href');
                stopBtnA.setAttribute('type', 'button'); // Ensure it's a button

                // Define the stop handler
                const stopHandlerA = async function (event) {
                    console.log('Stop button A activated!', event.type, event.target);

                    // Immediately block all event propagation
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();

                    // Additional debugging
                    console.log('Event target:', event.target);
                    console.log('Event currentTarget:', event.currentTarget);
                    console.log('Event phase:', event.eventPhase);

                    try {
                        await stopTrack('A');
                        console.log('Stop track A completed');
                    } catch (error) {
                        console.error('Error in stop track A:', error);
                    }

                    return false;
                };

                // Add multiple event listeners to catch all possible interactions
                stopBtnA.addEventListener('click', stopHandlerA, { capture: true, passive: false });
                stopBtnA.addEventListener('mousedown', stopHandlerA, { capture: true, passive: false });
                stopBtnA.addEventListener('touchstart', stopHandlerA, { capture: true, passive: false });

            } else {
                console.error('Stop button A not found!');
            }

            // Track B Stop button
            const stopBtnB = document.getElementById('stopBtnB');
            if (stopBtnB) {
                console.log('Stop button B found and adding event listener');

                // Clear all existing handlers and attributes
                stopBtnB.onclick = null;
                stopBtnB.removeAttribute('onclick');
                stopBtnB.removeAttribute('href');
                stopBtnB.setAttribute('type', 'button'); // Ensure it's a button

                // Define the stop handler
                const stopHandlerB = async function (event) {
                    console.log('Stop button B activated!', event.type, event.target);

                    // Immediately block all event propagation
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();

                    // Additional debugging
                    console.log('Event target:', event.target);
                    console.log('Event currentTarget:', event.currentTarget);
                    console.log('Event phase:', event.eventPhase);

                    try {
                        await stopTrack('B');
                        console.log('Stop track B completed');
                    } catch (error) {
                        console.error('Error in stop track B:', error);
                    }

                    return false;
                };

                // Add multiple event listeners to catch all possible interactions
                stopBtnB.addEventListener('click', stopHandlerB, { capture: true, passive: false });
                stopBtnB.addEventListener('mousedown', stopHandlerB, { capture: true, passive: false });
                stopBtnB.addEventListener('touchstart', stopHandlerB, { capture: true, passive: false });

            } else {
                console.error('Stop button B not found!');
            }

            // Track timing functions
            async function toggleTrackPlayback(track) {
                const isPlayingTrack = track === 'A' ? isPlayingA : isPlayingB;
                const playBtn = document.getElementById(`playBtn${track}`);

                if (isPlayingTrack) {
                    await pauseTrack(track);
                } else {
                    await playTrack(track);
                }
            } async function playTrack(track) {
                const audioBuffer = track === 'A' ? audioBufferA : audioBufferB;
                const playBtn = document.getElementById(`playBtn${track}`);

                if (!audioBuffer) {
                    showStatus(`Please load Track ${track} first`, 'error');
                    return;
                }

                try {
                    await initAudioContext();

                    // Initialize mixed playback system if not already running
                    if (!isPlaying) {
                        await startMixedPlaybackSystem();
                    }

                    playBtn.textContent = track === 'A' ? '⏸️ Pause A' : '⏸️ Pause B';

                    // Create source for the track
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.loop = true;

                    // Get current track position
                    const startPosition = track === 'A' ? trackPositionA : trackPositionB;

                    // Connect to appropriate mixer channel
                    if (track === 'A') {
                        if (currentSourceA) {
                            currentSourceA.stop();
                        }
                        currentSourceA = source;
                        source.connect(mixerGainNodeA);
                        isPlayingA = true;
                        trackStartTimeA = ctx.currentTime - startPosition;

                        // When track A starts, trigger FadeSync update if enabled
                        if (realtimeParams.fadeSyncEnabled) {
                            updateFadeSyncMix();
                        }
                    } else {
                        if (currentSourceB) {
                            currentSourceB.stop();
                        }
                        currentSourceB = source;
                        source.connect(mixerGainNodeB);
                        isPlayingB = true;
                        trackStartTimeB = ctx.currentTime - startPosition;

                        // When track B starts, trigger FadeSync update if enabled
                        if (realtimeParams.fadeSyncEnabled) {
                            updateFadeSyncMix();
                        }
                    }

                    source.onended = () => {
                        if (track === 'A') {
                            isPlayingA = false;
                            playBtn.textContent = '▶️ Play A';
                            currentSourceA = null;
                        } else {
                            isPlayingB = false;
                            playBtn.textContent = '▶️ Play B';
                            currentSourceB = null;
                        }
                    };

                    // Start playback from the current position
                    source.start(0, startPosition);
                    showStatus(`Track ${track} playing through transformer`, 'info');

                } catch (error) {
                    showStatus(`Error playing Track ${track}: ${error.message}`, 'error');
                    console.error(`Track ${track} playback error:`, error);
                }
            }

            async function pauseTrack(track) {
                const playBtn = document.getElementById(`playBtn${track}`);

                try {
                    if (track === 'A' && currentSourceA) {
                        // Save current position before stopping
                        trackPositionA = ctx.currentTime - trackStartTimeA;

                        currentSourceA.stop();
                        currentSourceA = null;
                        isPlayingA = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play A';
                        }

                    } else if (track === 'B' && currentSourceB) {
                        // Save current position before stopping
                        trackPositionB = ctx.currentTime - trackStartTimeB;

                        currentSourceB.stop();
                        currentSourceB = null;
                        isPlayingB = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play B';
                        }
                    }

                    // If no tracks are playing, stop the mixed system
                    if (!isPlayingA && !isPlayingB) {
                        await stopMixedPlayback();
                    }

                    showStatus(`Track ${track} paused`, 'info');

                } catch (error) {
                    console.error(`Error pausing track ${track}:`, error);
                    showStatus(`Error pausing Track ${track}: ${error.message}`, 'error');
                }
            }

            async function stopTrack(track) {
                const playBtn = document.getElementById(`playBtn${track}`);

                try {
                    if (track === 'A' && currentSourceA) {
                        currentSourceA.stop();
                        currentSourceA = null;
                        isPlayingA = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play A';
                        }
                        trackPositionA = 0; // Reset position

                        // Reset time slider
                        const timeSliderA = document.getElementById('timeSliderA');
                        const timeValueA = document.getElementById('timeValueA');
                        if (timeSliderA) timeSliderA.value = 0;
                        if (timeValueA) timeValueA.textContent = '0:00';

                    } else if (track === 'B' && currentSourceB) {
                        currentSourceB.stop();
                        currentSourceB = null;
                        isPlayingB = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play B';
                        }
                        trackPositionB = 0; // Reset position

                        // Reset time slider
                        const timeSliderB = document.getElementById('timeSliderB');
                        const timeValueB = document.getElementById('timeValueB');
                        if (timeSliderB) timeSliderB.value = 0;
                        if (timeValueB) timeValueB.textContent = '0:00';
                    }

                    // If no tracks are playing, stop the mixed system
                    if (!isPlayingA && !isPlayingB) {
                        await stopMixedPlayback();
                    }

                    showStatus(`Track ${track} stopped`, 'info');

                } catch (error) {
                    console.error(`Error stopping track ${track}:`, error);
                    showStatus(`Error stopping Track ${track}: ${error.message}`, 'error');
                }
            }

            // Function to scrub track to specific position
            function scrubTrack(track, position) {
                console.log(`scrubTrack called: track=${track}, position=${position}`);
                try {
                    if (track === 'A' && currentSourceA && audioBufferA && isPlayingA) {
                        console.log(`Scrubbing track A from ${trackPositionA} to ${position}`);
                        // Stop current source (but don't trigger button state change)
                        currentSourceA.onended = null; // Remove the onended handler to prevent button state change
                        currentSourceA.stop();

                        // Create new source starting at the specified position
                        const newSource = ctx.createBufferSource();
                        newSource.buffer = audioBufferA;
                        newSource.loop = true;
                        newSource.connect(mixerGainNodeA);

                        // Start from the scrubbed position
                        newSource.start(0, position);
                        currentSourceA = newSource;
                        trackStartTimeA = ctx.currentTime - position;

                        // Set onended handler for natural track ending (not scrubbing)
                        newSource.onended = () => {
                            // Only change button state if the track actually ended naturally
                            if (isPlayingA) {
                                isPlayingA = false;
                                document.getElementById('playBtnA').textContent = '▶️ Play A';
                                currentSourceA = null;
                                console.log('Track A ended naturally');
                            }
                        };

                        console.log(`Track A scrubbed successfully to ${position}s`);

                    } else if (track === 'B' && currentSourceB && audioBufferB && isPlayingB) {
                        console.log(`Scrubbing track B from ${trackPositionB} to ${position}`);
                        // Stop current source (but don't trigger button state change)
                        currentSourceB.onended = null; // Remove the onended handler to prevent button state change
                        currentSourceB.stop();

                        // Create new source starting at the specified position
                        const newSource = ctx.createBufferSource();
                        newSource.buffer = audioBufferB;
                        newSource.loop = true;
                        newSource.connect(mixerGainNodeB);

                        // Start from the scrubbed position
                        newSource.start(0, position);
                        currentSourceB = newSource;
                        trackStartTimeB = ctx.currentTime - position;

                        // Set onended handler for natural track ending (not scrubbing)
                        newSource.onended = () => {
                            // Only change button state if the track actually ended naturally
                            if (isPlayingB) {
                                isPlayingB = false;
                                document.getElementById('playBtnB').textContent = '▶️ Play B';
                                currentSourceB = null;
                                console.log('Track B ended naturally');
                            }
                        };

                        console.log(`Track B scrubbed successfully to ${position}s`);
                    } else {
                        console.log(`Scrubbing skipped: track=${track}, playing=${track === 'A' ? isPlayingA : isPlayingB}, hasSource=${track === 'A' ? !!currentSourceA : !!currentSourceB}, hasBuffer=${track === 'A' ? !!audioBufferA : !!audioBufferB}`);
                    }
                } catch (error) {
                    console.error(`Error scrubbing track ${track}:`, error);
                    showStatus(`Error scrubbing track ${track}: ${error.message}`, 'error');
                }
            }

            // Initialize the mixed playback system (always runs when any track plays)
            async function startMixedPlaybackSystem() {
                if (isPlaying) return; // Already running

                try {
                    await initAudioContext();

                    // Create mixer nodes
                    mixerGainNodeA = ctx.createGain();
                    mixerGainNodeB = ctx.createGain();
                    mixerOutputNode = ctx.createGain();

                    // Update crossfader gains
                    updateCrossfaderGains();

                    // Connect mixer
                    mixerGainNodeA.connect(mixerOutputNode);
                    mixerGainNodeB.connect(mixerOutputNode);

                    // Create real-time processor
                    realtimeProcessor = setupRealtimeAudio();
                    if (!realtimeProcessor) {
                        throw new Error('Failed to create real-time processor');
                    }

                    // Create effects chain
                    const delayEffect = createDelayEffect();
                    const reverbEffect = createReverbEffect();
                    createOutputFilters();

                    // Create LUFS analyzers
                    inputLufsAnalyser = ctx.createAnalyser();
                    inputLufsAnalyser.fftSize = 2048;
                    inputLufsAnalyser.smoothingTimeConstant = 0.8;

                    outputLufsAnalyser = ctx.createAnalyser();
                    outputLufsAnalyser.fftSize = 2048;
                    outputLufsAnalyser.smoothingTimeConstant = 0.8;

                    // Connect mixed audio to processing chain
                    mixerOutputNode.connect(inputLufsAnalyser);
                    inputLufsAnalyser.connect(realtimeProcessor);

                    // Store effect references
                    delayNode = delayEffect ? delayEffect.delayNode : null;
                    delayFeedbackNode = delayEffect ? delayEffect.feedbackNode : null;
                    delayMixNode = delayEffect ? delayEffect.wetGainNode : null;
                    delayWetGainNode = delayEffect ? delayEffect.wetGainNode : null;
                    delayDryGainNode = delayEffect ? delayEffect.dryGainNode : null;

                    reverbNode = reverbEffect ? reverbEffect.reverbNode : null;
                    reverbMixNode = reverbEffect ? reverbEffect.wetGainNode : null;
                    reverbWetGainNode = reverbEffect ? reverbEffect.wetGainNode : null;
                    reverbDryGainNode = reverbEffect ? reverbEffect.dryGainNode : null;

                    // Create output gain and compressor
                    finalOutputGainNode = ctx.createGain();
                    finalOutputGainNode.gain.setValueAtTime(realtimeParams.finalOutputGain, ctx.currentTime);

                    compressorNode = ctx.createDynamicsCompressor();
                    compressorNode.threshold.setValueAtTime(-0.1, ctx.currentTime);
                    compressorNode.knee.setValueAtTime(0, ctx.currentTime);
                    compressorNode.ratio.setValueAtTime(20, ctx.currentTime);
                    compressorNode.attack.setValueAtTime(0.001, ctx.currentTime);
                    compressorNode.release.setValueAtTime(0.01, ctx.currentTime);

                    // Connect effects chain
                    if (delayEffect && reverbEffect && highPassFilter && lowPassFilter) {
                        realtimeProcessor.connect(delayEffect.input);
                        realtimeProcessor.connect(delayEffect.inputDry);
                        delayEffect.output.connect(reverbEffect.input);
                        delayEffect.output.connect(reverbEffect.inputDry);
                        reverbEffect.output.connect(highPassFilter);
                        lowPassFilter.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    } else if (highPassFilter && lowPassFilter) {
                        realtimeProcessor.connect(highPassFilter);
                        lowPassFilter.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    } else {
                        realtimeProcessor.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    }

                    isPlaying = true;
                    isRealTimeMode = true;

                    // Start LUFS monitoring
                    if (lufsUpdateInterval) {
                        clearInterval(lufsUpdateInterval);
                    }
                    lufsUpdateInterval = setInterval(updateLUFSMeasurements, 50);

                    // Start visualization and modulation
                    animationId = requestAnimationFrame(drawVisualization);
                    if (realtimeParams.modEnabled) {
                        requestAnimationFrame(updateModulatedDisplay);
                    }

                    // Setup real-time parameter updates
                    setupRealtimeParameterUpdates();
                    setupVisualization();
                    drawVisualization();

                    showStatus(`🎧 Transform system initialized!`, 'success');

                } catch (error) {
                    isPlaying = false;
                    isRealTimeMode = false;
                    showStatus(`Error starting transform system: ${error.message}`, 'error');
                    console.error('Transform system error:', error);
                }
            }

            // Mixed playback with crossfading and processing
            async function toggleMixedPlayback() {
                if (isPlaying) {
                    await stopMixedPlayback();
                } else {
                    await playMixedTracks();
                }
            } async function playMixedTracks() {
                // This function is now deprecated - individual tracks handle mixed playback
                showStatus('Use individual track play buttons instead', 'info');
                return;
            }

            async function stopMixedPlayback() {
                // Stop LUFS monitoring
                if (lufsUpdateInterval) {
                    clearInterval(lufsUpdateInterval);
                    lufsUpdateInterval = null;
                }

                // Stop sources
                if (currentSourceA) {
                    currentSourceA.stop();
                    currentSourceA = null;
                }
                if (currentSourceB) {
                    currentSourceB.stop();
                    currentSourceB = null;
                }

                // Disconnect all nodes
                if (realtimeProcessor) {
                    realtimeProcessor.disconnect();
                    realtimeProcessor = null;
                }
                if (analyser) {
                    analyser.disconnect();
                }

                // Disconnect effects and mixers
                [delayNode, delayFeedbackNode, delayWetGainNode, delayDryGainNode,
                    reverbNode, reverbWetGainNode, reverbDryGainNode,
                    finalOutputGainNode, compressorNode, inputLufsAnalyser, outputLufsAnalyser,
                    mixerGainNodeA, mixerGainNodeB, mixerOutputNode].forEach(node => {
                        if (node) {
                            node.disconnect();
                        }
                    });

                // Reset variables
                isPlaying = false;
                isRealTimeMode = false;

                cancelAnimationFrame(animationId);
                showStatus('Mixed playback stopped', 'info');
            }

            // Crossfader and time control handlers
            function updateCrossfaderGains() {
                const crossfaderPos = realtimeParams.crossfaderValue / 100; // 0 to 1

                // Calculate gains using equal power law for smooth crossfading
                const gainA = Math.cos(crossfaderPos * Math.PI / 2);
                const gainB = Math.sin(crossfaderPos * Math.PI / 2);

                realtimeParams.crossfaderGainA = gainA;
                realtimeParams.crossfaderGainB = gainB;

                if (mixerGainNodeA) {
                    mixerGainNodeA.gain.setValueAtTime(gainA, ctx.currentTime);
                }
                if (mixerGainNodeB) {
                    mixerGainNodeB.gain.setValueAtTime(gainB, ctx.currentTime);
                }

                // Update display
                const crossfaderValue = document.getElementById('crossfaderValue');
                if (crossfaderPos < 0.1) {
                    crossfaderValue.textContent = 'A Only';
                } else if (crossfaderPos > 0.9) {
                    crossfaderValue.textContent = 'B Only';
                } else {
                    const percentA = Math.round(gainA * gainA * 100);
                    const percentB = Math.round(gainB * gainB * 100);
                    crossfaderValue.textContent = `A:${percentA}% B:${percentB}%`;
                }
            }
            // FadeSync: Effects intensity based on crossfader position
            // 100% Track A (0) = 0% effects, 50/50 mix (50) = 100% effects, 100% Track B (100) = 0% effects
            function updateFadeSyncMix() {
                if (!realtimeParams.fadeSyncEnabled) return;

                const crossfaderPos = realtimeParams.crossfaderValue / 100; // 0 to 1

                // Calculate effects mix factor: 0 at extremes (0 or 100), 1 at center (50)
                // Use a sine wave that peaks at 0.5 (center)
                const effectsMixFactor = Math.sin(crossfaderPos * Math.PI);

                // Debug logging
                console.log(`FadeSync Debug - Crossfader: ${crossfaderPos}, EffectsFactor: ${effectsMixFactor.toFixed(3)}`);

                // Update transform mix parameter (scaled by captured maximum)
                const transformMix = effectsMixFactor * realtimeParams.fadeSyncMaxTransformMix;
                realtimeParams.mix = transformMix;
                if (realtimeProcessor && realtimeProcessor.params) {
                    realtimeProcessor.params.mix = transformMix;
                }

                // Update transform mix slider display
                const mixSlider = document.getElementById('mixSlider');
                const mixValueDisplay = document.getElementById('mixValue');
                if (mixSlider && mixValueDisplay) {
                    mixSlider.value = Math.round(transformMix * 100);
                    mixValueDisplay.textContent = Math.round(transformMix * 100) + '%';
                }

                // Update delay mix parameter (scaled by captured maximum)
                const delayMix = effectsMixFactor * realtimeParams.fadeSyncMaxDelayMix;
                realtimeParams.delayMix = delayMix;
                const delayMixSlider = document.getElementById('delayMixSlider');
                const delayMixValueDisplay = document.getElementById('delayMixValue');
                if (delayMixSlider && delayMixValueDisplay) {
                    delayMixSlider.value = Math.round(delayMix * 100);
                    delayMixValueDisplay.textContent = Math.round(delayMix * 100) + '%';
                }
                // Update delay wet/dry mix in audio nodes
                if (delayWetGainNode && delayDryGainNode) {
                    delayWetGainNode.gain.setTargetAtTime(delayMix, ctx.currentTime, 0.01);
                    delayDryGainNode.gain.setTargetAtTime(1.0 - delayMix, ctx.currentTime, 0.01);
                }

                // Update reverb mix parameter (scaled by captured maximum)
                const reverbMix = effectsMixFactor * realtimeParams.fadeSyncMaxReverbMix;
                realtimeParams.reverbMix = reverbMix;
                console.log(`Reverb Debug - Max: ${realtimeParams.fadeSyncMaxReverbMix}, Mix: ${reverbMix.toFixed(3)}, Nodes: ${reverbWetGainNode ? 'OK' : 'NULL'}, ${reverbDryGainNode ? 'OK' : 'NULL'}`);

                const reverbMixSlider = document.getElementById('reverbMixSlider');
                const reverbMixValueDisplay = document.getElementById('reverbMixValue');
                if (reverbMixSlider && reverbMixValueDisplay) {
                    reverbMixSlider.value = Math.round(reverbMix * 100);
                    reverbMixValueDisplay.textContent = Math.round(reverbMix * 100) + '%';
                }
                // Update reverb wet/dry mix in audio nodes
                if (reverbWetGainNode && reverbDryGainNode) {
                    reverbWetGainNode.gain.setTargetAtTime(reverbMix, ctx.currentTime, 0.01);
                    reverbDryGainNode.gain.setTargetAtTime(1.0 - reverbMix, ctx.currentTime, 0.01);
                    console.log(`Reverb audio nodes updated: wet=${reverbMix.toFixed(3)}, dry=${(1.0 - reverbMix).toFixed(3)}`);
                }

                // --- FadeSync Function Gain (Gain knob under Mathematical Function) ---
                // If function gain is set (dB), fade it from 0dB at crossfader extremes to max at center
                if (typeof realtimeParams.fadeSyncMaxFunctionGainDb === 'number' && realtimeParams.fadeSyncMaxFunctionGainDb > -60) {
                    // At center: max dB, at edges: 0dB (smooth sine curve)
                    const functionGainDb = effectsMixFactor * realtimeParams.fadeSyncMaxFunctionGainDb;
                    realtimeParams.gain = functionGainDb <= -60 ? 0 : Math.pow(10, functionGainDb / 20);

                    // Update function gain slider and display with smooth transitions
                    const gainSlider = document.getElementById('gainSlider');
                    const gainValue = document.getElementById('gainValue');
                    if (gainSlider && gainValue) {
                        gainSlider.value = functionGainDb <= -60 ? -60 : functionGainDb;
                        gainValue.textContent = functionGainDb <= -60
                            ? '-∞dB'
                            : (functionGainDb >= 0 ? '+' : '') + functionGainDb.toFixed(1) + 'dB';
                    }
                    // Update processor param with smooth transition
                    if (realtimeProcessor && realtimeProcessor.params) {
                        realtimeProcessor.params.gain = realtimeParams.gain;
                    }

                    console.log(`FadeSync Function Gain - Factor: ${effectsMixFactor.toFixed(3)}, Max: ${realtimeParams.fadeSyncMaxFunctionGainDb.toFixed(1)}dB, Current: ${functionGainDb.toFixed(1)}dB`);
                }

                // --- FadeSync Output Gain (Master Output) ---
                if (typeof realtimeParams.fadeSyncMaxOutputGainDb === 'number') {
                    const outputGainDb = effectsMixFactor * realtimeParams.fadeSyncMaxOutputGainDb;
                    realtimeParams.outputGainDb = outputGainDb;
                    realtimeParams.finalOutputGain = outputGainDb <= -60 ? 0 : Math.pow(10, outputGainDb / 20);

                    if (finalOutputGainNode) {
                        finalOutputGainNode.gain.setTargetAtTime(realtimeParams.finalOutputGain, ctx.currentTime, 0.01);
                    }
                    const outputGainSlider = document.getElementById('outputGainSlider');
                    const outputGainValue = document.getElementById('outputGainValue');
                    if (outputGainSlider && outputGainValue) {
                        outputGainSlider.value = outputGainDb <= -60 ? -60 : outputGainDb;
                        outputGainValue.textContent = outputGainDb <= -60
                            ? '-∞dB'
                            : (outputGainDb >= 0 ? '+' : '') + outputGainDb.toFixed(1) + 'dB';
                    }
                }
            }

            // Crossfader handler with FadeSync support
            const crossfaderSlider = document.getElementById('crossfaderSlider');
            const fadeSyncCheckbox = document.getElementById('fadeSyncCrossfader');

            if (crossfaderSlider) {
                crossfaderSlider.addEventListener('input', function () {
                    realtimeParams.crossfaderValue = parseInt(this.value);
                    updateCrossfaderGains();

                    // Update FadeSync if enabled
                    if (realtimeParams.fadeSyncEnabled) {
                        updateFadeSyncMix();
                    }
                });
            }

            if (fadeSyncCheckbox) {
                fadeSyncCheckbox.addEventListener('change', function () {
                    realtimeParams.fadeSyncEnabled = this.checked;

                    if (this.checked) {
                        // Capture current effect values as maximums for FadeSync
                        realtimeParams.fadeSyncMaxTransformMix = realtimeParams.mix;
                        realtimeParams.fadeSyncMaxDelayMix = realtimeParams.delayMix;
                        realtimeParams.fadeSyncMaxReverbMix = realtimeParams.reverbMix;

                        // Capture function gain - ensure we have a meaningful value
                        const currentGainDb = realtimeParams.gain > 0 ? 20 * Math.log10(realtimeParams.gain) : 0;
                        realtimeParams.fadeSyncMaxFunctionGainDb = Math.max(currentGainDb, 6); // Minimum 6dB for meaningful fading

                        realtimeParams.fadeSyncMaxOutputGainDb = realtimeParams.outputGainDb;

                        console.log(`FadeSync enabled - Function Gain Max captured: ${realtimeParams.fadeSyncMaxFunctionGainDb.toFixed(1)}dB`);

                        // Apply initial FadeSync mix
                        updateFadeSyncMix();
                        showStatus('FadeSync enabled - Effects will fade with crossfader position', 'success');
                    } else {
                        showStatus('FadeSync disabled - Manual effect control restored', 'info');
                    }
                });
            }

            // Setup time sliders for both tracks
            function setupTimeSliders() {
                // Track time sliders with proper drag state tracking
                const timeSliderA = document.getElementById('timeSliderA');
                if (timeSliderA) {
                    console.log('Time slider A found, setting up event listeners');

                    // Track drag state with specific events for this slider
                    const handleMouseDownA = () => {
                        timeSliderADragging = true;
                        console.log('Time slider A drag started');
                    };

                    const handleMouseUpA = () => {
                        if (timeSliderADragging) {
                            console.log('Time slider A drag ended');
                            timeSliderADragging = false;
                        }
                    };

                    const handleTouchStartA = () => {
                        timeSliderADragging = true;
                        console.log('Time slider A touch started');
                    };

                    const handleTouchEndA = () => {
                        if (timeSliderADragging) {
                            console.log('Time slider A touch ended');
                            timeSliderADragging = false;
                        }
                    };

                    // Add event listeners
                    timeSliderA.addEventListener('mousedown', handleMouseDownA);
                    timeSliderA.addEventListener('touchstart', handleTouchStartA);

                    // Use document-level events but check if this specific slider was being dragged
                    document.addEventListener('mouseup', handleMouseUpA);
                    document.addEventListener('touchend', handleTouchEndA);

                    // Also handle mouse leave events to ensure drag state is reset
                    timeSliderA.addEventListener('mouseleave', () => {
                        if (timeSliderADragging) {
                            console.log('Time slider A mouse left while dragging - ending drag');
                            timeSliderADragging = false;
                        }
                    });

                    timeSliderA.addEventListener('input', function () {
                        console.log(`Time slider A moved to: ${this.value}, dragging: ${timeSliderADragging}`);
                        trackPositionA = parseFloat(this.value);
                        const minutes = Math.floor(trackPositionA / 60);
                        const seconds = Math.floor(trackPositionA % 60);
                        document.getElementById('timeValueA').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                        // Scrub track A to the new position if playing
                        if (isPlayingA && currentSourceA && audioBufferA) {
                            console.log(`Scrubbing track A to position: ${trackPositionA}`);
                            scrubTrack('A', trackPositionA);
                        }
                    });

                    // Handle the change event (fires when user releases slider)
                    timeSliderA.addEventListener('change', function () {
                        console.log(`Time slider A change event: ${this.value}`);
                        timeSliderADragging = false; // Ensure drag state is reset
                    });

                } else {
                    console.error('Time slider A not found!');
                }

                const timeSliderB = document.getElementById('timeSliderB');
                if (timeSliderB) {
                    console.log('Time slider B found, setting up event listeners');

                    // Track drag state with specific events for this slider
                    const handleMouseDownB = () => {
                        timeSliderBDragging = true;
                        console.log('Time slider B drag started');
                    };

                    const handleMouseUpB = () => {
                        if (timeSliderBDragging) {
                            console.log('Time slider B drag ended');
                            timeSliderBDragging = false;
                        }
                    };

                    const handleTouchStartB = () => {
                        timeSliderBDragging = true;
                        console.log('Time slider B touch started');
                    };

                    const handleTouchEndB = () => {
                        if (timeSliderBDragging) {
                            console.log('Time slider B touch ended');
                            timeSliderBDragging = false;
                        }
                    };

                    // Add event listeners
                    timeSliderB.addEventListener('mousedown', handleMouseDownB);
                    timeSliderB.addEventListener('touchstart', handleTouchStartB);

                    // Use document-level events but check if this specific slider was being dragged
                    document.addEventListener('mouseup', handleMouseUpB);
                    document.addEventListener('touchend', handleTouchEndB);

                    // Also handle mouse leave events to ensure drag state is reset
                    timeSliderB.addEventListener('mouseleave', () => {
                        if (timeSliderBDragging) {
                            console.log('Time slider B mouse left while dragging - ending drag');
                            timeSliderBDragging = false;
                        }
                    });

                    timeSliderB.addEventListener('input', function () {
                        console.log(`Time slider B moved to: ${this.value}, dragging: ${timeSliderBDragging}`);
                        trackPositionB = parseFloat(this.value);
                        const minutes = Math.floor(trackPositionB / 60);
                        const seconds = Math.floor(trackPositionB % 60);
                        document.getElementById('timeValueB').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                        // Scrub track B to the new position if playing
                        if (isPlayingB && currentSourceB && audioBufferB) {
                            console.log(`Scrubbing track B to position: ${trackPositionB}`);
                            scrubTrack('B', trackPositionB);
                        }
                    });

                    // Handle the change event (fires when user releases slider)
                    timeSliderB.addEventListener('change', function () {
                        console.log(`Time slider B change event: ${this.value}`);
                        timeSliderBDragging = false; // Ensure drag state is reset
                    });

                } else {
                    console.error('Time slider B not found!');
                }
            } // End setupTimeSliders function

            // Crossfader modulation sync function (deprecated - now using FadeSync)
            function updateCrossfaderModulation() {
                // This function is no longer used - FadeSync handles effects mixing
                // Keep for compatibility with existing mod system calls
            }

            // Global error handler for all audio operations
            window.addEventListener('error', function (event) {
                if (event.error && event.error.message &&
                    (event.error.message.includes('audio') ||
                        event.error.message.includes('AudioContext') ||
                        event.error.message.includes('TypeError'))) {
                    console.error('Audio error caught by global handler:', event.error);
                    showStatus(`Error: ${event.error.message}. Try clicking the play button first.`, 'error');
                    event.preventDefault();
                }
            });

            // Initialize everything
            initFunctionSelect();
            initSliders();
            setupDualTrackFileInputs(); // Updated for dual track system
            setupTimeSliders(); // Setup time sliders for track scrubbing
            setupVisualization();
            setupFilterControls();

            // Set initial optimal range for default function
            updateSliderRange(selectedFunction);

            // Initialize crossfader
            updateCrossfaderGains();

            showStatus('Run audio through equations and stuff. Ready.', 'info');
            updateMemoryInfo();
        });
    </script>
</body>

</html>
