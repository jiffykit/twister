<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twịz⊥</title>
    <style>
        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 8px;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 1600px;
            height: calc(100vh - 16px);
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 1.6em;
            margin-bottom: 8px;
            text-align: center;
            background: linear-gradient(45deg, #4f0643, #4ecdc4, #225703, #96ceb4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
            flex: 1;
            overflow: hidden;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }

        .control-group h3 {
            margin: 0 0 8px 0;
            font-size: 0.95em;
            color: #4ecdc4;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 4px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #e0e0e0;
            font-size: 0.85em;
        }

        input[type="file"] {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: #fff;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        input[type="file"]:hover,
        .file-drop-zone:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-drop-zone {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop-zone.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: scale(1.02);
        }

        .file-drop-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .file-drop-hint {
            color: #999;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        select {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            font-size: 0.95em;
            width: 100%;
            transition: all 0.3s ease;
        }

        select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #222;
            color: #fff;
            padding: 8px;
        }

        .function-grid {
            display: none;
            /* Hide the grid, we'll use a dropdown */
        }

        .function-select {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            font-size: 0.95em;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .function-select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .function-select option {
            background: #222;
            color: #fff;
            padding: 8px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            color: #fff;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stop-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .stop-btn:hover {
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.6);
        }

        .realtime-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .realtime-btn:hover {
            box-shadow: 0 6px 25px rgba(78, 205, 196, 0.6);
        }

        #status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
        }

        .error {
            background: rgba(255, 51, 51, 0.2);
            border: 1px solid #ff3333;
        }

        .success {
            background: rgba(51, 255, 51, 0.2);
            border: 1px solid #33ff33;
        }

        .info {
            background: rgba(51, 51, 255, 0.2);
            border: 1px solid #3333ff;
        }

        .value-display {
            font-weight: 700;
            color: #4ecdc4;
            font-size: 1.1em;
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }

        .memory-info {
            font-size: 0.9em;
            color: #888;
            text-align: center;
            margin-top: 15px;
        }

        .visualizer {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 120px;
            border-radius: 8px;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
        }

        .compact-layout {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .compact-control {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .compact-control label {
            margin-bottom: 3px;
            font-size: 0.8em;
        }

        .toggle-container {
            display: flex;
            gap: 2px;
            margin-top: 3px;
        }

        .toggle-btn {
            flex: 1;
            padding: 6px 3px;
            font-size: 0.75em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            box-shadow: 0 2px 8px rgba(78, 205, 196, 0.4);
        }

        .slider-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            color: #888;
            margin-top: 2px;
        }

        .visualizer {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 100px;
            border-radius: 6px;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
        }

        .button-group {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 8px 0;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 20px;
            color: #fff;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .compact-layout {
                grid-template-columns: 1fr;
            }
        }

        .value-display {
            font-weight: 700;
            color: #4ecdc4;
            font-size: 1.0em;
        }

        .memory-info {
            font-size: 0.8em;
            color: #888;
            text-align: center;
            margin-top: 8px;
        }

        #status {
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }

        .error {
            background: rgba(255, 51, 51, 0.2);
            border: 1px solid #ff3333;
        }

        .success {
            background: rgba(51, 255, 51, 0.2);
            border: 1px solid #33ff33;
        }

        .info {
            background: rgba(51, 51, 255, 0.2);
            border: 1px solid #3333ff;
        }

        /* Dual-handle slider styling */
        .dual-slider-container {
            position: relative;
            margin: 10px 0;
        }

        .main-slider {
            width: 100%;
            position: relative;
            z-index: 1;
            transition: all 0.1s ease;
        }

        .main-slider.animated {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffd93d);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .main-slider.animated::-webkit-slider-thumb {
            background: radial-gradient(circle, #fff, #4ecdc4);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
            animation: modulation-pulse 1s ease-in-out infinite alternate;
        }

        @keyframes modulation-pulse {
            from {
                transform: scale(1.0);
                box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
            }

            to {
                transform: scale(1.2);
                box-shadow: 0 0 20px rgba(78, 205, 196, 1.0);
            }
        }

        /* Legacy mod-handle styling (kept for modulation sliders) */
        .mod-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: transparent;
            pointer-events: none;
            z-index: 2;
            -webkit-appearance: none;
            appearance: none;
            height: 100%;
        }

        .mod-handle::-webkit-slider-track {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
        }

        .mod-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
            pointer-events: auto;
            cursor: pointer;
            transform: scale(0.9);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            -webkit-appearance: none;
            appearance: none;
        }

        /* FIXED: Compact dual slider - single track appearance */
        .dual-slider-container {
            position: relative;
            margin: 6px 0;
            height: 16px;
        }

        /* Show main slider when modulation is disabled, hide when enabled */
        .dual-slider-container.modulation-disabled .main-slider {
            display: block !important;
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 16px;
            z-index: 5;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .dual-slider-container:not(.modulation-disabled) .main-slider {
            display: none !important;
        }

        .slider-track {
            position: absolute;
            top: 6px;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 2px;
            z-index: 1;
        }

        .dual-handle {
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 16px;
            background: transparent;
            pointer-events: none;
            z-index: 3;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Main slider styling when modulation is disabled - green handle appearance */
        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-track {
            background: transparent;
            height: 4px;
        }

        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
            cursor: pointer;
            position: relative;
            z-index: 6;
        }

        .dual-slider-container.modulation-disabled .main-slider::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #20bf6b, #26de81) !important;
            box-shadow: 0 0 12px rgba(46, 213, 115, 0.8) !important;
            transform: scale(1.1);
        }

        .dual-handle::-webkit-slider-track {
            background: transparent;
            height: 4px;
        }

        .dual-handle::-webkit-slider-thumb {
            pointer-events: auto;
            cursor: pointer;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            -webkit-appearance: none;
            appearance: none;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 4;
        }

        .dual-handle::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
        }

        /* Green handle styling for minimum values */
        .green-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
        }

        .green-handle::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #20bf6b, #26de81) !important;
            box-shadow: 0 0 12px rgba(46, 213, 115, 0.8) !important;
        }

        /* Red handle styling for maximum values */
        .red-handle::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff4757) !important;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6) !important;
        }

        .red-handle::-webkit-slider-thumb:hover {
            background: linear-gradient(45deg, #ff5252, #ff3742) !important;
            box-shadow: 0 0 12px rgba(255, 107, 107, 0.8) !important;
        }

        .handle-labels {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            z-index: 2;
        }

        .min-label {
            color: #2ed573;
            font-weight: 600;
        }

        .max-label {
            color: #ff6b6b;
            font-weight: 600;
        }

        /* Special styling for modulation sliders */
        #modMinSlider::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ff6b6b, #ff4757) !important;
            border: 2px solid #fff !important;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6) !important;
        }

        #modMaxSlider::-webkit-slider-thumb {
            background: linear-gradient(45deg, #2ed573, #7bed9f) !important;
            border: 2px solid #fff !important;
            box-shadow: 0 0 8px rgba(46, 213, 115, 0.6) !important;
        }

        .modulation-range-display {
            font-size: 0.85em;
            color: #ff6b6b;
            margin-top: 5px;
            text-align: center;
            opacity: 0.9;
            font-weight: 500;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
        }

        /* Pulse indicator for modulation */
        .pulse-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: #ffffff;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: left 0.1s ease-out, opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }

        .dual-slider-container:not(.modulation-disabled) .pulse-indicator {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0.7;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* Show mod handles only when modulation is enabled */
        .modulation-disabled .mod-handle {
            display: none;
        }

        .modulation-disabled .modulation-range-display {
            display: none;
        }

        /* Hide dual handles when modulation is disabled */
        .modulation-disabled .dual-handle {
            display: none !important;
        }

        /* LUFS display styling */
        .lufs-display {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 4px;
            padding: 3px 6px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-align: center;
            font-size: 0.75em;
        }

        .toggle-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: #fff;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.4);
        }

        input[type="range"] {
            width: 100%;
            margin: 6px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 3px;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        select {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
            width: 100%;
            transition: all 0.3s ease;
        }

        select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #222;
            color: #fff;
            padding: 6px;
        }

        .function-select {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .function-select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .function-select option {
            background: #222;
            color: #fff;
            padding: 6px;
        }

        input[type="file"] {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            width: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        input[type="file"]:hover,
        .file-drop-zone:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-drop-zone {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop-zone.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: scale(1.02);
        }

        .file-drop-text {
            color: #e0e0e0;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .file-drop-hint {
            color: #999;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Twịz⊥</h1>

        <div class="controls-grid">
            <!-- Dual Track System -->
            <div class="control-group">
                <h3>WTF</h3>

                <!-- Track A -->
                <div
                    style="border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(78, 205, 196, 0.05);">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.85em; color: #4ecdc4;">🎵 Track A</h4>

                    <!-- File Drop Zone Row -->
                    <div class="file-drop-zone" id="fileDropZoneA"
                        style="padding: 4px 8px; margin-bottom: 8px; position: relative; border: 1px dashed rgba(78, 205, 196, 0.5); border-radius: 4px; height: 20px; overflow: hidden;">
                        <div class="file-drop-text" style="font-size: 11px; text-align: center; line-height: 12px;">🎵
                            Drop audio file A here or click</div>
                        <input type="file" id="fileInputA" accept="audio/*"
                            style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 20px; cursor: pointer; z-index: 1;">
                    </div>

                    <!-- Controls Row -->
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                        <button type="button" id="playBtnA" style="padding: 4px 6px; font-size: 0.75em;">▶️ Play
                            A</button>
                        <button type="button" id="stopBtnA" style="padding: 4px 6px; font-size: 0.75em;">⏹️
                            Stop</button>
                    </div>

                    <!-- Time Slider Row -->
                    <div class="compact-control" style="margin-top: 4px;">
                        <label for="timeSliderA" style="font-size: 0.75em;">Time A: <span class="value-display"
                                id="timeValueA">0:00</span></label>
                        <input type="range" id="timeSliderA" min="0" max="100" step="0.1" value="0"
                            style="height: 4px;">
                    </div>
                </div>

                <!-- Track B -->
                <div
                    style="border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(255, 107, 107, 0.05);">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.85em; color: #ff6b6b;">🎵 Track B</h4>

                    <!-- File Drop Zone Row -->
                    <div class="file-drop-zone" id="fileDropZoneB"
                        style="padding: 4px 8px; margin-bottom: 8px; position: relative; border: 1px dashed rgba(255, 107, 107, 0.5); border-radius: 4px; height: 20px; overflow: hidden;">
                        <div class="file-drop-text" style="font-size: 11px; text-align: center; line-height: 12px;">🎵
                            Drop audio file B here or click</div>
                        <input type="file" id="fileInputB" accept="audio/*"
                            style="opacity: 0; position: absolute; top: 0; left: 0; width: 100%; height: 20px; cursor: pointer; z-index: 1;">
                    </div>

                    <!-- Controls Row -->
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                        <button type="button" id="playBtnB" style="padding: 4px 6px; font-size: 0.75em;">▶️ Play
                            B</button>
                        <button type="button" id="stopBtnB" style="padding: 4px 6px; font-size: 0.75em;">⏹️
                            Stop</button>
                    </div>

                    <!-- Time Slider Row -->
                    <div class="compact-control" style="margin-top: 4px;">
                        <label for="timeSliderB" style="font-size: 0.75em;">Time B: <span class="value-display"
                                id="timeValueB">0:00</span></label>
                        <input type="range" id="timeSliderB" min="0" max="100" step="0.1" value="0"
                            style="height: 4px;">
                    </div>
                </div>

                <!-- Crossfader -->
                <div
                    style="border: 1px solid rgba(150, 206, 180, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 8px; background: rgba(150, 206, 180, 0.05);">
                    <div class="compact-control">
                        <label for="crossfaderSlider" style="font-size: 0.85em; color: #96ceb4;">🎚️ Crossfader: <span
                                class="value-display" id="crossfaderValue">A ←→ B</span></label>
                        <input type="range" id="crossfaderSlider" min="0" max="100" step="1" value="50"
                            style="background: linear-gradient(90deg, #4ecdc4, #96ceb4, #ff6b6b);">
                        <div class="slider-info">
                            <span style="color: #4ecdc4;">A Only</span>
                            <span style="color: #96ceb4;">Mix</span>
                            <span style="color: #ff6b6b;">B Only</span>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 4px;">
                        <label style="font-size: 0.75em;">
                            <input type="checkbox" id="fadeSyncCrossfader" style="margin-right: 4px;">
                            FadeSync - Effects fade with crossfader mix
                        </label>
                    </div>
                </div>

                <!-- Master Controls -->
                <div style="margin-top: 8px;">
                    <!-- Buttons removed as requested -->
                </div>

                <div id="status" style="margin-top: 6px; font-size: 0.75em;"></div>
                <div class="memory-info" id="memoryInfo" style="font-size: 0.7em; margin-top: 4px;"></div>
            </div>

            <!-- Mathematical Function & Processing -->
            <div class="control-group">
                <h3>🔬 Mathematical Function</h3>
                <label for="functionSelect">Function:</label>
                <select id="functionSelect" class="function-select">
                    <!-- Basic Operations -->
                    <optgroup label="🔢 Basic Operations">
                        <option value="power">Power (f^n) - Raises frequency to a power, expanding harmonic spacing
                        </option>
                        <option value="sqrt">Square Root - Compresses frequency spectrum, bringing higher harmonics
                            closer</option>
                        <option value="cbrt">Cube Root - Gentle compression of frequency spectrum</option>
                        <option value="nroot">N-th Root - Adjustable frequency compression based on amount</option>
                        <option value="square">Square - Expands frequency spectrum, doubling harmonic distances</option>
                        <option value="cube">Cube - Dramatic frequency expansion, tripling harmonic distances</option>
                        <option value="inverse">Reciprocal (1/z) - Inverts frequency spectrum, low becomes high</option>
                    </optgroup>

                    <!-- Logarithmic & Exponential -->
                    <optgroup label="📈 Logarithmic & Exponential">
                        <option value="log">Natural Log - Dramatically compresses high frequencies</option>
                        <option value="log10">Log Base 10 - Even compression across frequency decades</option>
                        <option value="log2">Log Base 2 - Transforms octaves to linear spacing</option>
                        <option value="exp">Natural Exponential - Explosive high frequency expansion</option>
                        <option value="exp2">Base-2 Exponential - Doubles frequency with each octave</option>
                        <option value="exp10">Base-10 Exponential - Extreme high frequency emphasis</option>
                    </optgroup>

                    <!-- Trigonometric -->
                    <optgroup label="🌊 Trigonometric">
                        <option value="sin">Sine - Warps frequencies in wave-like pattern</option>
                        <option value="cos">Cosine - Similar to sine but phase-shifted warping</option>
                        <option value="tan">Tangent - Creates resonant peaks at periodic intervals</option>
                        <option value="asin">Arc Sine - Compresses extreme frequencies, expands mid-range</option>
                        <option value="acos">Arc Cosine - Inverse cosine warping of frequency space</option>
                        <option value="atan">Arc Tangent - Smooth compression of entire spectrum</option>
                    </optgroup>

                    <!-- Hyperbolic -->
                    <optgroup label="📐 Hyperbolic">
                        <option value="sinh">Hyperbolic Sine - Exponential frequency expansion, symmetric</option>
                        <option value="cosh">Hyperbolic Cosine - Even stronger exponential expansion</option>
                        <option value="tanh">Hyperbolic Tangent - Frequency compression with soft limiting</option>
                        <option value="asinh">Inverse Hyperbolic Sine - Logarithmic-like compression</option>
                        <option value="acosh">Inverse Hyperbolic Cosine - Creates frequency bands</option>
                        <option value="atanh">Inverse Hyperbolic Tangent - Strong mid-frequency emphasis</option>
                    </optgroup>

                    <!-- Famous Physics Equations -->
                    <optgroup label="⚛️ Physics Equations">
                        <option value="schrodinger">Schrödinger Wave - Probabilistic frequency transformation</option>
                        <option value="heisenberg">Heisenberg Uncertainty - Frequency-time smearing effect</option>
                        <option value="einstein_mass_energy">E=mc² - Frequency squaring with relativistic scaling
                        </option>
                        <option value="planck_radiation">Planck Radiation - Black body frequency distribution</option>
                        <option value="maxwell_boltzmann">Maxwell-Boltzmann - Statistical frequency redistribution
                        </option>
                        <option value="wave_equation">Wave Equation - Spatial-temporal frequency mapping</option>
                        <option value="lorentz_factor">Lorentz Factor - Relativistic frequency shifting</option>
                        <option value="schwarzschild">Schwarzschild Radius - Gravitational frequency warping</option>
                    </optgroup>

                    <!-- Special Functions -->
                    <optgroup label="🔬 Special Functions">
                        <option value="gamma">Gamma Function - Extends factorial to complex frequencies</option>
                        <option value="zeta">Riemann Zeta - Prime-based frequency transformation</option>
                        <option value="bessel_j0">Bessel J₀ - Cylindrical wave frequency modulation</option>
                        <option value="bessel_y0">Bessel Y₀ - Complementary cylindrical modulation</option>
                        <option value="erf">Error Function - Statistical frequency distribution</option>
                        <option value="airy_ai">Airy Function - Quantum-mechanical frequency bending</option>
                    </optgroup>

                    <!-- Fractals & Chaos -->
                    <optgroup label="🌀 Fractals & Chaos">
                        <option value="mandelbrot">Mandelbrot Set - Self-similar frequency clusters</option>
                        <option value="julia">Julia Set - Parameter-dependent frequency patterns</option>
                        <option value="burning_ship">Burning Ship - Folded self-similar frequency structure</option>
                        <option value="newton_raphson">Newton Fractal - Frequency root-finding patterns</option>
                        <option value="logistic_map">Logistic Map - Chaotic frequency bifurcation</option>
                        <option value="henon_map">Hénon Map - 2D chaotic frequency attractor</option>
                        <option value="lorenz_attractor">Lorenz Attractor - Weather-like frequency chaos</option>
                    </optgroup>

                    <!-- Geometric Transformations -->
                    <optgroup label="📐 Geometric">
                        <option value="mobius">Möbius Transform - Circular frequency inversion</option>
                        <option value="joukowsky">Joukowsky Transform - Airfoil-like frequency mapping</option>
                        <option value="cayley">Cayley Transform - Maps frequency line to unit circle</option>
                        <option value="schwarz_christoffel">Schwarz-Christoffel - Polygon frequency mapping</option>
                    </optgroup>

                    <!-- Spirals -->
                    <optgroup label="🌪️ Spirals">
                        <option value="spiral">Logarithmic Spiral - Frequency spiraling outward</option>
                        <option value="fibonacci_spiral">Fibonacci Spiral - Golden ratio frequency spacing</option>
                        <option value="archimedean_spiral">Archimedean Spiral - Linear spiral frequency shift</option>
                        <option value="fermat_spiral">Fermat Spiral - Square-root-based frequency spiral</option>
                        <option value="hyperbolic_spiral">Hyperbolic Spiral - Inverse radius frequency mapping</option>
                    </optgroup>

                    <!-- Wave Functions -->
                    <optgroup label="🌊 Wave Functions">
                        <option value="wave">Wave Interference - Frequency combing with interference</option>
                        <option value="ripple">Ripple Effect - Concentric frequency rings</option>
                        <option value="standing_wave">Standing Wave - Frequency nodes and anti-nodes</option>
                        <option value="doppler_effect">Doppler Effect - Moving source frequency shifts</option>
                        <option value="chirp">Chirp Function - Frequency sweep transformation</option>
                        <option value="sinc_function">Sinc Function - Sampling-based frequency comb</option>
                    </optgroup>

                    <!-- Stereo Panning Effects -->
                    <optgroup label="🎧 Stereo Panning">
                        <option value="stereo_real_imag">Real/Imaginary Split - Complex parts to L/R channels</option>
                        <option value="stereo_mag_phase">Magnitude/Phase Split - Polar components to L/R</option>
                        <option value="stereo_rotation">Complex Rotation - Rotating frequency stereo field</option>
                        <option value="stereo_spiral_pan">Spiral Panning - Frequency-dependent stereo panning</option>
                        <option value="stereo_doppler_pan">Doppler Panning - Moving source stereo illusion</option>
                    </optgroup>

                    <!-- Quantum & Exotic -->
                    <optgroup label="🚀 Quantum & Exotic">
                        <option value="quantum_harmonic">Quantum Harmonic - Discrete energy level frequency mapping
                        </option>
                        <option value="hydrogen_orbital">Hydrogen Orbital - Electron probability frequency distribution
                        </option>
                        <option value="tunneling_effect">Quantum Tunneling - Frequency barrier penetration</option>
                        <option value="dirac_equation">Dirac Equation - Relativistic quantum frequency shifts</option>
                        <option value="feynman_diagram">Feynman Propagator - Particle interaction frequency mapping
                        </option>
                    </optgroup>
                </select>

                <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="powerSlider">Amount: <span class="value-display"
                                id="powerValue">1.000</span></label>
                        <div class="dual-slider-container modulation-disabled">
                            <input type="range" id="powerSlider" class="main-slider" min="0.1" max="20.0" step="0.001"
                                value="1.0">
                            <div class="slider-track"></div>
                            <input type="range" id="modMinSlider" class="dual-handle green-handle" min="0.1" max="20.0"
                                step="0.001" value="0.1">
                            <input type="range" id="modMaxSlider" class="dual-handle red-handle" min="0.1" max="20.0"
                                step="0.001" value="1.0">
                            <div class="modulation-range-display">
                                Mod Range: <span id="modRangeValue">0.100 → 1.000</span>
                            </div>
                            <div class="pulse-indicator"></div>
                        </div>
                        <div class="slider-info">
                            <span>0.1</span>
                            <span>10.0</span>
                            <span>20.0</span>
                        </div>
                    </div>
                    <div class="compact-control">
                        <label for="modPeriodSlider">Modulate (<span id="modStatus">Off</span>): <span
                                class="value-display" id="modPeriodValue">5.0s</span></label>
                        <input type="range" id="modPeriodSlider" min="0" max="2" step="0.01" value="0">
                        <div class="slider-info">
                            <span>Off</span>
                            <span>1min</span>
                            <span>10min</span>
                        </div>
                    </div>
                </div>

                <div class="compact-layout" style="grid-template-columns: 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="gainSlider">Gain: <span class="value-display" id="gainValue">0.0dB</span></label>
                        <input type="range" id="gainSlider" min="-60" max="18" step="0.1" value="0">
                        <div class="slider-info">
                            <span>-∞dB</span>
                            <span>0dB</span>
                            <span>+18dB</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mix & Effects Section -->
            <div class="control-group">
                <h3>🎛️ Mix & Effects</h3>

                <!-- Output Filters -->
                <div class="compact-control">
                    <label for="outputFilterSlider">High/Low Pass: <span class="value-display"
                            id="outputFilterValue">1Hz → 20kHz</span></label>
                    <div class="dual-slider-container">
                        <div class="slider-track"></div>
                        <input type="range" id="outputFilterMinSlider" class="dual-handle green-handle" min="1"
                            max="20000" step="1" value="1">
                        <input type="range" id="outputFilterMaxSlider" class="dual-handle red-handle" min="1"
                            max="20000" step="1" value="20000">
                        <div class="handle-labels">
                            <span class="min-label">Min</span>
                            <span class="max-label">Max</span>
                        </div>
                    </div>
                </div>

                <!-- Transform Mix & Output Gain -->
                <div class="compact-layout" style="grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                    <div class="compact-control">
                        <label for="mixSlider">Transform Mix: <span class="value-display"
                                id="mixValue">100%</span></label>
                        <input type="range" id="mixSlider" min="0" max="100" step="1" value="100">
                        <div class="slider-info">
                            <span>0%</span>
                            <span>50%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    <div class="compact-control">
                        <label for="outputGainSlider">Output Gain: <span class="value-display"
                                id="outputGainValue">0.0dB</span></label>
                        <input type="range" id="outputGainSlider" min="-60" max="18" step="0.1" value="0">
                        <div class="slider-info">
                            <span>-∞dB</span>
                            <span>0dB</span>
                            <span>+18dB</span>
                        </div>
                    </div>
                </div>

                <!-- Delay Effects -->
                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.85em; color: #4ecdc4;">🔄 Delay</h4>
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                        <div class="compact-control">
                            <label for="delayTimeSlider">Time: <span class="value-display"
                                    id="delayTimeValue">0.0s</span></label>
                            <input type="range" id="delayTimeSlider" min="0" max="1000" step="1" value="0">
                            <div class="slider-info">
                                <span>0ms</span>
                                <span>500ms</span>
                                <span>1s</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="delayFeedbackSlider">Feedback: <span class="value-display"
                                    id="delayFeedbackValue">0%</span></label>
                            <input type="range" id="delayFeedbackSlider" min="0" max="95" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>95%</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="delayMixSlider">Mix: <span class="value-display"
                                    id="delayMixValue">0%</span></label>
                            <input type="range" id="delayMixSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 6px;">
                        <label for="delayFilterSlider">Filter: <span class="value-display" id="delayFilterValue">20Hz →
                                20kHz</span></label>
                        <div class="dual-slider-container">
                            <div class="slider-track"></div>
                            <input type="range" id="delayFilterMinSlider" class="dual-handle green-handle" min="20"
                                max="20000" step="10" value="20">
                            <input type="range" id="delayFilterMaxSlider" class="dual-handle red-handle" min="20"
                                max="20000" step="10" value="20000">
                            <div class="handle-labels">
                                <span class="min-label">Min</span>
                                <span class="max-label">Max</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Reverb Effects -->
                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.85em; color: #4ecdc4;">🌊 Reverb</h4>
                    <div class="compact-layout" style="grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                        <div class="compact-control">
                            <label for="reverbRoomSizeSlider">Room: <span class="value-display"
                                    id="reverbRoomSizeValue">0%</span></label>
                            <input type="range" id="reverbRoomSizeSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>Small</span>
                                <span>Medium</span>
                                <span>Large</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="reverbDecaySlider">Decay: <span class="value-display"
                                    id="reverbDecayValue">1.0s</span></label>
                            <input type="range" id="reverbDecaySlider" min="0.1" max="10.0" step="0.1" value="1.0">
                            <div class="slider-info">
                                <span>0.1s</span>
                                <span>5s</span>
                                <span>10s</span>
                            </div>
                        </div>
                        <div class="compact-control">
                            <label for="reverbMixSlider">Mix: <span class="value-display"
                                    id="reverbMixValue">0%</span></label>
                            <input type="range" id="reverbMixSlider" min="0" max="100" step="1" value="0">
                            <div class="slider-info">
                                <span>0%</span>
                                <span>50%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="compact-control" style="margin-top: 6px;">
                        <label for="reverbFilterSlider">Filter: <span class="value-display" id="reverbFilterValue">20Hz
                                → 20kHz</span></label>
                        <div class="dual-slider-container">
                            <div class="slider-track"></div>
                            <input type="range" id="reverbFilterMinSlider" class="dual-handle green-handle" min="20"
                                max="20000" step="10" value="20">
                            <input type="range" id="reverbFilterMaxSlider" class="dual-handle red-handle" min="20"
                                max="20000" step="10" value="20000">
                            <div class="handle-labels">
                                <span class="min-label">Min</span>
                                <span class="max-label">Max</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Audio Visualization -->
        <div class="control-group full-width">
            <h3>📊 Audio Visualization</h3>
            <div class="visualizer">
                <canvas id="visualizerCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>// Ultimate Complex Audio Transformer - Always Real-time with Dual Track System
        let ctx;

        // Dual Track System Variables
        let audioBufferA, audioBufferB;
        let processedBuffer;
        let audioSourceA, audioSourceB;
        let realtimeProcessor;
        let currentSourceA, currentSourceB;
        let isPlayingA = false, isPlayingB = false;
        let isPlaying = false; // For mixed playback state
        let isRealTimeMode = false;
        let selectedFunction = 'power';
        let analyser;
        let canvas;
        let canvasCtx;
        let animationId;
        let scriptProcessor;

        // Track timing and position variables
        let trackPositionA = 0, trackPositionB = 0;
        let trackDurationA = 0, trackDurationB = 0;
        let trackStartTimeA = 0, trackStartTimeB = 0;

        // Time slider drag state tracking
        let timeSliderADragging = false;
        let timeSliderBDragging = false;

        // Crossfader variables
        let crossfaderValue = 50; // 0 = A only, 50 = equal mix, 100 = B only
        let fadeSyncEnabled = false;
        let mixerGainNodeA, mixerGainNodeB, mixerOutputNode;

        // Effects chain nodes
        let delayNode;
        let delayFeedbackNode;
        let delayMixNode;
        let delayWetGainNode;
        let delayDryGainNode;
        let reverbNode;
        let reverbMixNode;
        let reverbWetGainNode;
        let reverbDryGainNode;

        // Output filter nodes
        let lowPassFilter;
        let highPassFilter;

        // Auto gain and output gain nodes
        let finalOutputGainNode;
        let compressorNode; // Auto-limiter

        // LUFS measurement
        let inputLufsAnalyser;
        let outputLufsAnalyser;
        let lufsUpdateInterval;

        // Real-time processing parameters
        let realtimeParams = {
            fftSize: 2048,
            amount: 1.0,
            smoothing: 0.1,
            mix: 1.0,
            gain: 1.0,
            modEnabled: false,   // Whether amount modulation is enabled
            modPeriod: 5.0,      // Modulation period in seconds
            modStartTime: 0,     // Time when modulation started
            modMinAmount: 0.0,   // Minimum modulation amount
            modMaxAmount: 1.0,   // Maximum modulation amount

            // Crossfader parameters
            crossfaderValue: 50,     // 0 = A only, 50 = equal mix, 100 = B only
            fadeSyncEnabled: false,  // Whether effects fade with crossfader mix
            crossfaderGainA: 0.5,    // Calculated gain for track A
            crossfaderGainB: 0.5,    // Calculated gain for track B

            // FadeSync maximum values (captured when FadeSync is enabled)
            fadeSyncMaxTransformMix: 1.0,  // Maximum transform mix for FadeSync
            fadeSyncMaxDelayMix: 1.0,      // Maximum delay mix for FadeSync  
            fadeSyncMaxReverbMix: 1.0,     // Maximum reverb mix for FadeSync

            // Output filter parameters
            lowPassFreq: 20000,  // Low pass filter frequency in Hz
            highPassFreq: 1,     // High pass filter frequency in Hz (start at 1Hz)

            // Delay parameters
            delayTime: 0.0,      // Delay time in seconds
            delayFeedback: 0.0,  // Feedback amount (0-0.95)
            delayMix: 0.0,       // Delay mix (0-1)
            delayLowCut: 20.0,   // Delay low cut frequency in Hz
            delayHighCut: 20000.0, // Delay high cut frequency in Hz

            // Reverb parameters
            reverbRoomSize: 0.0, // Room size (0-1)
            reverbDecay: 1.0,    // Decay time in seconds
            reverbMix: 0.0,      // Reverb mix (0-1)
            reverbLowCut: 20.0,  // Reverb low cut frequency in Hz
            reverbHighCut: 20000.0, // Reverb high cut frequency in Hz

            // Auto gain compensation and output
            outputGainDb: 0.0,     // Output gain in dB (-∞ to +18)
            finalOutputGain: 1.0   // Final output gain
        };

        // Memory management pool
        let memoryPool = {
            realBuffers: [],
            imagBuffers: [],
            windowBuffers: new Map(),
            fftBuffers: []
        };

        // Complex function definitions with complete implementations
        const complexFunctions = {
            // === BASIC MATHEMATICAL OPERATIONS ===
            'power': { name: 'Power (f^n)', desc: 'Frequency stretching/compression' },
            'sqrt': { name: '√z', desc: 'Square root expansion' },
            'cbrt': { name: '∛z', desc: 'Cube root expansion' },
            'nroot': { name: 'ⁿ√z', desc: 'N-th root (power-controlled)' },
            'square': { name: 'z²', desc: 'Square compression' },
            'cube': { name: 'z³', desc: 'Cube transformation' },
            'quartic': { name: 'z⁴', desc: 'Fourth power' },
            'quintic': { name: 'z⁵', desc: 'Fifth power' },
            'inverse': { name: '1/z', desc: 'Reciprocal inversion' },

            // === LOGARITHMIC & EXPONENTIAL ===
            'log': { name: 'ln(z)', desc: 'Natural logarithm' },
            'log10': { name: 'log₁₀(z)', desc: 'Base-10 logarithm' },
            'log2': { name: 'log₂(z)', desc: 'Base-2 logarithm' },
            'exp': { name: 'e^z', desc: 'Natural exponential' },
            'exp2': { name: '2^z', desc: 'Base-2 exponential' },
            'exp10': { name: '10^z', desc: 'Base-10 exponential' },

            // === TRIGONOMETRIC FUNCTIONS ===
            'sin': { name: 'sin(z)', desc: 'Sine wave warping' },
            'cos': { name: 'cos(z)', desc: 'Cosine wave warping' },
            'tan': { name: 'tan(z)', desc: 'Tangent sharp bending' },
            'csc': { name: 'csc(z)', desc: 'Cosecant (1/sin)' },
            'sec': { name: 'sec(z)', desc: 'Secant (1/cos)' },
            'cot': { name: 'cot(z)', desc: 'Cotangent (1/tan)' },

            // === INVERSE TRIGONOMETRIC ===
            'asin': { name: 'arcsin(z)', desc: 'Inverse sine mapping' },
            'acos': { name: 'arccos(z)', desc: 'Inverse cosine mapping' },
            'atan': { name: 'arctan(z)', desc: 'S-curve frequency mapping' },
            'atan2': { name: 'atan2(y,x)', desc: 'Two-argument arctangent' },

            // === HYPERBOLIC FUNCTIONS (FIXED) ===
            'sinh': { name: 'sinh(z)', desc: 'Hyperbolic sine growth' },
            'cosh': { name: 'cosh(z)', desc: 'Hyperbolic cosine catenary' },
            'tanh': { name: 'tanh(z)', desc: 'Hyperbolic tangent saturation' },
            'csch': { name: 'csch(z)', desc: 'Hyperbolic cosecant' },
            'sech': { name: 'sech(z)', desc: 'Hyperbolic secant' },
            'coth': { name: 'coth(z)', desc: 'Hyperbolic cotangent' },

            // === INVERSE HYPERBOLIC ===
            'asinh': { name: 'asinh(z)', desc: 'Inverse hyperbolic sine' },
            'acosh': { name: 'acosh(z)', desc: 'Inverse hyperbolic cosine' },
            'atanh': { name: 'atanh(z)', desc: 'Inverse hyperbolic tangent' },

            // === COMPLEX NUMBER OPERATIONS ===
            'complex_magnitude': { name: '|z|', desc: 'Distance from origin' },
            'complex_phase': { name: 'arg(z)', desc: 'Angle transformation' },
            'conjugate': { name: 'z*', desc: 'Complex conjugate mirror' },
            'reciprocal': { name: '1/z', desc: 'Complex reciprocal' },
            'abs_square': { name: '|z|²', desc: 'Squared magnitude' },

            // === FAMOUS PHYSICS EQUATIONS ===
            'schrodinger': { name: 'Schrödinger Ψ', desc: 'Quantum wave function' },
            'heisenberg': { name: 'Heisenberg Δx·Δp', desc: 'Uncertainty principle' },
            'einstein_mass_energy': { name: 'E=mc²', desc: 'Mass-energy equivalence' },
            'planck_radiation': { name: 'Planck B(ν,T)', desc: 'Blackbody radiation' },
            'maxwell_boltzmann': { name: 'Maxwell-Boltzmann', desc: 'Velocity distribution' },
            'wave_equation': { name: 'Wave ∂²u/∂t²', desc: 'String vibrations' },
            'heat_equation': { name: 'Heat ∂u/∂t', desc: 'Thermal diffusion' },
            'lorentz_factor': { name: 'Lorentz γ', desc: 'Relativistic factor' },
            'schwarzschild': { name: 'Schwarzschild r_s', desc: 'Black hole radius' },
            'compton_scattering': { name: 'Compton Δλ', desc: 'Photon scattering' },

            // === SPECIAL FUNCTIONS ===
            'gamma': { name: 'Γ(z)', desc: 'Gamma function' },
            'factorial': { name: 'z!', desc: 'Factorial function' },
            'zeta': { name: 'ζ(z)', desc: 'Riemann zeta function' },
            'eta': { name: 'η(z)', desc: 'Dirichlet eta function' },
            'bessel_j0': { name: 'J₀(z)', desc: 'Bessel function of 1st kind' },
            'bessel_y0': { name: 'Y₀(z)', desc: 'Bessel function of 2nd kind' },
            'bessel_i0': { name: 'I₀(z)', desc: 'Modified Bessel function' },
            'bessel_k0': { name: 'K₀(z)', desc: 'Modified Bessel function 2nd' },
            'airy_ai': { name: 'Ai(z)', desc: 'Airy function Ai' },
            'airy_bi': { name: 'Bi(z)', desc: 'Airy function Bi' },
            'erf': { name: 'erf(z)', desc: 'Error function' },
            'erfc': { name: 'erfc(z)', desc: 'Complementary error function' },

            // === GEOMETRIC TRANSFORMATIONS ===
            'mobius': { name: 'Möbius (az+b)/(cz+d)', desc: 'Conformal mapping' },
            'joukowsky': { name: 'Joukowsky z+1/z', desc: 'Airfoil transformation' },
            'schwarz_christoffel': { name: 'Schwarz-Christoffel', desc: 'Polygon mapping' },
            'cayley': { name: 'Cayley (z-i)/(z+i)', desc: 'Disk to half-plane' },

            // === SPIRAL TRANSFORMATIONS ===
            'spiral': { name: 'Log Spiral', desc: 'Logarithmic spiral' },
            'fibonacci_spiral': { name: 'Fibonacci Spiral', desc: 'Golden ratio spiral' },
            'archimedean_spiral': { name: 'Archimedean rθ', desc: 'Linear spiral' },
            'fermat_spiral': { name: 'Fermat r²=aθ', desc: 'Parabolic spiral' },
            'hyperbolic_spiral': { name: 'Hyperbolic r=a/θ', desc: 'Reciprocal spiral' },
            'ulam_spiral': { name: 'Ulam Spiral', desc: 'Prime number spiral' },

            // === FRACTAL FUNCTIONS ===
            'mandelbrot': { name: 'Mandelbrot z²+c', desc: 'Classic fractal' },
            'julia': { name: 'Julia Set', desc: 'Julia set fractal' },
            'burning_ship': { name: 'Burning Ship |z|²+c', desc: 'Absolute value fractal' },
            'tricorn': { name: 'Tricorn z̄²+c', desc: 'Conjugate fractal' },
            'multibrot': { name: 'Multibrot z^n+c', desc: 'Generalized Mandelbrot' },
            'newton_raphson': { name: 'Newton z³-1', desc: 'Newton fractal' },
            'nova': { name: 'Nova Fractal', desc: 'Newton-style fractal' },
            'phoenix': { name: 'Phoenix z²+c+b', desc: 'Phoenix fractal' },
            'magnet': { name: 'Magnet (z²+c-1)²', desc: 'Magnet fractal' },
            'lambda': { name: 'Lambda λz(1-z)', desc: 'Lambda fractal' },
            'spider': { name: 'Spider z²+c/z', desc: 'Spider fractal' },
            'henon_map': { name: 'Hénon Map', desc: '2D chaotic attractor' },
            'lorenz_attractor': { name: 'Lorenz Attractor', desc: 'Butterfly effect chaos' },
            'logistic_map': { name: 'Logistic rx(1-x)', desc: 'Period-doubling chaos' },
            'tent_map': { name: 'Tent Map', desc: 'Piecewise linear chaos' },

            // === WAVE FUNCTIONS ===
            'wave': { name: 'Wave Interference', desc: 'Constructive/destructive' },
            'ripple': { name: 'Ripple Effect', desc: 'Concentric waves' },
            'standing_wave': { name: 'Standing Wave', desc: 'Node/antinode pattern' },
            'beat_frequency': { name: 'Beat Frequency', desc: 'Amplitude modulation' },
            'doppler_effect': { name: 'Doppler f(1±v/c)', desc: 'Moving source shift' },
            'gaussian_wave': { name: 'Gaussian Wave', desc: 'Bell curve packet' },
            'sinc_function': { name: 'Sinc sin(x)/x', desc: 'Cardinal sine' },
            'chirp': { name: 'Chirp f(t)', desc: 'Frequency sweep' },
            'morlet_wavelet': { name: 'Morlet Wavelet', desc: 'Gaussian windowed sine' },
            'mexican_hat': { name: 'Mexican Hat', desc: 'Ricker wavelet' },

            // === SPECIAL PATTERNS ===
            'dirac_delta': { name: 'Dirac δ(x)', desc: 'Impulse function' },
            'heaviside_step': { name: 'Heaviside H(x)', desc: 'Unit step function' },
            'sawtooth': { name: 'Sawtooth Wave', desc: 'Linear ramp' },
            'square_wave': { name: 'Square Wave', desc: 'Binary switching' },
            'triangle_wave': { name: 'Triangle Wave', desc: 'Triangular oscillation' },
            'pulse_train': { name: 'Pulse Train', desc: 'Periodic impulses' },

            // === STEREO PANNING EFFECTS ===
            'stereo_real_imag': { name: '🎧 Real/Imaginary Split', desc: 'Real→Left, Imag→Right' },
            'stereo_mag_phase': { name: '🎧 Magnitude/Phase Split', desc: 'Mag→Left, Phase→Right' },
            'stereo_rotation': { name: '🎧 Complex Rotation', desc: 'Rotating panning field' },
            'stereo_spiral_pan': { name: '🎧 Spiral Panning', desc: 'Frequency-dependent pan' },
            'stereo_doppler_pan': { name: '🎧 Doppler Panning', desc: 'Moving source simulation' },
            'stereo_binaural': { name: '🎧 Binaural Beats', desc: 'Frequency difference beats' },

            // === QUANTUM & EXOTIC ===
            'quantum_harmonic': { name: 'Quantum Harmonic', desc: 'QHO wave functions' },
            'hydrogen_orbital': { name: 'Hydrogen Orbital', desc: 'Atomic wave functions' },
            'tunneling_effect': { name: 'Quantum Tunneling', desc: 'Barrier penetration' },
            'klein_gordon': { name: 'Klein-Gordon', desc: 'Relativistic wave equation' },
            'dirac_equation': { name: 'Dirac Equation', desc: 'Relativistic electron' },
            'feynman_diagram': { name: 'Feynman Propagator', desc: 'Particle interactions' }
        };

        // Memory management functions
        function getBuffer(size, type = 'real') {
            // Ensure memoryPool exists
            if (!memoryPool) {
                memoryPool = {
                    realBuffers: [],
                    imagBuffers: [],
                    windowBuffers: new Map(),
                    fftBuffers: []
                };
            }

            const pool = type === 'real' ? memoryPool.realBuffers : memoryPool.imagBuffers;
            if (!pool) {
                console.warn(`Memory pool for type '${type}' is undefined, creating new array`);
                if (type === 'real') {
                    memoryPool.realBuffers = [];
                    return new Float32Array(size);
                } else {
                    memoryPool.imagBuffers = [];
                    return new Float32Array(size);
                }
            }

            let buffer = pool.find(b => b && b.length >= size);
            if (!buffer) {
                buffer = new Float32Array(size);
                pool.push(buffer);
            }
            return buffer.subarray(0, size);
        }

        function getWindow(size) {
            // Ensure memoryPool exists
            if (!memoryPool || !memoryPool.windowBuffers) {
                if (!memoryPool) {
                    memoryPool = {
                        realBuffers: [],
                        imagBuffers: [],
                        windowBuffers: new Map(),
                        fftBuffers: []
                    };
                } else if (!memoryPool.windowBuffers) {
                    memoryPool.windowBuffers = new Map();
                }
            }

            if (!memoryPool.windowBuffers.has(size)) {
                const window = new Float32Array(size);
                // Hann window
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                memoryPool.windowBuffers.set(size, window);
            }
            return memoryPool.windowBuffers.get(size);
        }

        function updateMemoryInfo() {
            try {
                // Ensure memoryPool exists and has required properties
                if (!memoryPool) {
                    console.warn('memoryPool is undefined, reinitializing...');
                    memoryPool = {
                        realBuffers: [],
                        imagBuffers: [],
                        windowBuffers: new Map(),
                        fftBuffers: []
                    };
                }

                // Ensure each property exists
                if (!memoryPool.realBuffers) memoryPool.realBuffers = [];
                if (!memoryPool.imagBuffers) memoryPool.imagBuffers = [];
                if (!memoryPool.windowBuffers) memoryPool.windowBuffers = new Map();
                if (!memoryPool.fftBuffers) memoryPool.fftBuffers = [];

                const realCount = memoryPool.realBuffers.length;
                const imagCount = memoryPool.imagBuffers.length;
                const windowCount = memoryPool.windowBuffers.size;
                const fftCount = memoryPool.fftBuffers.length;

                const memoryInfoElement = document.getElementById('memoryInfo');
                if (memoryInfoElement) {
                    const outputGainStatus = realtimeParams.outputGainDb === -Infinity ?
                        'Output: -∞dB' : `Output: ${realtimeParams.outputGainDb >= 0 ? '+' : ''}${realtimeParams.outputGainDb.toFixed(1)}dB`;
                    memoryInfoElement.textContent =
                        `Memory Pool: ${realCount} real, ${imagCount} imag, ${windowCount} window, ${fftCount} FFT buffers | ${outputGainStatus}`;
                }
            } catch (error) {
                console.error('Error in updateMemoryInfo:', error);
                // Don't throw the error, just log it to prevent breaking the audio processing
            }
        }

        // Audio context initialization
        async function initAudioContext() {
            try {
                if (!ctx) {
                    ctx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio context created');
                }

                if (ctx.state === 'suspended') {
                    console.log('Audio context suspended, attempting to resume...');
                    await ctx.resume();
                    console.log('Audio context resumed successfully');
                }

                console.log(`Audio context state: ${ctx.state}, sample rate: ${ctx.sampleRate}`);
                return ctx;

            } catch (error) {
                console.error('Failed to initialize audio context:', error);
                showStatus(`Audio context error: ${error.message}. Try clicking a button first.`, 'error');
                throw error;
            }
        }

        // Status display
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = type;
            console.log(`[${type}] ${message}`);
        }

        // Real-time Audio Processor with large buffer for smooth processing
        class RealtimeAudioProcessor {
            constructor(audioContext, bufferDuration = 3.0) {
                this.audioContext = audioContext;
                this.sampleRate = audioContext.sampleRate;
                this.bufferDuration = bufferDuration;

                // Use larger buffer size for smoother processing
                this.bufferSize = 8192; // Larger ScriptProcessorNode buffer

                // Large circular buffer for smooth processing (3+ seconds)
                this.circularBufferSize = Math.ceil(this.sampleRate * bufferDuration);
                this.inputCircularBuffer = new Float32Array(this.circularBufferSize);
                this.outputCircularBuffer = new Float32Array(this.circularBufferSize);

                // Buffer pointers
                this.writePtr = 0;
                this.readPtr = 0;
                this.bufferFilled = false;

                // Initialize with 3 second latency for smooth processing
                this.latencyBufferSize = Math.floor(this.sampleRate * 1.5); // 1.5 second initial latency
                this.readPtr = this.circularBufferSize - this.latencyBufferSize;

                console.log(`Initialized large buffer: ${this.circularBufferSize} samples (${(this.circularBufferSize / this.sampleRate).toFixed(2)}s) at ${this.sampleRate}Hz`);

                // Processing parameters
                this.params = {
                    function: 'power',
                    amount: 1.0,
                    smoothing: 0.1,
                    mix: 1.0,
                    gain: 1.0
                };

                // FFT setup for real-time processing
                this.fftSize = 2048;
                this.windowFunc = this.createWindow(this.fftSize);

                // Processing state
                this.lastSample = 0;
                this.processCounter = 0;

                // Create ScriptProcessorNode with larger buffer
                this.processor = audioContext.createScriptProcessor(this.bufferSize, 1, 1);
                this.processor.onaudioprocess = this.processAudio.bind(this);

                // Gain node for output control
                this.gainNode = audioContext.createGain();
                this.processor.connect(this.gainNode);

                console.log(`RealtimeAudioProcessor initialized with ${this.bufferSize} sample buffer and ${(this.circularBufferSize / this.sampleRate).toFixed(2)}s circular buffer`);
            }

            createWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                return window;
            }

            updateParams(newParams) {
                // Update parameters safely
                Object.assign(this.params, newParams);
                this.gainNode.gain.value = this.params.gain;

                // Update FFT size if changed
                if (newParams.fftSize && newParams.fftSize !== this.fftSize) {
                    this.fftSize = newParams.fftSize;
                    this.windowFunc = this.createWindow(this.fftSize);
                    this.lastSample = 0;
                    console.log(`FFT size updated to ${this.fftSize}`);
                }

                // Log parameter updates for debugging
                if (this.processCounter % 50 === 0) {
                    console.log('Updated params:', {
                        function: this.params.function,
                        amount: this.params.amount,
                        mix: this.params.mix,
                        fftSize: this.fftSize
                    });
                }
            }

            processAudio(event) {
                const inputData = event.inputBuffer.getChannelData(0);
                const outputData = event.outputBuffer.getChannelData(0);
                const bufferLength = inputData.length;

                // Write input data to circular buffer
                for (let i = 0; i < bufferLength; i++) {
                    this.inputCircularBuffer[this.writePtr] = inputData[i];
                    this.writePtr = (this.writePtr + 1) % this.circularBufferSize;
                }

                // Simple direct processing to avoid circular buffer complexity
                // Process the current input buffer directly with proper windowing

                if (bufferLength >= this.fftSize) {
                    // Process in overlapping windows
                    const hopSize = this.fftSize / 4; // 75% overlap for very smooth processing
                    const tempOutput = new Float32Array(bufferLength);
                    tempOutput.fill(0); // Initialize to zero for overlap-add

                    for (let windowStart = 0; windowStart < bufferLength - this.fftSize + hopSize; windowStart += hopSize) {
                        const windowEnd = Math.min(windowStart + this.fftSize, bufferLength);
                        const actualWindowSize = windowEnd - windowStart;

                        if (actualWindowSize < this.fftSize / 2) continue; // Skip tiny windows

                        // Extract window
                        const windowBuffer = new Float32Array(this.fftSize);
                        windowBuffer.fill(0);

                        for (let i = 0; i < actualWindowSize; i++) {
                            windowBuffer[i] = inputData[windowStart + i];
                        }

                        // Process window
                        const processedWindow = this.processChunk(windowBuffer);

                        // Overlap-add to output with proper scaling
                        const overlapScale = 1.0 / 3.0; // Scale for 75% overlap
                        for (let i = 0; i < actualWindowSize; i++) {
                            if (windowStart + i < bufferLength) {
                                tempOutput[windowStart + i] += processedWindow[i] * overlapScale;
                            }
                        }
                    }

                    // Copy to final output with mixing and gain
                    for (let i = 0; i < bufferLength; i++) {
                        let processedSample = tempOutput[i];

                        // Apply smoothing to reduce artifacts
                        if (this.lastSample !== undefined) {
                            const smoothingAmount = Math.min(0.1, this.params.smoothing);
                            processedSample = smoothingAmount * this.lastSample + (1 - smoothingAmount) * processedSample;
                        }
                        this.lastSample = processedSample;

                        // Apply dry/wet mix
                        const originalSample = inputData[i];
                        let mixedSample = this.params.mix * processedSample + (1 - this.params.mix) * originalSample;

                        // Apply gain with soft limiting
                        mixedSample *= this.params.gain;
                        if (Math.abs(mixedSample) > 0.95) {
                            mixedSample = Math.sign(mixedSample) * (0.95 + 0.05 * Math.tanh((Math.abs(mixedSample) - 0.95) * 10));
                        }

                        outputData[i] = mixedSample;
                    }

                } else {
                    // Buffer smaller than FFT size - simple processing
                    const paddedBuffer = new Float32Array(this.fftSize);
                    paddedBuffer.fill(0);

                    for (let i = 0; i < bufferLength; i++) {
                        paddedBuffer[i] = inputData[i];
                    }

                    const processedBuffer = this.processChunk(paddedBuffer);

                    for (let i = 0; i < bufferLength; i++) {
                        let processedSample = processedBuffer[i];

                        // Apply smoothing
                        if (this.lastSample !== undefined) {
                            const smoothingAmount = Math.min(0.1, this.params.smoothing);
                            processedSample = smoothingAmount * this.lastSample + (1 - smoothingAmount) * processedSample;
                        }
                        this.lastSample = processedSample;

                        // Apply mix and gain
                        const originalSample = inputData[i];
                        let mixedSample = this.params.mix * processedSample + (1 - this.params.mix) * originalSample;

                        mixedSample *= this.params.gain;
                        if (Math.abs(mixedSample) > 0.95) {
                            mixedSample = Math.sign(mixedSample) * (0.95 + 0.05 * Math.tanh((Math.abs(mixedSample) - 0.95) * 10));
                        }

                        outputData[i] = mixedSample;
                    }
                }

                // Update processing counter for diagnostics
                this.processCounter++;
                if (this.processCounter % 200 === 0) {
                    const bufferFillPercent = (this.getAvailableData() / this.circularBufferSize * 100).toFixed(1);
                    console.log(`Processing stable - Buffer: ${bufferFillPercent}%`);
                }
            }

            // Helper method to get available data in circular buffer
            getAvailableData() {
                if (this.writePtr >= this.readPtr) {
                    return this.writePtr - this.readPtr;
                } else {
                    return this.circularBufferSize - this.readPtr + this.writePtr;
                }
            }

            // Process a single chunk through FFT
            processChunk(inputChunk) {
                const real = new Float32Array(this.fftSize);
                const imag = new Float32Array(this.fftSize);

                // Copy input with windowing
                for (let i = 0; i < Math.min(inputChunk.length, this.fftSize); i++) {
                    real[i] = inputChunk[i] * this.windowFunc[i];
                    imag[i] = 0;
                }

                // Forward FFT
                fft(real, imag);

                // Apply frequency domain transformation
                try {
                    applyComplexFunction(real, imag, this.fftSize, this.sampleRate, this.params.function, this.params.amount, this.params);
                } catch (error) {
                    console.warn('Frequency transformation error:', error);
                }

                // Inverse FFT
                ifft(real, imag);

                // Apply windowing again and return
                const output = new Float32Array(this.fftSize);
                for (let i = 0; i < this.fftSize; i++) {
                    output[i] = real[i] * this.windowFunc[i];
                }

                return output;
            }

            connect(destination) {
                this.gainNode.connect(destination);
                return this.processor;
            }

            disconnect() {
                if (this.processor) {
                    this.processor.disconnect();
                }
                if (this.gainNode) {
                    this.gainNode.disconnect();
                }
            }
        }

        // Create delay effect
        function createDelayEffect() {
            if (!ctx) return null;

            try {
                // Create delay line
                const maxDelayTime = 1.0; // 1 second maximum
                const delay = ctx.createDelay(maxDelayTime);
                delay.delayTime.setValueAtTime(realtimeParams.delayTime, ctx.currentTime);

                // Create feedback gain
                const feedback = ctx.createGain();
                feedback.gain.setValueAtTime(realtimeParams.delayFeedback, ctx.currentTime);

                // Create wet/dry mix
                const wetGain = ctx.createGain();
                const dryGain = ctx.createGain();
                const outputGain = ctx.createGain();

                wetGain.gain.setValueAtTime(realtimeParams.delayMix, ctx.currentTime);
                dryGain.gain.setValueAtTime(1.0 - realtimeParams.delayMix, ctx.currentTime);

                // Connect delay feedback loop
                delay.connect(feedback);
                feedback.connect(delay);

                // Connect wet/dry mix
                delay.connect(wetGain);
                wetGain.connect(outputGain);
                dryGain.connect(outputGain);

                return {
                    input: delay,
                    inputDry: dryGain,
                    output: outputGain,
                    delayNode: delay,
                    feedbackNode: feedback,
                    wetGainNode: wetGain,
                    dryGainNode: dryGain
                };
            } catch (error) {
                console.error('Error creating delay effect:', error);
                return null;
            }
        }

        // Create reverb effect using convolution
        function createReverbEffect() {
            if (!ctx) return null;

            try {
                // Create convolver for reverb
                const convolver = ctx.createConvolver();

                // Generate impulse response for reverb
                const sampleRate = ctx.sampleRate;
                const decayTime = realtimeParams.reverbDecay;
                const roomSize = realtimeParams.reverbRoomSize;
                const length = Math.min(sampleRate * decayTime, sampleRate * 4); // Max 4 seconds

                const impulse = ctx.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;

                        // Exponential decay
                        const decay = Math.exp(-4 * t / decayTime);

                        // Room characteristics
                        const roomFactor = 0.05 + roomSize * 0.95;

                        // Early reflections (first 80ms)
                        let sample = 0;
                        if (t < 0.08) {
                            const reflectionDensity = roomFactor * 20;
                            const numReflections = Math.floor(reflectionDensity * t);
                            for (let r = 0; r < numReflections; r++) {
                                const reflectionTime = Math.random() * t;
                                const reflectionDecay = Math.exp(-reflectionTime / 0.02);
                                const reflectionAmp = (Math.random() - 0.5) * 0.1 * reflectionDecay;
                                sample += reflectionAmp;
                            }
                        }

                        // Late reverb (dense, decorrelated)
                        const lateReverb = (Math.random() - 0.5) * 2 * decay * roomFactor;

                        // High frequency rolloff
                        const hfRolloff = Math.exp(-t * 2);

                        // Combine components
                        const totalSample = (sample + lateReverb) * hfRolloff;

                        // Stereo decorrelation
                        channelData[i] = totalSample * (channel === 0 ? 1 : 0.7 + Math.random() * 0.3);
                    }
                }

                convolver.buffer = impulse;

                // Create wet/dry mix
                const wetGain = ctx.createGain();
                const dryGain = ctx.createGain();
                const outputGain = ctx.createGain();

                wetGain.gain.setValueAtTime(realtimeParams.reverbMix, ctx.currentTime);
                dryGain.gain.setValueAtTime(1.0 - realtimeParams.reverbMix, ctx.currentTime);

                // Connect reverb chain
                convolver.connect(wetGain);
                wetGain.connect(outputGain);
                dryGain.connect(outputGain);

                return {
                    input: convolver,
                    inputDry: dryGain,
                    output: outputGain,
                    reverbNode: convolver,
                    wetGainNode: wetGain,
                    dryGainNode: dryGain
                };
            } catch (error) {
                console.error('Error creating reverb effect:', error);
                return null;
            }
        }

        // Function to recreate reverb impulse response when parameters change
        function recreateReverbImpulse() {
            if (!ctx || !reverbNode) return;

            try {
                // Generate new impulse response with current parameters
                const sampleRate = ctx.sampleRate;
                const decayTime = realtimeParams.reverbDecay;
                const roomSize = realtimeParams.reverbRoomSize;
                const length = Math.min(sampleRate * decayTime, sampleRate * 4); // Max 4 seconds

                const impulse = ctx.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;

                        // Exponential decay
                        const decay = Math.exp(-4 * t / decayTime);

                        // Room characteristics
                        const roomFactor = 0.05 + roomSize * 0.95;

                        // Early reflections (first 80ms)
                        let sample = 0;
                        if (t < 0.08) {
                            const reflectionDensity = roomFactor * 20;
                            const numReflections = Math.floor(reflectionDensity * t);
                            for (let r = 0; r < numReflections; r++) {
                                const reflectionTime = Math.random() * t;
                                const reflectionDecay = Math.exp(-reflectionTime / 0.02);
                                const reflectionAmp = (Math.random() - 0.5) * 0.1 * reflectionDecay;
                                sample += reflectionAmp;
                            }
                        }

                        // Late reverb (dense, decorrelated)
                        const lateReverb = (Math.random() - 0.5) * 2 * decay * roomFactor;

                        // High frequency rolloff
                        const hfRolloff = Math.exp(-t * 2);

                        // Combine components
                        const totalSample = (sample + lateReverb) * hfRolloff;

                        // Stereo decorrelation
                        channelData[i] = totalSample * (channel === 0 ? 1 : 0.7 + Math.random() * 0.3);
                    }
                }

                // Update the reverb node's buffer
                reverbNode.buffer = impulse;

                showStatus(`Reverb updated: ${realtimeParams.reverbDecay.toFixed(1)}s decay, ${Math.round(realtimeParams.reverbRoomSize * 100)}% room size`, 'info');

            } catch (error) {
                console.error('Error recreating reverb impulse:', error);
                showStatus('Error updating reverb parameters', 'error');
            }
        }

        // RMS calculation for auto gain compensation (simpler than LUFS)
        function calculateRMS(analyser) {
            if (!analyser) return 0.0;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatFrequencyData(dataArray);

            // Calculate RMS from frequency domain data
            let sum = 0;
            let count = 0;

            for (let i = 1; i < bufferLength; i++) { // Skip DC
                if (dataArray[i] > -120) { // Only count significant energy
                    const linearPower = Math.pow(10, dataArray[i] / 10);
                    sum += linearPower;
                    count++;
                }
            }

            if (count === 0) return 0.0;

            const rms = Math.sqrt(sum / count);
            return rms;
        }

        // Update RMS measurements and auto gain
        function updateLUFSMeasurements() {
            if (!inputLufsAnalyser || !outputLufsAnalyser) return;

            const inputRMS = calculateRMS(inputLufsAnalyser);
            const outputRMS = calculateRMS(outputLufsAnalyser);

            // Update display if elements exist (optional UI elements)
            const inputLufsElement = document.getElementById('inputLufs');
            const outputLufsElement = document.getElementById('outputLufs');
            if (inputLufsElement) inputLufsElement.textContent = (20 * Math.log10(inputRMS + 1e-12)).toFixed(1) + ' dB';
            if (outputLufsElement) outputLufsElement.textContent = (20 * Math.log10(outputRMS + 1e-12)).toFixed(1) + ' dB';

            // Auto gain compensation removed - no autoGainNode needed
            updateMemoryInfo(); // Update UI
        }

        // Complex function applications with proper frequency transformations
        function applyComplexFunction(real, imag, fftSize, sampleRate, funcName, amount = 1.0, params = null) {
            try {
                // Use passed params or fall back to global realtimeParams
                const currentParams = params || realtimeParams;

                const nyquist = sampleRate / 2;
                const binSize = sampleRate / fftSize;

                // Frequency range limits - permanently set to unlimited
                const minFreq = 0;
                const maxFreq = nyquist * 2; // Allow frequencies up to 2x Nyquist to trigger wrapping

                // Create temporary arrays for frequency remapping
                const tempReal = new Float32Array(fftSize);
                const tempImag = new Float32Array(fftSize);

                // Copy original spectrum
                for (let i = 0; i < fftSize; i++) {
                    tempReal[i] = real[i];
                    tempImag[i] = imag[i];
                }

                // Clear output arrays
                real.fill(0);
                imag.fill(0);

                // Process only positive frequencies (first half of spectrum)
                for (let i = 1; i < fftSize / 2; i++) {
                    const frequency = i * binSize;

                    // Skip frequencies outside range based on current settings
                    if (frequency < minFreq || frequency > maxFreq) continue;

                    // Normalize frequency to 0-1 within selected range
                    let normalizedFreq = (frequency - minFreq) / (maxFreq - minFreq);

                    // Get magnitude and phase from original spectrum
                    const magnitude = Math.sqrt(tempReal[i] * tempReal[i] + tempImag[i] * tempImag[i]);
                    const phase = Math.atan2(tempImag[i], tempReal[i]);

                    if (magnitude < 1e-12) continue; // Skip silent bins

                    let mappedFreq = normalizedFreq; // Default: no change
                    let magnitudeMultiplier = 1.0;
                    let phaseShift = 0;

                    // Apply dramatic frequency transformations based on function type
                    // All functions use 'amount' parameter to control intensity (0-10 typical range)
                    switch (funcName) {
                        // === BASIC OPERATIONS ===
                        case 'power':
                            // Frequency stretching/compression: amount controls exponent (0.1 to 5.0)
                            const exponent = 0.1 + (amount * 0.5);
                            mappedFreq = Math.pow(normalizedFreq, exponent);
                            break;

                        case 'sqrt':
                            // Square root expansion: spreads low frequencies
                            mappedFreq = Math.pow(normalizedFreq, 0.5 - amount * 0.03);
                            break;

                        case 'cbrt':
                            // Cube root: even more expansion
                            mappedFreq = Math.pow(normalizedFreq, 0.33 - amount * 0.02);
                            break;

                        case 'nroot':
                            // N-th root: amount controls root (1-20)
                            const rootPower = 1 + amount;
                            mappedFreq = Math.pow(normalizedFreq, 1 / rootPower);
                            break;

                        case 'square':
                            // Square compression: compresses to higher frequencies
                            mappedFreq = Math.pow(normalizedFreq, 2 + amount * 0.5);
                            break;

                        case 'cube':
                            // Cube: severe compression
                            mappedFreq = Math.pow(normalizedFreq, 3 + amount);
                            break;

                        case 'inverse':
                            // Frequency inversion with scaling
                            mappedFreq = 1 - normalizedFreq * (1 - amount * 0.1);
                            magnitudeMultiplier = 1 + amount * 0.3;
                            break;

                        // === LOGARITHMIC & EXPONENTIAL ===
                        case 'log':
                            // Logarithmic stretching: expands low frequencies dramatically
                            mappedFreq = Math.log(1 + normalizedFreq * (Math.E - 1) * amount) / amount;
                            break;

                        case 'log10':
                            // Base-10 log: different curve shape
                            mappedFreq = Math.log10(1 + normalizedFreq * 9 * amount) / Math.log10(1 + 9 * amount);
                            break;

                        case 'log2':
                            // Base-2 log: computer-friendly stretching
                            mappedFreq = Math.log2(1 + normalizedFreq * 3 * amount) / Math.log2(1 + 3 * amount);
                            break;

                        case 'exp':
                            // Exponential compression: compresses to high frequencies
                            mappedFreq = (Math.exp(normalizedFreq * amount) - 1) / (Math.exp(amount) - 1);
                            break;

                        case 'exp2':
                            // Base-2 exponential: sharp compression
                            mappedFreq = (Math.pow(2, normalizedFreq * amount) - 1) / (Math.pow(2, amount) - 1);
                            break;

                        case 'exp10':
                            // Base-10 exponential: extreme compression
                            mappedFreq = (Math.pow(10, normalizedFreq * amount * 0.5) - 1) / (Math.pow(10, amount * 0.5) - 1);
                            break;

                        // === TRIGONOMETRIC FUNCTIONS ===
                        case 'sin':
                            // Sine wave warping: creates multiple bands
                            mappedFreq = (1 + Math.sin((normalizedFreq * Math.PI * 2 * amount) - Math.PI / 2)) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.sin(normalizedFreq * Math.PI * amount);
                            phaseShift = Math.sin(normalizedFreq * Math.PI * amount) * 0.5;
                            break;

                        case 'cos':
                            // Cosine wave warping: different phase than sine
                            mappedFreq = (1 + Math.cos(normalizedFreq * Math.PI * amount)) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.cos(normalizedFreq * Math.PI * amount);
                            break;

                        case 'tan':
                            // Tangent: creates sharp frequency bands
                            const tanInput = (normalizedFreq - 0.5) * Math.PI * 0.8 * amount;
                            mappedFreq = (Math.atan(Math.tan(tanInput)) / (Math.PI * 0.8 * amount)) + 0.5;
                            mappedFreq = Math.max(0, Math.min(1, mappedFreq));
                            break;

                        case 'asin':
                            // Arcsine: S-curve stretching
                            const asinInput = (normalizedFreq * 2 - 1) * Math.min(0.99, amount * 0.1);
                            mappedFreq = (Math.asin(asinInput) / Math.asin(Math.min(0.99, amount * 0.1)) + 1) / 2;
                            break;

                        case 'acos':
                            // Arccosine: inverse S-curve
                            const acosInput = Math.min(0.99, amount * 0.1);
                            mappedFreq = Math.acos(normalizedFreq * acosInput) / Math.acos(acosInput);
                            break;

                        case 'atan':
                            // Arctangent: gentle S-curve with amount scaling
                            const atanInput = (normalizedFreq - 0.5) * amount * 2;
                            mappedFreq = (Math.atan(atanInput) / Math.atan(amount * 2)) * 0.5 + 0.5;
                            break;

                        // === HYPERBOLIC FUNCTIONS ===
                        case 'sinh':
                            // Hyperbolic sine: exponential-like growth
                            const sinhInput = (normalizedFreq - 0.5) * amount;
                            mappedFreq = Math.tanh(Math.sinh(sinhInput) * 0.5) * 0.5 + 0.5;
                            magnitudeMultiplier = 1 + 0.2 * Math.abs(Math.sinh(sinhInput));
                            break;

                        case 'cosh':
                            // Hyperbolic cosine: U-shaped transformation
                            const coshInput = (normalizedFreq - 0.5) * amount;
                            mappedFreq = (Math.cosh(coshInput) - 1) / (Math.cosh(amount) - 1);
                            break;

                        case 'tanh':
                            // Hyperbolic tangent: saturation function
                            const tanhInput = (normalizedFreq - 0.5) * amount * 3;
                            mappedFreq = (Math.tanh(tanhInput) + 1) / 2;
                            magnitudeMultiplier = 1 + 0.3 * Math.abs(Math.tanh(tanhInput));
                            break;

                        // === COMPLEX OPERATIONS ===
                        case 'complex_magnitude':
                            // Distance from origin with phase modulation
                            const compReal = normalizedFreq * Math.cos(amount);
                            const compImag = normalizedFreq * Math.sin(amount);
                            mappedFreq = Math.sqrt(compReal * compReal + compImag * compImag);
                            break;

                        case 'complex_phase':
                            // Phase-based frequency mapping
                            const phaseAngle = normalizedFreq * Math.PI * amount;
                            mappedFreq = (Math.atan2(Math.sin(phaseAngle), Math.cos(phaseAngle)) + Math.PI) / (2 * Math.PI);
                            break;

                        case 'conjugate':
                            // Complex conjugate: frequency mirroring
                            mappedFreq = 1 - normalizedFreq * (amount * 0.1);
                            phaseShift = -phase * amount * 0.1;
                            break;

                        // === PHYSICS EQUATIONS ===
                        case 'schrodinger':
                            // Quantum harmonic oscillator
                            const x_pos = (normalizedFreq - 0.5) * 6;
                            const n_level = Math.floor(amount) % 10;
                            const hermite = Math.exp(-x_pos * x_pos / 2) * Math.pow(x_pos, n_level);
                            mappedFreq = normalizedFreq * (1 + 0.5 * hermite * (amount * 0.1));
                            magnitudeMultiplier = 1 + 0.3 * Math.abs(hermite);
                            break;

                        case 'heisenberg':
                            // Uncertainty principle: Δx·Δp ≥ ħ/2
                            const uncertainty = amount / (normalizedFreq * 10 + 1);
                            mappedFreq = normalizedFreq * (1 + uncertainty * 0.3);
                            magnitudeMultiplier = 1 + uncertainty * 0.2;
                            break;

                        case 'einstein_mass_energy':
                            // E = mc²: relativistic effects
                            const velocity = normalizedFreq * 0.99;
                            const gamma = 1 / Math.sqrt(1 - velocity * velocity);
                            mappedFreq = normalizedFreq * (1 + (gamma - 1) * amount * 0.1);
                            magnitudeMultiplier = Math.sqrt(gamma) * (1 + amount * 0.1);
                            break;

                        case 'planck_radiation':
                            // Blackbody radiation curve
                            const temp = 1000 + amount * 500; // Temperature
                            const planckCurve = Math.pow(normalizedFreq, 3) / (Math.exp(normalizedFreq * 20 / temp) - 1);
                            mappedFreq = normalizedFreq * (1 + planckCurve * amount * 0.1);
                            magnitudeMultiplier = 1 + planckCurve * amount * 0.2;
                            break;

                        case 'wave_equation':
                            // Standing wave patterns
                            const modeNum = Math.floor(amount) % 20 + 1;
                            const standingWave = Math.sin(normalizedFreq * Math.PI * modeNum);
                            mappedFreq = normalizedFreq * (1 + standingWave * amount * 0.1);
                            magnitudeMultiplier = 1 + Math.abs(standingWave) * amount * 0.3;
                            break;

                        // === FRACTALS ===
                        case 'mandelbrot':
                            // Mandelbrot set escape time
                            let zr = (normalizedFreq - 0.5) * 3;
                            let zi = 0;
                            const cr = -0.5 + amount * 0.1;
                            const ci = 0.6 * amount * 0.1;
                            let iter = 0;
                            const maxIter = 50;

                            while (iter < maxIter && zr * zr + zi * zi < 4) {
                                const temp = zr * zr - zi * zi + cr;
                                zi = 2 * zr * zi + ci;
                                zr = temp;
                                iter++;
                            }

                            const escape = iter / maxIter;
                            mappedFreq = normalizedFreq * (0.5 + escape * 0.5 * amount * 0.1);
                            magnitudeMultiplier = 0.5 + escape * amount * 0.1;
                            break;

                        case 'julia':
                            // Julia set
                            const juliaC_r = -0.7 + amount * 0.05;
                            const juliaC_i = 0.27 + amount * 0.05;
                            let jr = (normalizedFreq - 0.5) * 2;
                            let ji = 0.1 * amount;
                            let juliaIter = 0;

                            while (juliaIter < 30 && jr * jr + ji * ji < 4) {
                                const temp = jr * jr - ji * ji + juliaC_r;
                                ji = 2 * jr * ji + juliaC_i;
                                jr = temp;
                                juliaIter++;
                            }

                            const juliaEscape = juliaIter / 30;
                            mappedFreq = normalizedFreq * (0.3 + juliaEscape * 0.7 * amount * 0.1);
                            break;

                        // === GEOMETRIC TRANSFORMATIONS ===
                        case 'mobius':
                            // Möbius transformation: z' = (az + b) / (cz + d)
                            const a = 1 + amount * 0.1;
                            const b = amount * 0.05;
                            const c = amount * 0.03;
                            const d = 1;
                            const mobZ = normalizedFreq + 0.1;
                            mappedFreq = Math.abs((a * mobZ + b) / (c * mobZ + d)) % 1;
                            break;

                        case 'joukowsky':
                            // Joukowsky airfoil transformation
                            const jouZ = normalizedFreq * 2 - 1; // -1 to 1
                            const jouResult = 0.5 * (jouZ + amount * 0.2 / (jouZ + 0.01));
                            mappedFreq = (jouResult + 1) / 2;
                            mappedFreq = Math.max(0, Math.min(1, mappedFreq));
                            break;

                        case 'spiral':
                            // Logarithmic spiral
                            const spiralR = normalizedFreq;
                            const spiralTheta = normalizedFreq * Math.PI * 2 * amount;
                            const spiralX = spiralR * Math.cos(spiralTheta);
                            mappedFreq = (spiralX + 1) / 2;
                            break;

                        // Add more functions...
                        default:
                            // For unimplemented functions, apply a default transformation
                            mappedFreq = Math.pow(normalizedFreq, 1 + amount * 0.1);
                            break;
                    }

                    // Apply simple frequency clamping to prevent aliasing
                    mappedFreq = Math.max(0, Math.min(1, mappedFreq));

                    // Convert back to actual frequency in the selected range
                    const newFrequency = minFreq + mappedFreq * (maxFreq - minFreq);
                    const newBin = Math.round(newFrequency / binSize);

                    // Only place frequency content in valid bins
                    if (newBin > 0 && newBin < fftSize / 2) {
                        // Apply magnitude and phase modifications
                        const finalMagnitude = magnitude * magnitudeMultiplier;
                        const finalPhase = phase + phaseShift;

                        // Convert back to real/imaginary
                        real[newBin] += finalMagnitude * Math.cos(finalPhase);
                        imag[newBin] += finalMagnitude * Math.sin(finalPhase);

                        // Mirror for negative frequencies (maintain symmetry)
                        const negBin = fftSize - newBin;
                        if (negBin < fftSize) {
                            real[negBin] = real[newBin];
                            imag[negBin] = -imag[newBin];
                        }
                    }
                }

                // Preserve DC component
                real[0] = tempReal[0];
                imag[0] = 0;

            } catch (error) {
                console.error(`Error in applyComplexFunction (${funcName}):`, error);
                // On error, just copy original data
                for (let i = 0; i < fftSize; i++) {
                    real[i] = tempReal[i];
                    imag[i] = tempImag[i];
                }
            }
        }

        // STFT Implementation
        function stft(audioData, fftSize, hopSize, windowFunc) {
            const numFrames = Math.floor((audioData.length - fftSize) / hopSize) + 1;
            const frames = [];

            for (let i = 0; i < numFrames; i++) {
                const start = i * hopSize;
                const frame = audioData.slice(start, start + fftSize);

                // Apply window
                for (let j = 0; j < fftSize; j++) {
                    frame[j] *= windowFunc[j];
                }

                frames.push(frame);
            }

            return frames;
        }

        // Custom FFT Implementation
        function fft(real, imag) {
            const n = real.length;
            if (n <= 1) return;

            // Ensure n is a power of 2
            if ((n & (n - 1)) !== 0) {
                console.error('FFT size must be a power of 2');
                return;
            }

            // Bit-reversal permutation
            for (let i = 0; i < n; i++) {
                let j = 0;
                let temp = i;
                for (let k = 0; k < Math.log2(n); k++) {
                    j = (j << 1) | (temp & 1);
                    temp >>= 1;
                }
                if (j > i) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
            }

            // Cooley-Tukey FFT
            for (let len = 2; len <= n; len *= 2) {
                const angle = -2 * Math.PI / len;
                const wlen = { re: Math.cos(angle), im: Math.sin(angle) };

                for (let i = 0; i < n; i += len) {
                    let w = { re: 1, im: 0 };

                    for (let j = 0; j < len / 2; j++) {
                        const u = { re: real[i + j], im: imag[i + j] };
                        const v = {
                            re: real[i + j + len / 2] * w.re - imag[i + j + len / 2] * w.im,
                            im: real[i + j + len / 2] * w.im + imag[i + j + len / 2] * w.re
                        };

                        real[i + j] = u.re + v.re;
                        imag[i + j] = u.im + v.im;
                        real[i + j + len / 2] = u.re - v.re;
                        imag[i + j + len / 2] = u.im - v.im;

                        const newW = {
                            re: w.re * wlen.re - w.im * wlen.im,
                            im: w.re * wlen.im + w.im * wlen.re
                        };
                        w = newW;
                    }
                }
            }
        }

        // Inverse FFT
        function ifft(real, imag) {
            const n = real.length;

            // Conjugate
            for (let i = 0; i < n; i++) {
                imag[i] = -imag[i];
            }

            // Forward FFT
            fft(real, imag);

            // Conjugate and scale
            for (let i = 0; i < n; i++) {
                real[i] /= n;
                imag[i] = -imag[i] / n;
            }
        }

        // Main audio processing function with proper frequency transformations
        async function processAudio() {
            if (!audioBuffer) {
                showStatus('No audio loaded', 'error');
                return null;
            }

            showStatus('Processing audio...', 'info');

            try {
                const fftSize = Math.pow(2, parseInt(document.getElementById('fftSizeSlider').value));
                const overlapFactor = Math.pow(2, parseInt(document.getElementById('overlapSlider').value));
                const hopSize = Math.floor(fftSize / overlapFactor);
                const amount = parseFloat(document.getElementById('powerSlider').value);
                const smoothing = parseFloat(document.getElementById('smoothingSlider').value);
                const mixValue = parseFloat(document.getElementById('mixSlider').value) / 100;
                const gain = parseFloat(document.getElementById('gainSlider').value);

                console.log(`Processing with FFT size: ${fftSize}, hop size: ${hopSize}, amount: ${amount}`);

                const audioData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                const windowFunc = getWindow(fftSize);

                // Perform STFT
                const frames = stft(audioData, fftSize, hopSize, windowFunc);
                const processedFrames = [];

                console.log(`Processing ${frames.length} frames`);

                for (let frameIdx = 0; frameIdx < frames.length; frameIdx++) {
                    const frame = frames[frameIdx];
                    const real = getBuffer(fftSize, 'real');
                    const imag = getBuffer(fftSize, 'imag');

                    // Copy frame data and zero-pad if necessary
                    for (let i = 0; i < fftSize; i++) {
                        real[i] = i < frame.length ? frame[i] : 0;
                        imag[i] = 0;
                    }

                    // Forward FFT
                    fft(real, imag);

                    // Apply complex frequency transformations
                    applyComplexFunction(real, imag, fftSize, sampleRate, selectedFunction, amount);

                    // Apply smoothing in frequency domain
                    if (smoothing > 0) {
                        for (let i = 1; i < fftSize / 2 - 1; i++) {
                            const prevReal = real[i - 1];
                            const prevImag = imag[i - 1];
                            const nextReal = real[i + 1];
                            const nextImag = imag[i + 1];

                            real[i] = real[i] * (1 - smoothing) + (prevReal + nextReal) * smoothing / 2;
                            imag[i] = imag[i] * (1 - smoothing) + (prevImag + nextImag) * smoothing / 2;

                            // Update mirrored bins
                            real[fftSize - i] = real[i];
                            imag[fftSize - i] = -imag[i];
                        }
                    }

                    // Inverse FFT
                    ifft(real, imag);

                    // Store raw IFFT output (no additional windowing)
                    processedFrames.push(real.slice(0, fftSize));
                }

                // Overlap-add reconstruction with proper normalization
                const outputLength = (frames.length - 1) * hopSize + fftSize;
                const outputBuffer = new Float32Array(outputLength);
                const normBuffer = new Float32Array(outputLength);

                // Calculate window normalization factor for overlap-add
                for (let i = 0; i < frames.length; i++) {
                    const start = i * hopSize;
                    for (let j = 0; j < fftSize; j++) {
                        if (start + j < outputLength) {
                            normBuffer[start + j] += windowFunc[j] * windowFunc[j];
                        }
                    }
                }

                // Reconstruct with proper windowing and normalization
                for (let i = 0; i < processedFrames.length; i++) {
                    const start = i * hopSize;
                    for (let j = 0; j < fftSize; j++) {
                        if (start + j < outputLength) {
                            // Apply synthesis window and accumulate
                            outputBuffer[start + j] += processedFrames[i][j] * windowFunc[j];
                        }
                    }
                }

                // Normalize to prevent amplitude modulation
                for (let i = 0; i < outputLength; i++) {
                    if (normBuffer[i] > 1e-12) {
                        outputBuffer[i] /= normBuffer[i];
                    }
                }

                // Mix with original signal
                const mixedBuffer = new Float32Array(Math.min(outputBuffer.length, audioData.length));
                for (let i = 0; i < mixedBuffer.length; i++) {
                    const dry = audioData[i];
                    const wet = outputBuffer[i] * gain;
                    mixedBuffer[i] = dry * (1 - mixValue) + wet * mixValue;
                }

                // Create new audio buffer
                const newBuffer = ctx.createBuffer(1, mixedBuffer.length, sampleRate);
                newBuffer.copyToChannel(mixedBuffer, 0);

                showStatus('Audio processing complete!', 'success');
                updateMemoryInfo();

                return newBuffer;

            } catch (error) {
                showStatus(`Error processing audio: ${error.message}`, 'error');
                console.error('Audio processing error:', error);
                return null;
            }
        }

        // Visualization
        function setupVisualization() {
            canvas = document.getElementById('visualizerCanvas');
            canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        function drawVisualization() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const timeArray = new Uint8Array(analyser.fftSize);

            analyser.getByteFrequencyData(dataArray);
            analyser.getByteTimeDomainData(timeArray);

            // Clear canvas with fade effect
            canvasCtx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw frequency spectrum (top half)
            const freqHeight = canvas.height / 2;
            const barWidth = canvas.width / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * freqHeight;

                // Color based on frequency and transformation
                const hue = (i / bufferLength) * 360;
                const saturation = 70 + (dataArray[i] / 255) * 30;
                const lightness = 40 + (dataArray[i] / 255) * 20;

                canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                canvasCtx.fillRect(x, freqHeight - barHeight, barWidth, barHeight);

                x += barWidth;
            }

            // Draw waveform (bottom half)
            canvasCtx.strokeStyle = '#4ecdc4';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();

            const sliceWidth = canvas.width / timeArray.length;
            x = 0;

            for (let i = 0; i < timeArray.length; i++) {
                const v = (timeArray[i] - 128) / 128;
                const y = freqHeight + (v * freqHeight / 2) + freqHeight / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.stroke();

            // Draw function name and parameters
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            canvasCtx.font = '16px Segoe UI';
            canvasCtx.fillText(`Function: ${complexFunctions[selectedFunction].name}`, 10, 25);

            if (isPlaying) {
                canvasCtx.fillStyle = 'rgba(78, 205, 196, 0.8)';
                canvasCtx.fillText('● REAL-TIME', 10, 50);
            }

            // Update time sliders for playing tracks
            updateTimeSliders();

            if (isPlaying) {
                animationId = requestAnimationFrame(drawVisualization);
            }
        }

        // Function to update time sliders during playback
        function updateTimeSliders() {
            if (!ctx) return;

            // Update Track A slider
            if (isPlayingA && trackStartTimeA !== undefined) {
                const currentTimeA = ctx.currentTime - trackStartTimeA;
                const durationA = audioBufferA ? audioBufferA.duration : 0;

                if (durationA > 0) {
                    trackPositionA = currentTimeA % durationA; // Handle looping
                    const sliderA = document.getElementById('timeSliderA');
                    const valueA = document.getElementById('timeValueA');

                    if (sliderA && !timeSliderADragging) { // Don't update if user is dragging
                        sliderA.value = trackPositionA;
                        const minutes = Math.floor(trackPositionA / 60);
                        const seconds = Math.floor(trackPositionA % 60);
                        valueA.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }

            // Update Track B slider
            if (isPlayingB && trackStartTimeB !== undefined) {
                const currentTimeB = ctx.currentTime - trackStartTimeB;
                const durationB = audioBufferB ? audioBufferB.duration : 0;

                if (durationB > 0) {
                    trackPositionB = currentTimeB % durationB; // Handle looping
                    const sliderB = document.getElementById('timeSliderB');
                    const valueB = document.getElementById('timeValueB');

                    if (sliderB && !timeSliderBDragging) { // Don't update if user is dragging
                        sliderB.value = trackPositionB;
                        const minutes = Math.floor(trackPositionB / 60);
                        const seconds = Math.floor(trackPositionB % 60);
                        valueB.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }
        }

        // Robust real-time audio processor with proper overlap-add
        function setupRealtimeAudio() {
            if (!ctx || (!audioBufferA && !audioBufferB)) return;

            try {
                // Create script processor for real-time effects
                scriptProcessor = ctx.createScriptProcessor(4096, 1, 1);
                analyser = ctx.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.3;

                // FFT processing setup
                const fftSize = 2048;
                const hopSize = fftSize / 4; // 75% overlap
                const windowFunc = createOptimalHannWindow(fftSize, hopSize);

                // Delay line for overlap-add
                let inputDelay = new Float32Array(fftSize);
                let outputDelay = new Float32Array(fftSize);
                let frameCounter = 0;

                // Initialize processor parameters with all current settings
                scriptProcessor.params = {
                    ...realtimeParams,
                    antiAliasingMode: realtimeParams.antiAliasingMode,
                    frequencyMapping: realtimeParams.frequencyMapping
                };
                // Set global reference to processor
                realtimeProcessor = scriptProcessor;

                scriptProcessor.onaudioprocess = function (audioProcessingEvent) {
                    const input = audioProcessingEvent.inputBuffer.getChannelData(0);
                    const output = audioProcessingEvent.outputBuffer.getChannelData(0);

                    // Get current parameters from the processor object
                    let amount = scriptProcessor.params.amount;
                    const mixValue = scriptProcessor.params.mix;
                    const gain = scriptProcessor.params.gain;

                    // Apply modulation to amount if enabled
                    if (scriptProcessor.params.modEnabled) {
                        const minAmount = scriptProcessor.params.modMinAmount || 0.0;
                        const maxAmount = scriptProcessor.params.modMaxAmount || amount;
                        const currentTime = ctx.currentTime;
                        const startTime = scriptProcessor.params.modStartTime;
                        const modPeriod = scriptProcessor.params.modPeriod;

                        // Calculate elapsed time and position in modulation cycle
                        const elapsedTime = currentTime - startTime;
                        const normalizedPosition = (elapsedTime % modPeriod) / modPeriod;

                        // Sinusoidal modulation between min and max bounds
                        const modulationFactor = Math.sin(normalizedPosition * 2 * Math.PI);
                        amount = minAmount + (maxAmount - minAmount) * (modulationFactor * 0.5 + 0.5);
                    }

                    for (let n = 0; n < input.length; n++) {
                        // Shift delay lines
                        for (let i = 0; i < fftSize - 1; i++) {
                            inputDelay[i] = inputDelay[i + 1];
                            outputDelay[i] = outputDelay[i + 1];
                        }
                        inputDelay[fftSize - 1] = input[n];
                        outputDelay[fftSize - 1] = 0;

                        // Process frame every hopSize samples
                        if (frameCounter % hopSize === 0) {
                            // Prepare FFT buffers
                            const real = new Float32Array(fftSize);
                            const imag = new Float32Array(fftSize);

                            // Apply window to input
                            for (let i = 0; i < fftSize; i++) {
                                real[i] = inputDelay[i] * windowFunc[i];
                                imag[i] = 0;
                            }

                            // Forward FFT
                            fft(real, imag);

                            // Apply frequency transformation
                            applyComplexFunction(real, imag, fftSize, ctx.sampleRate, selectedFunction, amount);

                            // Inverse FFT
                            ifft(real, imag);

                            // Apply synthesis window and overlap-add
                            for (let i = 0; i < fftSize; i++) {
                                outputDelay[i] += real[i] * windowFunc[i];
                            }
                        }

                        // Output with proper mix
                        const wet = outputDelay[0] * gain;
                        output[n] = input[n] * (1 - mixValue) + wet * mixValue;

                        frameCounter++;
                    }
                };

                return scriptProcessor;

            } catch (error) {
                console.error('Error setting up real-time audio:', error);
                return null;
            }
        }

        function createOptimalHannWindow(size, hopSize) {
            const window = new Float32Array(size);

            // Create basic Hann window
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Calculate the optimal normalization for constant amplitude with overlap-add
            // For Hann window with 75% overlap (hopSize = size/4), we need to compensate
            // for the overlapping window energy

            // Test the overlap sum at the center of the window
            let overlapSum = 0;
            const center = Math.floor(size / 2);

            // Sum all overlapping windows at the center point
            for (let offset = -size; offset <= size; offset += hopSize) {
                const index = center + offset;
                if (index >= 0 && index < size) {
                    overlapSum += window[index] * window[index];
                }
            }

            // Normalize so that overlapping windows sum to constant amplitude
            const normFactor = 1.0 / Math.sqrt(overlapSum);
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        // Hann window creation for analysis
        function createHannWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Normalize for overlap-add with 75% overlap (hopSize = size/4)
            // This ensures constant amplitude reconstruction
            let sum = 0;
            const hopSize = size / 4;
            for (let i = 0; i < size; i++) {
                let overlap = 0;
                for (let j = -3; j <= 3; j++) { // Check overlapping windows
                    const pos = i + j * hopSize;
                    if (pos >= 0 && pos < size) {
                        overlap += window[pos] * window[pos];
                    }
                }
                if (overlap > sum) sum = overlap;
            }

            // Apply normalization factor
            const normFactor = 1.0 / Math.sqrt(sum);
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        function createSimpleHannWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
            }

            // Simple normalization for 75% overlap
            // For Hann window with 75% overlap, the normalization factor is approximately 2/3
            const normFactor = 2.0 / 3.0;
            for (let i = 0; i < size; i++) {
                window[i] *= normFactor;
            }

            return window;
        }

        // Update real-time amount display with modulated value and slider animation
        function updateModulatedDisplay() {
            if (!isPlaying || !realtimeProcessor || !realtimeProcessor.params.modEnabled) {
                // If modulation is off, restore original amount display and remove animation
                if (realtimeProcessor && realtimeProcessor.params) {
                    const powerValue = document.getElementById('powerValue');
                    const powerSlider = document.getElementById('powerSlider');
                    if (powerValue) {
                        powerValue.textContent = realtimeProcessor.params.amount.toFixed(3);
                    }
                    if (powerSlider) {
                        powerSlider.classList.remove('animated');
                    }
                }
                return;
            }

            const powerValue = document.getElementById('powerValue');
            const powerSlider = document.getElementById('powerSlider');
            if (!powerValue || !powerSlider) return;

            const amount = realtimeProcessor.params.amount;
            const minAmount = realtimeProcessor.params.modMinAmount || 0.0;
            const maxAmount = realtimeProcessor.params.modMaxAmount || amount;
            const currentTime = ctx.currentTime;
            const startTime = realtimeProcessor.params.modStartTime;
            const modPeriod = realtimeProcessor.params.modPeriod;

            // Calculate elapsed time and position in modulation cycle
            const elapsedTime = currentTime - startTime;
            const normalizedPosition = (elapsedTime % modPeriod) / modPeriod;

            // Sinusoidal modulation between min and max bounds
            const modulationFactor = Math.sin(normalizedPosition * 2 * Math.PI);
            const modulatedAmount = minAmount + (maxAmount - minAmount) * (modulationFactor * 0.5 + 0.5);

            // Update display with the current modulated value and bounds
            powerValue.textContent = `${modulatedAmount.toFixed(3)} (${minAmount.toFixed(3)}→${maxAmount.toFixed(3)})`;

            // Add animation class to slider
            powerSlider.classList.add('animated');

            // Move the slider thumb to match the modulated value
            const sliderMin = parseFloat(powerSlider.min);
            const sliderMax = parseFloat(powerSlider.max);
            const clampedValue = Math.max(sliderMin, Math.min(sliderMax, modulatedAmount));
            powerSlider.value = clampedValue;

            // Set CSS custom property for smooth animation
            const percentage = ((clampedValue - sliderMin) / (sliderMax - sliderMin)) * 100;
            powerSlider.style.setProperty('--modulation-position', `${percentage}%`);

            // Update pulse indicator position to move between red and green handles
            const pulseIndicator = document.querySelector('.dual-slider-container .pulse-indicator');
            if (pulseIndicator) {
                // Calculate position based on modulation factor (-1 to 1, but we want 0 to 1)
                const normalizedFactor = (modulationFactor + 1) / 2; // Convert -1→1 to 0→1

                // Get slider values for positioning
                const minSliderValue = parseFloat(document.getElementById('modMinSlider').value);
                const maxSliderValue = parseFloat(document.getElementById('modMaxSlider').value);

                // Calculate position as percentage between min and max handles
                const minPos = ((minSliderValue - sliderMin) / (sliderMax - sliderMin)) * 100;
                const maxPos = ((maxSliderValue - sliderMin) / (sliderMax - sliderMin)) * 100;
                const currentPos = minPos + (maxPos - minPos) * normalizedFactor;

                pulseIndicator.style.left = `${currentPos}%`;
            }

            // Update the internal processor amount in real-time
            if (realtimeProcessor.params) {
                realtimeProcessor.params.amount = modulatedAmount;
            }

            // Update crossfader modulation sync if enabled
            if (typeof updateCrossfaderModulation === 'function') {
                updateCrossfaderModulation();
            }

            // Request next animation frame
            requestAnimationFrame(updateModulatedDisplay);
        }

        // Setup real-time parameter updates
        function setupRealtimeParameterUpdates() {
            // This function can be empty for bypass mode
            // In full mode, it would update FFT processing parameters in real-time
        }

        // Create output filters
        function createOutputFilters() {
            if (!ctx) return;

            try {
                // Create low pass filter
                lowPassFilter = ctx.createBiquadFilter();
                lowPassFilter.type = 'lowpass';
                lowPassFilter.frequency.setValueAtTime(realtimeParams.lowPassFreq, ctx.currentTime);
                lowPassFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Create high pass filter
                highPassFilter = ctx.createBiquadFilter();
                highPassFilter.type = 'highpass';
                highPassFilter.frequency.setValueAtTime(realtimeParams.highPassFreq, ctx.currentTime);
                highPassFilter.Q.setValueAtTime(0.7, ctx.currentTime);

                // Chain them together: highpass -> lowpass
                highPassFilter.connect(lowPassFilter);

                console.log('Output filters created');
            } catch (error) {
                console.error('Error creating output filters:', error);
            }
        }

        // Setup filter slider handlers
        function setupFilterControls() {
            // Output Filters (High/Low Pass)
            setupDualSlider('outputFilter', 1, 20000,
                (min, max) => {
                    realtimeParams.highPassFreq = min;
                    realtimeParams.lowPassFreq = max;

                    if (highPassFilter) {
                        highPassFilter.frequency.setTargetAtTime(min, ctx.currentTime, 0.1);
                    }
                    if (lowPassFilter) {
                        lowPassFilter.frequency.setTargetAtTime(max, ctx.currentTime, 0.1);
                    }
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );

            // Delay Filter Range
            setupDualSlider('delayFilter', 20, 20000,
                (min, max) => {
                    realtimeParams.delayLowCut = min;
                    realtimeParams.delayHighCut = max;
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );

            // Reverb Filter Range  
            setupDualSlider('reverbFilter', 20, 20000,
                (min, max) => {
                    realtimeParams.reverbLowCut = min;
                    realtimeParams.reverbHighCut = max;
                },
                (min, max) => `${formatFreq(min)} → ${formatFreq(max)}`
            );
        }

        function formatFreq(freq) {
            if (freq >= 1000) {
                return `${(freq / 1000).toFixed(freq >= 10000 ? 0 : 1)}kHz`;
            } else {
                return `${freq}Hz`;
            }
        }

        function setupDualSlider(baseName, minVal, maxVal, onUpdate, formatDisplay) {
            const minSlider = document.getElementById(baseName + 'MinSlider');
            const maxSlider = document.getElementById(baseName + 'MaxSlider');
            const valueDisplay = document.getElementById(baseName + 'Value');

            if (!minSlider || !maxSlider) return;

            let currentMin = minVal;
            let currentMax = maxVal;

            function updateDisplay() {
                const displayText = formatDisplay(currentMin, currentMax);
                if (valueDisplay) valueDisplay.textContent = displayText;
                onUpdate(currentMin, currentMax);
            }

            function handleSliderChange() {
                const minValue = parseInt(minSlider.value);
                const maxValue = parseInt(maxSlider.value);

                // Prevent handles from crossing - if they try to cross, snap them together
                if (minValue >= maxValue) {
                    currentMin = maxValue;
                    currentMax = maxValue;
                    minSlider.value = currentMin;
                    maxSlider.value = currentMax;
                } else {
                    currentMin = minValue;
                    currentMax = maxValue;
                }

                updateDisplay();
            }

            minSlider.addEventListener('input', handleSliderChange);
            maxSlider.addEventListener('input', handleSliderChange);

            // Initialize display
            updateDisplay();
        }

        // Event listeners and initialization
        document.addEventListener('DOMContentLoaded', function () {
            // Optimal ranges for each function based on frequency analysis
            function getOptimalRange(functionName) {
                switch (functionName) {
                    // Basic Operations - Fine-tuned for frequency effects
                    case 'power': return { min: 0.1, max: 4.0, optimal: 1.5 };
                    case 'sqrt': return { min: 0.2, max: 3.0, optimal: 1.0 };
                    case 'cbrt': return { min: 0.3, max: 4.0, optimal: 1.5 };
                    case 'nroot': return { min: 0.2, max: 6.0, optimal: 2.0 };
                    case 'square': return { min: 0.1, max: 1.8, optimal: 1.0 };
                    case 'cube': return { min: 0.1, max: 1.4, optimal: 0.8 };
                    case 'inverse': return { min: 0.2, max: 5.0, optimal: 1.5 };

                    // Logarithmic & Exponential - Adjusted for audio frequency range
                    case 'log': return { min: 0.1, max: 8.0, optimal: 2.0 };
                    case 'log10': return { min: 0.5, max: 15.0, optimal: 5.0 };
                    case 'log2': return { min: 0.3, max: 12.0, optimal: 4.0 };
                    case 'exp': return { min: 0.01, max: 0.4, optimal: 0.15 };
                    case 'exp2': return { min: 0.05, max: 0.6, optimal: 0.25 };
                    case 'exp10': return { min: 0.005, max: 0.15, optimal: 0.05 };

                    // Trigonometric - Optimized for harmonic effects
                    case 'sin': return { min: 0.5, max: 25.0, optimal: 8.0 };
                    case 'cos': return { min: 0.5, max: 25.0, optimal: 8.0 };
                    case 'tan': return { min: 0.2, max: 8.0, optimal: 2.0 };
                    case 'asin': return { min: 0.1, max: 1.8, optimal: 0.8 };
                    case 'acos': return { min: 0.1, max: 1.8, optimal: 0.8 };
                    case 'atan': return { min: 0.5, max: 50.0, optimal: 15.0 };

                    // Hyperbolic - Tuned for dynamic range
                    case 'sinh': return { min: 0.05, max: 1.8, optimal: 0.6 };
                    case 'cosh': return { min: 0.05, max: 1.8, optimal: 0.6 };
                    case 'tanh': return { min: 0.5, max: 15.0, optimal: 5.0 };
                    case 'asinh': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'acosh': return { min: 0.2, max: 4.0, optimal: 1.5 };
                    case 'atanh': return { min: 0.1, max: 1.5, optimal: 0.8 };

                    // Special Functions - Optimized for unique effects
                    case 'gamma': return { min: 0.2, max: 4.0, optimal: 1.5 };
                    case 'bessel_j0': return { min: 1.0, max: 60.0, optimal: 20.0 };
                    case 'bessel_y0': return { min: 0.8, max: 35.0, optimal: 12.0 };
                    case 'erf': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'airy_ai': return { min: 0.5, max: 15.0, optimal: 6.0 };

                    // Fractal Functions - Balanced for audio stability
                    case 'mandelbrot': return { min: 0.2, max: 3.0, optimal: 1.0 };
                    case 'julia': return { min: 0.1, max: 2.5, optimal: 0.8 };
                    case 'burning_ship': return { min: 0.1, max: 1.8, optimal: 0.6 };
                    case 'newton_raphson': return { min: 0.1, max: 1.5, optimal: 0.5 };
                    case 'logistic_map': return { min: 1.0, max: 3.9, optimal: 2.8 };

                    // Geometric Transformations
                    case 'mobius': return { min: 0.3, max: 8.0, optimal: 2.5 };
                    case 'joukowsky': return { min: 0.2, max: 4.0, optimal: 1.5 };

                    // Spiral Transformations - Enhanced for motion effects
                    case 'spiral': return { min: 0.3, max: 8.0, optimal: 3.0 };
                    case 'fibonacci_spiral': return { min: 0.2, max: 6.0, optimal: 2.0 };

                    // Wave Functions - Optimized for interference patterns
                    case 'wave': return { min: 0.5, max: 18.0, optimal: 6.0 };
                    case 'ripple': return { min: 1.0, max: 35.0, optimal: 12.0 };
                    case 'sinc_function': return { min: 1.0, max: 80.0, optimal: 25.0 };
                    case 'chirp': return { min: 0.2, max: 12.0, optimal: 4.0 };

                    // Physics Equations - Tuned for realistic effects
                    case 'schrodinger': return { min: 0.1, max: 5.0, optimal: 1.5 };
                    case 'heisenberg': return { min: 0.3, max: 10.0, optimal: 3.0 };
                    case 'einstein_mass_energy': return { min: 0.1, max: 2.0, optimal: 0.8 };
                    case 'planck_radiation': return { min: 0.2, max: 8.0, optimal: 2.5 };
                    case 'maxwell_boltzmann': return { min: 0.5, max: 12.0, optimal: 4.0 };
                    case 'wave_equation': return { min: 0.3, max: 15.0, optimal: 5.0 };
                    case 'lorentz_factor': return { min: 0.1, max: 3.0, optimal: 1.0 };
                    case 'schwarzschild': return { min: 0.1, max: 4.0, optimal: 1.2 };

                    // Default for unspecified functions
                    default: return { min: 0.1, max: 20.0, optimal: 1.0 };
                }
            }

            // Initialize function grid
            function initFunctionSelect() {
                const select = document.getElementById('functionSelect');

                // Set initial value
                select.value = selectedFunction;

                // Add event listener
                select.addEventListener('change', function () {
                    selectedFunction = this.value;

                    // Update slider range based on selected function
                    updateSliderRange(selectedFunction);

                    showStatus(`Function changed to: ${complexFunctions[selectedFunction].name}`, 'info');
                });
            }

            // Update slider range when function changes
            function updateSliderRange(functionName) {
                const range = getOptimalRange(functionName);
                const powerSlider = document.getElementById('powerSlider');
                const modMinSlider = document.getElementById('modMinSlider');
                const modMaxSlider = document.getElementById('modMaxSlider');

                if (powerSlider) {
                    powerSlider.min = range.min;
                    powerSlider.max = range.max;
                    powerSlider.value = range.optimal;

                    // Update display
                    document.getElementById('powerValue').textContent = range.optimal.toFixed(3);
                    realtimeParams.amount = range.optimal;
                    if (realtimeProcessor && realtimeProcessor.params) {
                        realtimeProcessor.params.amount = range.optimal;
                    }
                }

                if (modMinSlider && modMaxSlider) {
                    modMinSlider.min = range.min;
                    modMinSlider.max = range.max;
                    modMaxSlider.min = range.min;
                    modMaxSlider.max = range.max;

                    // Set reasonable modulation range
                    modMinSlider.value = range.min;
                    modMaxSlider.value = range.optimal;
                }
            }

            function initSliders() {
                const sliders = {
                    powerSlider: (val) => {
                        document.getElementById('powerValue').textContent = parseFloat(val).toFixed(3);
                        realtimeParams.amount = parseFloat(val);
                        if (realtimeProcessor && realtimeProcessor.params) {
                            realtimeProcessor.params.amount = parseFloat(val);
                        }
                    },
                    modPeriodSlider: (val) => {
                        const sliderValue = parseFloat(val);

                        if (sliderValue === 0) {
                            // Modulation off
                            document.getElementById('modStatus').textContent = 'Off';
                            document.getElementById('modPeriodValue').textContent = 'Off';
                            realtimeParams.modEnabled = false;
                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.modEnabled = false;
                            }

                            // Reset amount display to show normal value
                            if (realtimeProcessor && realtimeProcessor.params) {
                                const powerValue = document.getElementById('powerValue');
                                if (powerValue) {
                                    powerValue.textContent = realtimeProcessor.params.amount.toFixed(3);
                                }
                            }
                        } else {
                            // Map slider value to minutes: 0.01-1.0 -> 0.1-1min, 1.0-2.0 -> 1-10min
                            let minutes;
                            if (sliderValue <= 1.0) {
                                // First half: 0.01 to 1.0 maps to 0.1 to 1 minute
                                minutes = 0.1 + (sliderValue * 0.9);
                            } else {
                                // Second half: 1.0 to 2.0 maps to 1 to 10 minutes  
                                minutes = 1 + ((sliderValue - 1.0) * 9);
                            }

                            // Convert minutes to seconds
                            const period = minutes * 60;

                            // Format display 
                            let displayValue;
                            if (minutes < 1) {
                                displayValue = `${(minutes * 60).toFixed(0)}s`;
                            } else {
                                displayValue = `${minutes.toFixed(1)}min`;
                            }

                            document.getElementById('modStatus').textContent = 'On';
                            document.getElementById('modPeriodValue').textContent = displayValue;

                            realtimeParams.modEnabled = true;
                            realtimeParams.modPeriod = period;
                            realtimeParams.modStartTime = ctx ? ctx.currentTime : 0;

                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.modEnabled = true;
                                realtimeProcessor.params.modPeriod = period;
                                realtimeProcessor.params.modStartTime = ctx ? ctx.currentTime : 0;
                            }

                            // Start modulation display updates if playing
                            if (isPlaying) {
                                requestAnimationFrame(updateModulatedDisplay);
                            }
                        }
                    },
                    mixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('mixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxTransformMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.mix = mixValue;
                            if (realtimeProcessor && realtimeProcessor.params) {
                                realtimeProcessor.params.mix = mixValue;
                            }
                        }
                    },
                    gainSlider: (val) => {
                        const gainDb = parseFloat(val);
                        let displayText;
                        if (gainDb <= -60) {
                            displayText = '-∞dB';
                            realtimeParams.gain = 0;
                        } else {
                            displayText = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                            realtimeParams.gain = Math.pow(10, gainDb / 20);
                        }
                        document.getElementById('gainValue').textContent = displayText;

                        if (realtimeProcessor && realtimeProcessor.params) {
                            realtimeProcessor.params.gain = realtimeParams.gain;
                        }
                    },

                    // Delay controls
                    delayTimeSlider: (val) => {
                        const timeMs = parseInt(val);
                        const timeSec = timeMs / 1000;
                        document.getElementById('delayTimeValue').textContent = timeMs === 0 ? '0.0s' : `${timeMs}ms`;
                        realtimeParams.delayTime = timeSec;
                        if (delayNode) {
                            delayNode.delayTime.setTargetAtTime(timeSec, ctx.currentTime, 0.01);
                        }
                    },
                    delayFeedbackSlider: (val) => {
                        const feedback = parseInt(val) / 100;
                        document.getElementById('delayFeedbackValue').textContent = `${val}%`;
                        realtimeParams.delayFeedback = feedback;
                        if (delayFeedbackNode) {
                            delayFeedbackNode.gain.setTargetAtTime(feedback, ctx.currentTime, 0.01);
                        }
                    },
                    delayMixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('delayMixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxDelayMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.delayMix = mixValue;
                            if (delayWetGainNode && delayDryGainNode) {
                                delayWetGainNode.gain.setTargetAtTime(mixValue, ctx.currentTime, 0.01);
                                delayDryGainNode.gain.setTargetAtTime(1.0 - mixValue, ctx.currentTime, 0.01);
                            }
                        }
                    },

                    // Reverb controls
                    reverbRoomSizeSlider: (val) => {
                        const roomSize = parseInt(val) / 100;
                        document.getElementById('reverbRoomSizeValue').textContent = `${val}%`;
                        realtimeParams.reverbRoomSize = roomSize;
                        // Recreate reverb impulse response with new room size
                        recreateReverbImpulse();
                    },
                    reverbDecaySlider: (val) => {
                        const decay = parseFloat(val);
                        document.getElementById('reverbDecayValue').textContent = `${decay.toFixed(1)}s`;
                        realtimeParams.reverbDecay = decay;
                        // Recreate reverb impulse response with new decay time
                        recreateReverbImpulse();
                    },
                    reverbMixSlider: (val) => {
                        const mixValue = parseInt(val) / 100;
                        document.getElementById('reverbMixValue').textContent = `${val}%`;

                        if (realtimeParams.fadeSyncEnabled) {
                            // Store the manual value and apply crossfader modulation
                            realtimeParams.fadeSyncMaxReverbMix = mixValue;
                            updateFadeSyncMix();
                        } else {
                            // Normal operation when FadeSync is off
                            realtimeParams.reverbMix = mixValue;
                            if (reverbWetGainNode && reverbDryGainNode) {
                                reverbWetGainNode.gain.setTargetAtTime(mixValue, ctx.currentTime, 0.01);
                                reverbDryGainNode.gain.setTargetAtTime(1.0 - mixValue, ctx.currentTime, 0.01);
                            }
                        }
                    },

                    // Output gain control (-∞ to +18dB)
                    outputGainSlider: (val) => {
                        const gainDb = parseFloat(val);
                        let displayText;
                        if (gainDb <= -60) {
                            displayText = '-∞dB';
                            realtimeParams.outputGainDb = -Infinity;
                            realtimeParams.finalOutputGain = 0;
                        } else {
                            displayText = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                            realtimeParams.outputGainDb = gainDb;
                            realtimeParams.finalOutputGain = Math.pow(10, gainDb / 20);
                        }
                        document.getElementById('outputGainValue').textContent = displayText;

                        if (finalOutputGainNode) {
                            finalOutputGainNode.gain.setTargetAtTime(realtimeParams.finalOutputGain, ctx.currentTime, 0.01);
                        }
                    },

                    // Delay filter controls are now handled by dual-handle sliders in setupFilterControls

                    // Reverb filter controls are now handled by dual-handle sliders in setupFilterControls
                };

                Object.entries(sliders).forEach(([id, callback]) => {
                    const slider = document.getElementById(id);
                    if (slider) {
                        slider.addEventListener('input', (e) => callback(e.target.value));
                        // Initialize display without triggering processor updates
                        const currentValue = slider.value;
                        if (id === 'powerSlider') {
                            document.getElementById('powerValue').textContent = parseFloat(currentValue).toFixed(3);
                            realtimeParams.amount = parseFloat(currentValue);
                        } else if (id === 'modPeriodSlider') {
                            // Initialize modulation slider display with new 0-2 scale
                            const sliderValue = parseFloat(currentValue);
                            if (sliderValue === 0) {
                                document.getElementById('modStatus').textContent = 'Off';
                                document.getElementById('modPeriodValue').textContent = 'Off';
                                realtimeParams.modEnabled = false;
                            } else {
                                // Map slider value to minutes: 0.01-1.0 -> 0.1-1min, 1.0-2.0 -> 1-10min
                                let minutes;
                                if (sliderValue <= 1.0) {
                                    minutes = 0.1 + (sliderValue * 0.9);
                                } else {
                                    minutes = 1 + ((sliderValue - 1.0) * 9);
                                }

                                const period = minutes * 60;
                                let displayValue;
                                if (minutes < 1) {
                                    displayValue = `${(minutes * 60).toFixed(0)}s`;
                                } else {
                                    displayValue = `${minutes.toFixed(1)}min`;
                                }

                                document.getElementById('modStatus').textContent = 'On';
                                document.getElementById('modPeriodValue').textContent = displayValue;
                                realtimeParams.modEnabled = true;
                                realtimeParams.modPeriod = period;
                            }
                        } else if (id === 'mixSlider') {
                            document.getElementById('mixValue').textContent = `${currentValue}%`;
                            realtimeParams.mix = parseInt(currentValue) / 100;
                        } else if (id === 'gainSlider') {
                            const gainDb = parseFloat(currentValue);
                            if (gainDb <= -60) {
                                document.getElementById('gainValue').textContent = '-∞dB';
                                realtimeParams.gain = 0;
                            } else {
                                document.getElementById('gainValue').textContent = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                                realtimeParams.gain = Math.pow(10, gainDb / 20);
                            }
                        } else if (id === 'delayTimeSlider') {
                            const timeMs = parseInt(currentValue);
                            document.getElementById('delayTimeValue').textContent = timeMs === 0 ? '0.0s' : `${timeMs}ms`;
                            realtimeParams.delayTime = timeMs / 1000;
                        } else if (id === 'delayFeedbackSlider') {
                            document.getElementById('delayFeedbackValue').textContent = `${currentValue}%`;
                            realtimeParams.delayFeedback = parseInt(currentValue) / 100;
                        } else if (id === 'delayMixSlider') {
                            document.getElementById('delayMixValue').textContent = `${currentValue}%`;
                            realtimeParams.delayMix = parseInt(currentValue) / 100;
                        } else if (id === 'reverbRoomSizeSlider') {
                            document.getElementById('reverbRoomSizeValue').textContent = `${currentValue}%`;
                            realtimeParams.reverbRoomSize = parseInt(currentValue) / 100;
                        } else if (id === 'reverbDecaySlider') {
                            document.getElementById('reverbDecayValue').textContent = `${parseFloat(currentValue).toFixed(1)}s`;
                            realtimeParams.reverbDecay = parseFloat(currentValue);
                        } else if (id === 'reverbMixSlider') {
                            document.getElementById('reverbMixValue').textContent = `${currentValue}%`;
                            realtimeParams.reverbMix = parseInt(currentValue) / 100;
                        } else if (id === 'outputGainSlider') {
                            const gainDb = parseFloat(currentValue);
                            if (gainDb <= -60) {
                                document.getElementById('outputGainValue').textContent = '-∞dB';
                                realtimeParams.outputGainDb = -Infinity;
                                realtimeParams.finalOutputGain = 0;
                            } else {
                                document.getElementById('outputGainValue').textContent = `${gainDb >= 0 ? '+' : ''}${gainDb.toFixed(1)}dB`;
                                realtimeParams.outputGainDb = gainDb;
                                realtimeParams.finalOutputGain = Math.pow(10, gainDb / 20);
                            }
                        }
                        // Delay and reverb filter initialization is now handled by setupFilterControls
                    }
                });

                // Initialize dual-handle modulation bounds sliders
                const modMinSlider = document.getElementById('modMinSlider');
                const modMaxSlider = document.getElementById('modMaxSlider');
                const modRangeValue = document.getElementById('modRangeValue');
                const dualSliderContainer = document.querySelector('.dual-slider-container');

                if (modMinSlider && modMaxSlider && modRangeValue) {
                    function updateModulationBounds() {
                        const minVal = parseFloat(modMinSlider.value);
                        const maxVal = parseFloat(modMaxSlider.value);

                        // Ensure min is always less than max
                        if (minVal >= maxVal) {
                            if (this === modMinSlider) {
                                modMaxSlider.value = (minVal + 0.001).toFixed(3);
                            } else {
                                modMinSlider.value = (maxVal - 0.001).toFixed(3);
                            }
                        }

                        const finalMin = parseFloat(modMinSlider.value);
                        const finalMax = parseFloat(modMaxSlider.value);

                        // Update display
                        modRangeValue.textContent = `${finalMin.toFixed(3)} → ${finalMax.toFixed(3)}`;

                        // Update parameters
                        realtimeParams.modMinAmount = finalMin;
                        realtimeParams.modMaxAmount = finalMax;
                        if (realtimeProcessor && realtimeProcessor.params) {
                            realtimeProcessor.params.modMinAmount = finalMin;
                            realtimeProcessor.params.modMaxAmount = finalMax;
                        }
                    }

                    modMinSlider.addEventListener('input', updateModulationBounds);
                    modMaxSlider.addEventListener('input', updateModulationBounds);

                    // Initialize display
                    updateModulationBounds();

                    // Toggle visibility based on modulation state
                    function updateModulationVisibility() {
                        if (realtimeParams.modEnabled) {
                            dualSliderContainer.classList.remove('modulation-disabled');
                        } else {
                            dualSliderContainer.classList.add('modulation-disabled');
                        }
                    }

                    // Initial visibility update
                    updateModulationVisibility();

                    // Update visibility when modulation period changes
                    const modPeriodSlider = document.getElementById('modPeriodSlider');
                    if (modPeriodSlider) {
                        modPeriodSlider.addEventListener('input', () => {
                            setTimeout(updateModulationVisibility, 0); // Update after the main callback
                        });
                    }
                }
            }

            // Enhanced dual-track file input with drag-and-drop support
            function setupDualTrackFileInputs() {
                setupTrackFileInput('A');
                setupTrackFileInput('B');
            }

            function setupTrackFileInput(track) {
                const fileInput = document.getElementById(`fileInput${track}`);
                const dropZone = document.getElementById(`fileDropZone${track}`);

                // Handle file selection (both click and drag-drop)
                async function handleFile(file) {
                    if (!file) return;

                    showStatus(`📁 Loading Track ${track}: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)...`, 'info');
                    console.log(`Loading Track ${track} file: ${file.name}, size: ${file.size} bytes, type: ${file.type}`);

                    try {
                        // Enhanced file type checking - check both MIME type and extension
                        const supportedExtensions = ['wav', 'mp3', 'ogg', 'webm', 'm4a', 'aac', 'flac', 'opus'];
                        const supportedMimeTypes = [
                            'audio/wav', 'audio/wave', 'audio/x-wav',
                            'audio/mp3', 'audio/mpeg', 'audio/mp4',
                            'audio/ogg', 'audio/opus',
                            'audio/webm', 'audio/m4a', 'audio/aac',
                            'audio/flac', 'audio/x-flac'
                        ];

                        const fileExtension = file.name.toLowerCase().split('.').pop();
                        const mimeType = file.type.toLowerCase();

                        const isValidExtension = supportedExtensions.includes(fileExtension);
                        const isValidMimeType = supportedMimeTypes.some(type => mimeType.includes(type.replace('audio/', '')));

                        if (!isValidExtension && !isValidMimeType) {
                            throw new Error(`Unsupported file format: ${fileExtension || mimeType}.\nSupported formats: ${supportedExtensions.join(', ').toUpperCase()}`);
                        }

                        // Initialize audio context first
                        await initAudioContext();
                        console.log(`Audio context initialized, reading Track ${track} file...`);
                        showStatus(`🔄 Reading Track ${track} data...`, 'info');

                        // Read file as array buffer with progress
                        const arrayBuffer = await file.arrayBuffer();
                        console.log(`Track ${track} file read complete, buffer size: ${arrayBuffer.byteLength} bytes`);
                        showStatus(`🎵 Decoding Track ${track} audio (${fileExtension?.toUpperCase() || 'unknown format'})...`, 'info');

                        // Decode audio data with comprehensive error handling
                        try {
                            const audioBuffer = await ctx.decodeAudioData(arrayBuffer);

                            // Store in appropriate track variable
                            if (track === 'A') {
                                audioBufferA = audioBuffer;
                                trackDurationA = audioBuffer.duration;
                                document.getElementById('timeSliderA').max = trackDurationA;
                                document.getElementById('playBtnA').disabled = false;
                                console.log(`Track A loaded: duration=${trackDurationA}s, slider max set to ${trackDurationA}`);
                            } else {
                                audioBufferB = audioBuffer;
                                trackDurationB = audioBuffer.duration;
                                document.getElementById('timeSliderB').max = trackDurationB;
                                document.getElementById('playBtnB').disabled = false;
                                console.log(`Track B loaded: duration=${trackDurationB}s, slider max set to ${trackDurationB}`);
                            }

                            const duration = audioBuffer.duration;
                            const sampleRate = audioBuffer.sampleRate;
                            const channels = audioBuffer.numberOfChannels;
                            const samples = audioBuffer.length;

                            console.log(`Track ${track} decoded successfully:
            - File: ${file.name}
            - Duration: ${duration.toFixed(2)}s
            - Sample Rate: ${sampleRate}Hz
            - Channels: ${channels} (${channels === 1 ? 'Mono' : channels === 2 ? 'Stereo' : channels + '-channel'})
            - Samples: ${samples.toLocaleString()}
            - Size: ${(file.size / 1024 / 1024).toFixed(1)}MB`);

                            showStatus(`✅ Track ${track} Ready: ${file.name} | ${duration.toFixed(1)}s | ${sampleRate}Hz | ${channels}ch`, 'success');

                            // Update drop zone text to show loaded file
                            const dropText = dropZone.querySelector('.file-drop-text');
                            dropText.textContent = `✅ ${file.name.substring(0, 20)}...`;
                            dropZone.style.borderColor = track === 'A' ? 'rgba(78, 205, 196, 0.7)' : 'rgba(255, 107, 107, 0.7)';
                            dropZone.style.background = track === 'A' ? 'rgba(78, 205, 196, 0.1)' : 'rgba(255, 107, 107, 0.1)';

                            // Show audio info in status for user
                            setTimeout(() => {
                                showStatus(`🎵 Track ${track}: ${file.name} loaded (${duration.toFixed(1)}s, ${channels === 1 ? 'Mono' : 'Stereo'})`, 'success');
                            }, 2000);

                        } catch (decodeError) {
                            console.error(`Track ${track} decoding failed:`, decodeError);

                            // Provide specific error messages for common issues
                            let errorMessage = `Failed to decode Track ${track} audio file.`;
                            if (decodeError.message.includes('Unable to decode')) {
                                errorMessage = `Cannot decode Track ${track} ${fileExtension?.toUpperCase() || 'this'} file. It may be corrupted, DRM-protected, or in an unsupported codec.`;
                            } else if (decodeError.message.includes('InvalidStateError')) {
                                errorMessage = `Track ${track} audio context error. Try refreshing the page and loading the file again.`;
                            } else if (decodeError.message.includes('DataError')) {
                                errorMessage = `Track ${track} invalid audio data. The file may be corrupted or not a valid audio file.`;
                            }

                            throw new Error(`${errorMessage}\n\nTechnical details: ${decodeError.message}`);
                        }

                    } catch (error) {
                        const errorMsg = error.message.replace('Error: ', '');
                        showStatus(`❌ Track ${track}: ${errorMsg}`, 'error');
                        console.error(`Track ${track} loading error:`, error);

                        // Reset file input and disable play button
                        fileInput.value = '';
                        document.getElementById(`playBtn${track}`).disabled = true;
                        if (track === 'A') {
                            audioBufferA = null;
                            trackDurationA = 0;
                        } else {
                            audioBufferB = null;
                            trackDurationB = 0;
                        }

                        // Reset drop zone appearance
                        const dropText = dropZone.querySelector('.file-drop-text');
                        dropText.textContent = `🎵 Drop audio file ${track} here or click`;
                        dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        dropZone.style.background = 'rgba(255, 255, 255, 0.05)';
                    }
                }

                // File input change event
                fileInput.addEventListener('change', async function (e) {
                    const file = e.target.files[0];
                    await handleFile(file);
                });

                // Drag and drop events
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                });

                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        // Also update the file input to reflect the dropped file
                        const dt = new DataTransfer();
                        dt.items.add(file);
                        fileInput.files = dt.files;
                        await handleFile(file);
                    }
                });

                // Click on drop zone to trigger file input
                dropZone.addEventListener('click', (event) => {
                    // Only trigger file input if clicking directly on the drop zone, not on child buttons
                    if (event.target === dropZone || event.target.classList.contains('file-drop-text')) {
                        fileInput.click();
                    }
                });
            }

            // Legacy cleanup - removed old single-track handlers

            // Dual Track Play/Stop button handlers
            // Track A Play/Stop button
            document.getElementById('playBtnA').addEventListener('click', async function (event) {
                event.preventDefault();
                event.stopPropagation();
                await toggleTrackPlayback('A');
            });

            // Track B Play/Stop button  
            document.getElementById('playBtnB').addEventListener('click', async function (event) {
                event.preventDefault();
                event.stopPropagation();
                await toggleTrackPlayback('B');
            });

            // Track A Stop button
            const stopBtnA = document.getElementById('stopBtnA');
            if (stopBtnA) {
                console.log('Stop button A found and adding event listener');

                // Clear all existing handlers and attributes
                stopBtnA.onclick = null;
                stopBtnA.removeAttribute('onclick');
                stopBtnA.removeAttribute('href');
                stopBtnA.setAttribute('type', 'button'); // Ensure it's a button

                // Define the stop handler
                const stopHandlerA = async function (event) {
                    console.log('Stop button A activated!', event.type, event.target);

                    // Immediately block all event propagation
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();

                    // Additional debugging
                    console.log('Event target:', event.target);
                    console.log('Event currentTarget:', event.currentTarget);
                    console.log('Event phase:', event.eventPhase);

                    try {
                        await stopTrack('A');
                        console.log('Stop track A completed');
                    } catch (error) {
                        console.error('Error in stop track A:', error);
                    }

                    return false;
                };

                // Add multiple event listeners to catch all possible interactions
                stopBtnA.addEventListener('click', stopHandlerA, { capture: true, passive: false });
                stopBtnA.addEventListener('mousedown', stopHandlerA, { capture: true, passive: false });
                stopBtnA.addEventListener('touchstart', stopHandlerA, { capture: true, passive: false });

            } else {
                console.error('Stop button A not found!');
            }

            // Track B Stop button
            const stopBtnB = document.getElementById('stopBtnB');
            if (stopBtnB) {
                console.log('Stop button B found and adding event listener');

                // Clear all existing handlers and attributes
                stopBtnB.onclick = null;
                stopBtnB.removeAttribute('onclick');
                stopBtnB.removeAttribute('href');
                stopBtnB.setAttribute('type', 'button'); // Ensure it's a button

                // Define the stop handler
                const stopHandlerB = async function (event) {
                    console.log('Stop button B activated!', event.type, event.target);

                    // Immediately block all event propagation
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();

                    // Additional debugging
                    console.log('Event target:', event.target);
                    console.log('Event currentTarget:', event.currentTarget);
                    console.log('Event phase:', event.eventPhase);

                    try {
                        await stopTrack('B');
                        console.log('Stop track B completed');
                    } catch (error) {
                        console.error('Error in stop track B:', error);
                    }

                    return false;
                };

                // Add multiple event listeners to catch all possible interactions
                stopBtnB.addEventListener('click', stopHandlerB, { capture: true, passive: false });
                stopBtnB.addEventListener('mousedown', stopHandlerB, { capture: true, passive: false });
                stopBtnB.addEventListener('touchstart', stopHandlerB, { capture: true, passive: false });

            } else {
                console.error('Stop button B not found!');
            }

            // Track timing functions
            async function toggleTrackPlayback(track) {
                const isPlayingTrack = track === 'A' ? isPlayingA : isPlayingB;
                const playBtn = document.getElementById(`playBtn${track}`);

                if (isPlayingTrack) {
                    await pauseTrack(track);
                } else {
                    await playTrack(track);
                }
            } async function playTrack(track) {
                const audioBuffer = track === 'A' ? audioBufferA : audioBufferB;
                const playBtn = document.getElementById(`playBtn${track}`);

                if (!audioBuffer) {
                    showStatus(`Please load Track ${track} first`, 'error');
                    return;
                }

                try {
                    await initAudioContext();

                    // Initialize mixed playback system if not already running
                    if (!isPlaying) {
                        await startMixedPlaybackSystem();
                    }

                    playBtn.textContent = track === 'A' ? '⏸️ Pause A' : '⏸️ Pause B';

                    // Create source for the track
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.loop = true;

                    // Get current track position
                    const startPosition = track === 'A' ? trackPositionA : trackPositionB;

                    // Connect to appropriate mixer channel
                    if (track === 'A') {
                        if (currentSourceA) {
                            currentSourceA.stop();
                        }
                        currentSourceA = source;
                        source.connect(mixerGainNodeA);
                        isPlayingA = true;
                        trackStartTimeA = ctx.currentTime - startPosition;

                        // When track A starts, trigger FadeSync update if enabled
                        if (realtimeParams.fadeSyncEnabled) {
                            updateFadeSyncMix();
                        }
                    } else {
                        if (currentSourceB) {
                            currentSourceB.stop();
                        }
                        currentSourceB = source;
                        source.connect(mixerGainNodeB);
                        isPlayingB = true;
                        trackStartTimeB = ctx.currentTime - startPosition;

                        // When track B starts, trigger FadeSync update if enabled
                        if (realtimeParams.fadeSyncEnabled) {
                            updateFadeSyncMix();
                        }
                    }

                    source.onended = () => {
                        if (track === 'A') {
                            isPlayingA = false;
                            playBtn.textContent = '▶️ Play A';
                            currentSourceA = null;
                        } else {
                            isPlayingB = false;
                            playBtn.textContent = '▶️ Play B';
                            currentSourceB = null;
                        }
                    };

                    // Start playback from the current position
                    source.start(0, startPosition);
                    showStatus(`Track ${track} playing through transformer`, 'info');

                } catch (error) {
                    showStatus(`Error playing Track ${track}: ${error.message}`, 'error');
                    console.error(`Track ${track} playback error:`, error);
                }
            }

            async function pauseTrack(track) {
                const playBtn = document.getElementById(`playBtn${track}`);

                try {
                    if (track === 'A' && currentSourceA) {
                        // Save current position before stopping
                        trackPositionA = ctx.currentTime - trackStartTimeA;

                        currentSourceA.stop();
                        currentSourceA = null;
                        isPlayingA = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play A';
                        }

                    } else if (track === 'B' && currentSourceB) {
                        // Save current position before stopping
                        trackPositionB = ctx.currentTime - trackStartTimeB;

                        currentSourceB.stop();
                        currentSourceB = null;
                        isPlayingB = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play B';
                        }
                    }

                    // If no tracks are playing, stop the mixed system
                    if (!isPlayingA && !isPlayingB) {
                        await stopMixedPlayback();
                    }

                    showStatus(`Track ${track} paused`, 'info');

                } catch (error) {
                    console.error(`Error pausing track ${track}:`, error);
                    showStatus(`Error pausing Track ${track}: ${error.message}`, 'error');
                }
            }

            async function stopTrack(track) {
                const playBtn = document.getElementById(`playBtn${track}`);

                try {
                    if (track === 'A' && currentSourceA) {
                        currentSourceA.stop();
                        currentSourceA = null;
                        isPlayingA = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play A';
                        }
                        trackPositionA = 0; // Reset position

                        // Reset time slider
                        const timeSliderA = document.getElementById('timeSliderA');
                        const timeValueA = document.getElementById('timeValueA');
                        if (timeSliderA) timeSliderA.value = 0;
                        if (timeValueA) timeValueA.textContent = '0:00';

                    } else if (track === 'B' && currentSourceB) {
                        currentSourceB.stop();
                        currentSourceB = null;
                        isPlayingB = false;
                        if (playBtn) {
                            playBtn.textContent = '▶️ Play B';
                        }
                        trackPositionB = 0; // Reset position

                        // Reset time slider
                        const timeSliderB = document.getElementById('timeSliderB');
                        const timeValueB = document.getElementById('timeValueB');
                        if (timeSliderB) timeSliderB.value = 0;
                        if (timeValueB) timeValueB.textContent = '0:00';
                    }

                    // If no tracks are playing, stop the mixed system
                    if (!isPlayingA && !isPlayingB) {
                        await stopMixedPlayback();
                    }

                    showStatus(`Track ${track} stopped`, 'info');

                } catch (error) {
                    console.error(`Error stopping track ${track}:`, error);
                    showStatus(`Error stopping Track ${track}: ${error.message}`, 'error');
                }
            }

            // Function to scrub track to specific position
            function scrubTrack(track, position) {
                console.log(`scrubTrack called: track=${track}, position=${position}`);
                try {
                    if (track === 'A' && currentSourceA && audioBufferA && isPlayingA) {
                        console.log(`Scrubbing track A from ${trackPositionA} to ${position}`);
                        // Stop current source (but don't trigger button state change)
                        currentSourceA.onended = null; // Remove the onended handler to prevent button state change
                        currentSourceA.stop();

                        // Create new source starting at the specified position
                        const newSource = ctx.createBufferSource();
                        newSource.buffer = audioBufferA;
                        newSource.loop = true;
                        newSource.connect(mixerGainNodeA);

                        // Start from the scrubbed position
                        newSource.start(0, position);
                        currentSourceA = newSource;
                        trackStartTimeA = ctx.currentTime - position;

                        // Set onended handler for natural track ending (not scrubbing)
                        newSource.onended = () => {
                            // Only change button state if the track actually ended naturally
                            if (isPlayingA) {
                                isPlayingA = false;
                                document.getElementById('playBtnA').textContent = '▶️ Play A';
                                currentSourceA = null;
                                console.log('Track A ended naturally');
                            }
                        };

                        console.log(`Track A scrubbed successfully to ${position}s`);

                    } else if (track === 'B' && currentSourceB && audioBufferB && isPlayingB) {
                        console.log(`Scrubbing track B from ${trackPositionB} to ${position}`);
                        // Stop current source (but don't trigger button state change)
                        currentSourceB.onended = null; // Remove the onended handler to prevent button state change
                        currentSourceB.stop();

                        // Create new source starting at the specified position
                        const newSource = ctx.createBufferSource();
                        newSource.buffer = audioBufferB;
                        newSource.loop = true;
                        newSource.connect(mixerGainNodeB);

                        // Start from the scrubbed position
                        newSource.start(0, position);
                        currentSourceB = newSource;
                        trackStartTimeB = ctx.currentTime - position;

                        // Set onended handler for natural track ending (not scrubbing)
                        newSource.onended = () => {
                            // Only change button state if the track actually ended naturally
                            if (isPlayingB) {
                                isPlayingB = false;
                                document.getElementById('playBtnB').textContent = '▶️ Play B';
                                currentSourceB = null;
                                console.log('Track B ended naturally');
                            }
                        };

                        console.log(`Track B scrubbed successfully to ${position}s`);
                    } else {
                        console.log(`Scrubbing skipped: track=${track}, playing=${track === 'A' ? isPlayingA : isPlayingB}, hasSource=${track === 'A' ? !!currentSourceA : !!currentSourceB}, hasBuffer=${track === 'A' ? !!audioBufferA : !!audioBufferB}`);
                    }
                } catch (error) {
                    console.error(`Error scrubbing track ${track}:`, error);
                    showStatus(`Error scrubbing track ${track}: ${error.message}`, 'error');
                }
            }

            // Initialize the mixed playback system (always runs when any track plays)
            async function startMixedPlaybackSystem() {
                if (isPlaying) return; // Already running

                try {
                    await initAudioContext();

                    // Create mixer nodes
                    mixerGainNodeA = ctx.createGain();
                    mixerGainNodeB = ctx.createGain();
                    mixerOutputNode = ctx.createGain();

                    // Update crossfader gains
                    updateCrossfaderGains();

                    // Connect mixer
                    mixerGainNodeA.connect(mixerOutputNode);
                    mixerGainNodeB.connect(mixerOutputNode);

                    // Create real-time processor
                    realtimeProcessor = setupRealtimeAudio();
                    if (!realtimeProcessor) {
                        throw new Error('Failed to create real-time processor');
                    }

                    // Create effects chain
                    const delayEffect = createDelayEffect();
                    const reverbEffect = createReverbEffect();
                    createOutputFilters();

                    // Create LUFS analyzers
                    inputLufsAnalyser = ctx.createAnalyser();
                    inputLufsAnalyser.fftSize = 2048;
                    inputLufsAnalyser.smoothingTimeConstant = 0.8;

                    outputLufsAnalyser = ctx.createAnalyser();
                    outputLufsAnalyser.fftSize = 2048;
                    outputLufsAnalyser.smoothingTimeConstant = 0.8;

                    // Connect mixed audio to processing chain
                    mixerOutputNode.connect(inputLufsAnalyser);
                    inputLufsAnalyser.connect(realtimeProcessor);

                    // Store effect references
                    delayNode = delayEffect ? delayEffect.delayNode : null;
                    delayFeedbackNode = delayEffect ? delayEffect.feedbackNode : null;
                    delayMixNode = delayEffect ? delayEffect.wetGainNode : null;
                    delayWetGainNode = delayEffect ? delayEffect.wetGainNode : null;
                    delayDryGainNode = delayEffect ? delayEffect.dryGainNode : null;

                    reverbNode = reverbEffect ? reverbEffect.reverbNode : null;
                    reverbMixNode = reverbEffect ? reverbEffect.wetGainNode : null;
                    reverbWetGainNode = reverbEffect ? reverbEffect.wetGainNode : null;
                    reverbDryGainNode = reverbEffect ? reverbEffect.dryGainNode : null;

                    // Create output gain and compressor
                    finalOutputGainNode = ctx.createGain();
                    finalOutputGainNode.gain.setValueAtTime(realtimeParams.finalOutputGain, ctx.currentTime);

                    compressorNode = ctx.createDynamicsCompressor();
                    compressorNode.threshold.setValueAtTime(-0.1, ctx.currentTime);
                    compressorNode.knee.setValueAtTime(0, ctx.currentTime);
                    compressorNode.ratio.setValueAtTime(20, ctx.currentTime);
                    compressorNode.attack.setValueAtTime(0.001, ctx.currentTime);
                    compressorNode.release.setValueAtTime(0.01, ctx.currentTime);

                    // Connect effects chain
                    if (delayEffect && reverbEffect && highPassFilter && lowPassFilter) {
                        realtimeProcessor.connect(delayEffect.input);
                        realtimeProcessor.connect(delayEffect.inputDry);
                        delayEffect.output.connect(reverbEffect.input);
                        delayEffect.output.connect(reverbEffect.inputDry);
                        reverbEffect.output.connect(highPassFilter);
                        lowPassFilter.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    } else if (highPassFilter && lowPassFilter) {
                        realtimeProcessor.connect(highPassFilter);
                        lowPassFilter.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    } else {
                        realtimeProcessor.connect(finalOutputGainNode);
                        finalOutputGainNode.connect(compressorNode);
                        compressorNode.connect(analyser);
                        analyser.connect(outputLufsAnalyser);
                        outputLufsAnalyser.connect(ctx.destination);
                    }

                    isPlaying = true;
                    isRealTimeMode = true;

                    // Start LUFS monitoring
                    if (lufsUpdateInterval) {
                        clearInterval(lufsUpdateInterval);
                    }
                    lufsUpdateInterval = setInterval(updateLUFSMeasurements, 50);

                    // Start visualization and modulation
                    animationId = requestAnimationFrame(drawVisualization);
                    if (realtimeParams.modEnabled) {
                        requestAnimationFrame(updateModulatedDisplay);
                    }

                    // Setup real-time parameter updates
                    setupRealtimeParameterUpdates();
                    setupVisualization();
                    drawVisualization();

                    showStatus(`🎧 Transform system initialized!`, 'success');

                } catch (error) {
                    isPlaying = false;
                    isRealTimeMode = false;
                    showStatus(`Error starting transform system: ${error.message}`, 'error');
                    console.error('Transform system error:', error);
                }
            }

            // Mixed playback with crossfading and processing
            async function toggleMixedPlayback() {
                if (isPlaying) {
                    await stopMixedPlayback();
                } else {
                    await playMixedTracks();
                }
            } async function playMixedTracks() {
                // This function is now deprecated - individual tracks handle mixed playback
                showStatus('Use individual track play buttons instead', 'info');
                return;
            }

            async function stopMixedPlayback() {
                // Stop LUFS monitoring
                if (lufsUpdateInterval) {
                    clearInterval(lufsUpdateInterval);
                    lufsUpdateInterval = null;
                }

                // Stop sources
                if (currentSourceA) {
                    currentSourceA.stop();
                    currentSourceA = null;
                }
                if (currentSourceB) {
                    currentSourceB.stop();
                    currentSourceB = null;
                }

                // Disconnect all nodes
                if (realtimeProcessor) {
                    realtimeProcessor.disconnect();
                    realtimeProcessor = null;
                }
                if (analyser) {
                    analyser.disconnect();
                }

                // Disconnect effects and mixers
                [delayNode, delayFeedbackNode, delayWetGainNode, delayDryGainNode,
                    reverbNode, reverbWetGainNode, reverbDryGainNode,
                    finalOutputGainNode, compressorNode, inputLufsAnalyser, outputLufsAnalyser,
                    mixerGainNodeA, mixerGainNodeB, mixerOutputNode].forEach(node => {
                        if (node) {
                            node.disconnect();
                        }
                    });

                // Reset variables
                isPlaying = false;
                isRealTimeMode = false;

                cancelAnimationFrame(animationId);
                showStatus('Mixed playback stopped', 'info');
            }

            // Crossfader and time control handlers
            function updateCrossfaderGains() {
                const crossfaderPos = realtimeParams.crossfaderValue / 100; // 0 to 1

                // Calculate gains using equal power law for smooth crossfading
                const gainA = Math.cos(crossfaderPos * Math.PI / 2);
                const gainB = Math.sin(crossfaderPos * Math.PI / 2);

                realtimeParams.crossfaderGainA = gainA;
                realtimeParams.crossfaderGainB = gainB;

                if (mixerGainNodeA) {
                    mixerGainNodeA.gain.setValueAtTime(gainA, ctx.currentTime);
                }
                if (mixerGainNodeB) {
                    mixerGainNodeB.gain.setValueAtTime(gainB, ctx.currentTime);
                }

                // Update display
                const crossfaderValue = document.getElementById('crossfaderValue');
                if (crossfaderPos < 0.1) {
                    crossfaderValue.textContent = 'A Only';
                } else if (crossfaderPos > 0.9) {
                    crossfaderValue.textContent = 'B Only';
                } else {
                    const percentA = Math.round(gainA * gainA * 100);
                    const percentB = Math.round(gainB * gainB * 100);
                    crossfaderValue.textContent = `A:${percentA}% B:${percentB}%`;
                }
            }

            // FadeSync: Effects intensity based on crossfader position
            // 100% Track A (0) = 0% effects, 50/50 mix (50) = 100% effects, 100% Track B (100) = 0% effects
            function updateFadeSyncMix() {
                if (!realtimeParams.fadeSyncEnabled) return;

                const crossfaderPos = realtimeParams.crossfaderValue / 100; // 0 to 1

                // Calculate effects mix factor: 0 at extremes (0 or 100), 1 at center (50)
                // Use a sine wave that peaks at 0.5 (center)
                const effectsMixFactor = Math.sin(crossfaderPos * Math.PI);

                // Debug logging
                console.log(`FadeSync Debug - Crossfader: ${crossfaderPos}, EffectsFactor: ${effectsMixFactor.toFixed(3)}`);

                // Update transform mix parameter (scaled by captured maximum)
                const transformMix = effectsMixFactor * realtimeParams.fadeSyncMaxTransformMix;
                realtimeParams.mix = transformMix;
                if (realtimeProcessor && realtimeProcessor.params) {
                    realtimeProcessor.params.mix = transformMix;
                }

                // Update transform mix slider display
                const mixSlider = document.getElementById('mixSlider');
                const mixValueDisplay = document.getElementById('mixValue');
                if (mixSlider && mixValueDisplay) {
                    mixSlider.value = Math.round(transformMix * 100);
                    mixValueDisplay.textContent = Math.round(transformMix * 100) + '%';
                }

                // Update delay mix parameter (scaled by captured maximum)
                const delayMix = effectsMixFactor * realtimeParams.fadeSyncMaxDelayMix;
                realtimeParams.delayMix = delayMix;
                const delayMixSlider = document.getElementById('delayMixSlider');
                const delayMixValueDisplay = document.getElementById('delayMixValue');
                if (delayMixSlider && delayMixValueDisplay) {
                    delayMixSlider.value = Math.round(delayMix * 100);
                    delayMixValueDisplay.textContent = Math.round(delayMix * 100) + '%';
                }
                // Update delay wet/dry mix in audio nodes
                if (delayWetGainNode && delayDryGainNode) {
                    delayWetGainNode.gain.setTargetAtTime(delayMix, ctx.currentTime, 0.01);
                    delayDryGainNode.gain.setTargetAtTime(1.0 - delayMix, ctx.currentTime, 0.01);
                }

                // Update reverb mix parameter (scaled by captured maximum)
                const reverbMix = effectsMixFactor * realtimeParams.fadeSyncMaxReverbMix;
                realtimeParams.reverbMix = reverbMix;
                console.log(`Reverb Debug - Max: ${realtimeParams.fadeSyncMaxReverbMix}, Mix: ${reverbMix.toFixed(3)}, Nodes: ${reverbWetGainNode ? 'OK' : 'NULL'}, ${reverbDryGainNode ? 'OK' : 'NULL'}`);

                const reverbMixSlider = document.getElementById('reverbMixSlider');
                const reverbMixValueDisplay = document.getElementById('reverbMixValue');
                if (reverbMixSlider && reverbMixValueDisplay) {
                    reverbMixSlider.value = Math.round(reverbMix * 100);
                    reverbMixValueDisplay.textContent = Math.round(reverbMix * 100) + '%';
                }
                // Update reverb wet/dry mix in audio nodes
                if (reverbWetGainNode && reverbDryGainNode) {
                    reverbWetGainNode.gain.setTargetAtTime(reverbMix, ctx.currentTime, 0.01);
                    reverbDryGainNode.gain.setTargetAtTime(1.0 - reverbMix, ctx.currentTime, 0.01);
                    console.log(`Reverb audio nodes updated: wet=${reverbMix.toFixed(3)}, dry=${(1.0 - reverbMix).toFixed(3)}`);
                }
            }

            // Crossfader slider event listener
            document.getElementById('crossfaderSlider').addEventListener('input', function () {
                realtimeParams.crossfaderValue = parseFloat(this.value);
                updateCrossfaderGains();
                // Update FadeSync mix if enabled
                if (realtimeParams.fadeSyncEnabled) {
                    updateFadeSyncMix();
                }
            });

            // FadeSync crossfader checkbox
            document.getElementById('fadeSyncCrossfader').addEventListener('change', function () {
                realtimeParams.fadeSyncEnabled = this.checked;
                showStatus(`FadeSync: ${this.checked ? 'ON' : 'OFF'}`, 'info');

                // Capture current slider values as maximums when FadeSync is enabled
                if (this.checked) {
                    // Capture current transform mix maximum
                    const mixSlider = document.getElementById('mixSlider');
                    if (mixSlider) {
                        realtimeParams.fadeSyncMaxTransformMix = parseInt(mixSlider.value) / 100;
                    }

                    // Capture current delay mix maximum
                    const delayMixSlider = document.getElementById('delayMixSlider');
                    if (delayMixSlider) {
                        realtimeParams.fadeSyncMaxDelayMix = parseInt(delayMixSlider.value) / 100;
                    }

                    // Capture current reverb mix maximum
                    const reverbMixSlider = document.getElementById('reverbMixSlider');
                    if (reverbMixSlider) {
                        realtimeParams.fadeSyncMaxReverbMix = parseInt(reverbMixSlider.value) / 100;
                    }

                    console.log('FadeSync maximums captured:', {
                        transform: realtimeParams.fadeSyncMaxTransformMix,
                        delay: realtimeParams.fadeSyncMaxDelayMix,
                        reverb: realtimeParams.fadeSyncMaxReverbMix
                    });

                    // Update mix immediately with captured maximums
                    updateFadeSyncMix();
                }
            });

            // Track time sliders with proper drag state tracking
            const timeSliderA = document.getElementById('timeSliderA');
            if (timeSliderA) {
                console.log('Time slider A found, setting up event listeners');

                // Track drag state with specific events for this slider
                const handleMouseDownA = () => {
                    timeSliderADragging = true;
                    console.log('Time slider A drag started');
                };

                const handleMouseUpA = () => {
                    if (timeSliderADragging) {
                        console.log('Time slider A drag ended');
                        timeSliderADragging = false;
                    }
                };

                const handleTouchStartA = () => {
                    timeSliderADragging = true;
                    console.log('Time slider A touch started');
                };

                const handleTouchEndA = () => {
                    if (timeSliderADragging) {
                        console.log('Time slider A touch ended');
                        timeSliderADragging = false;
                    }
                };

                // Add event listeners
                timeSliderA.addEventListener('mousedown', handleMouseDownA);
                timeSliderA.addEventListener('touchstart', handleTouchStartA);

                // Use document-level events but check if this specific slider was being dragged
                document.addEventListener('mouseup', handleMouseUpA);
                document.addEventListener('touchend', handleTouchEndA);

                // Also handle mouse leave events to ensure drag state is reset
                timeSliderA.addEventListener('mouseleave', () => {
                    if (timeSliderADragging) {
                        console.log('Time slider A mouse left while dragging - ending drag');
                        timeSliderADragging = false;
                    }
                });

                timeSliderA.addEventListener('input', function () {
                    console.log(`Time slider A moved to: ${this.value}, dragging: ${timeSliderADragging}`);
                    trackPositionA = parseFloat(this.value);
                    const minutes = Math.floor(trackPositionA / 60);
                    const seconds = Math.floor(trackPositionA % 60);
                    document.getElementById('timeValueA').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    // Scrub track A to the new position if playing
                    if (isPlayingA && currentSourceA && audioBufferA) {
                        console.log(`Scrubbing track A to position: ${trackPositionA}`);
                        scrubTrack('A', trackPositionA);
                    }
                });

                // Handle the change event (fires when user releases slider)
                timeSliderA.addEventListener('change', function () {
                    console.log(`Time slider A change event: ${this.value}`);
                    timeSliderADragging = false; // Ensure drag state is reset
                });

            } else {
                console.error('Time slider A not found!');
            }

            const timeSliderB = document.getElementById('timeSliderB');
            if (timeSliderB) {
                console.log('Time slider B found, setting up event listeners');

                // Track drag state with specific events for this slider
                const handleMouseDownB = () => {
                    timeSliderBDragging = true;
                    console.log('Time slider B drag started');
                };

                const handleMouseUpB = () => {
                    if (timeSliderBDragging) {
                        console.log('Time slider B drag ended');
                        timeSliderBDragging = false;
                    }
                };

                const handleTouchStartB = () => {
                    timeSliderBDragging = true;
                    console.log('Time slider B touch started');
                };

                const handleTouchEndB = () => {
                    if (timeSliderBDragging) {
                        console.log('Time slider B touch ended');
                        timeSliderBDragging = false;
                    }
                };

                // Add event listeners
                timeSliderB.addEventListener('mousedown', handleMouseDownB);
                timeSliderB.addEventListener('touchstart', handleTouchStartB);

                // Use document-level events but check if this specific slider was being dragged
                document.addEventListener('mouseup', handleMouseUpB);
                document.addEventListener('touchend', handleTouchEndB);

                // Also handle mouse leave events to ensure drag state is reset
                timeSliderB.addEventListener('mouseleave', () => {
                    if (timeSliderBDragging) {
                        console.log('Time slider B mouse left while dragging - ending drag');
                        timeSliderBDragging = false;
                    }
                });

                timeSliderB.addEventListener('input', function () {
                    console.log(`Time slider B moved to: ${this.value}, dragging: ${timeSliderBDragging}`);
                    trackPositionB = parseFloat(this.value);
                    const minutes = Math.floor(trackPositionB / 60);
                    const seconds = Math.floor(trackPositionB % 60);
                    document.getElementById('timeValueB').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    // Scrub track B to the new position if playing
                    if (isPlayingB && currentSourceB && audioBufferB) {
                        console.log(`Scrubbing track B to position: ${trackPositionB}`);
                        scrubTrack('B', trackPositionB);
                    }
                });

                // Handle the change event (fires when user releases slider)
                timeSliderB.addEventListener('change', function () {
                    console.log(`Time slider B change event: ${this.value}`);
                    timeSliderBDragging = false; // Ensure drag state is reset
                });

            } else {
                console.error('Time slider B not found!');
            }

            // Crossfader modulation sync function (deprecated - now using FadeSync)
            function updateCrossfaderModulation() {
                // This function is no longer used - FadeSync handles effects mixing
                // Keep for compatibility with existing mod system calls
            }

            // Global error handler for all audio operations
            window.addEventListener('error', function (event) {
                if (event.error && event.error.message &&
                    (event.error.message.includes('audio') ||
                        event.error.message.includes('AudioContext') ||
                        event.error.message.includes('TypeError'))) {
                    console.error('Audio error caught by global handler:', event.error);
                    showStatus(`Error: ${event.error.message}. Try clicking the play button first.`, 'error');
                    event.preventDefault();
                }
            });

            // Initialize everything
            initFunctionSelect();
            initSliders();
            setupDualTrackFileInputs(); // Updated for dual track system
            setupVisualization();
            setupFilterControls();

            // Set initial optimal range for default function
            updateSliderRange(selectedFunction);

            // Initialize crossfader
            updateCrossfaderGains();

            showStatus('Ultimate Dual-Track Complex Audio Transformer ready! Load audio files or generate test audio.', 'info');
            updateMemoryInfo();
        });
    </script>
</body>

</html>
